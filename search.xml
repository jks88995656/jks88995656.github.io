<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Keras  CNN 实现 MNIST 手写数字识别</title>
    <url>/2021/09/03/Keras%20%20CNN%20%E5%AE%9E%E7%8E%B0%20MNIST%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>@<a href="Keras  CNN 实现 MNIST 手写数字识别">TOC</a></p>
<p>我们就以 MNIST数据集的手写识别 为例子</p>
<h1 id="导入需要的包"><a href="#导入需要的包" class="headerlink" title="导入需要的包"></a>导入需要的包</h1><p>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span>  Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Dropout,Convolution2D,MaxPooling2D,Flatten</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_backend())</span><br></pre></td></tr></table></figure>
<h1 id="载入MNIST-数据"><a href="#载入MNIST-数据" class="headerlink" title="载入MNIST 数据"></a>载入MNIST 数据</h1><p>该数据集一共有训练集 6w 张，测试集 1w 张<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_images,train_labels),(test_images,test_labels)= mnist.load_data()</span><br></pre></td></tr></table></figure></p>
<p>可以查看一下图像和标签  是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字5</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签5</span></span><br><span class="line"><span class="built_in">print</span>(train_labels[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 数字7</span></span><br><span class="line"><span class="built_in">print</span>(test_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签7</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以 打印 一下图片 看看是什么样子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.imshow(test_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/a745fc12bef94f93b93f80b2e89bb0d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="图片数据处理"><a href="#图片数据处理" class="headerlink" title="图片数据处理"></a>图片数据处理</h1><h2 id="查看图片原有-shape"><a href="#查看图片原有-shape" class="headerlink" title="查看图片原有 shape"></a>查看图片原有 shape</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train_images (60000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images&#x27;</span>, train_images.shape)</span><br><span class="line"><span class="comment"># train_labels (60000,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>, train_labels.shape)</span><br></pre></td></tr></table></figure>
<h2 id="图片数据处理：变成四维-，并归一化"><a href="#图片数据处理：变成四维-，并归一化" class="headerlink" title="图片数据处理：变成四维 ，并归一化"></a>图片数据处理：变成四维 ，并归一化</h2><p>变维度的 -1 是个通配符，系统会自动完成应该变成多少<br>除以255.0 是为了归一化，使得元素点 全部变为在 0-1 之间<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment"># CNN 输入的是一张图片</span></span><br><span class="line"><span class="comment"># 将 (60000, 28, 28) -&gt; (60000, 28, 28, 1)  变成四维</span></span><br><span class="line"><span class="comment"># 第四个 1  表示的为深度   黑白图像为 1   彩色图像为 3</span></span><br><span class="line">train_images_scale = train_images.reshape(-<span class="number">1</span>, train_images.shape[<span class="number">1</span>] ,train_images.shape[<span class="number">2</span>],<span class="number">1</span>)/<span class="number">255.0</span></span><br><span class="line">test_images_scale = test_images.reshape(-<span class="number">1</span>,test_images.shape[<span class="number">1</span>], test_images.shape[<span class="number">2</span>],<span class="number">1</span>)/<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_images变换后 (60000, 28, 28, 1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images变换后&#x27;</span>, train_images_scale.shape)</span><br><span class="line"><span class="comment"># test_images变换后 (10000, 28, 28, 1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_images变换后&#x27;</span>, test_images_scale.shape)</span><br></pre></td></tr></table></figure></p>
<h2 id="标签数据处理：转换成-one-hot-格式"><a href="#标签数据处理：转换成-one-hot-格式" class="headerlink" title="标签数据处理：转换成 one hot 格式"></a>标签数据处理：转换成 one hot 格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换 one hot 格式  共十个分类</span></span><br><span class="line"><span class="comment"># np_utils.to_categorical用于将标签转化为形如(nb_samples, nb_classes)的二值序列。</span></span><br><span class="line">train_labels_hot = np_utils.to_categorical(train_labels,num_classes=<span class="number">10</span>)</span><br><span class="line">test_labels_hot = np_utils.to_categorical(test_labels,num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_labels (60000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>,train_labels_hot.shape)</span><br><span class="line"><span class="comment"># test_labels (10000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_labels&#x27;</span>,test_labels_hot.shape)</span><br></pre></td></tr></table></figure>
<h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p>思路是 卷积 再池化 重复步骤  再压平给 全身神经网络<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"><span class="comment">#第一个卷积层</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    input shape 激入平面</span></span><br><span class="line"><span class="string">    filters 卷积核/过滤器 个数</span></span><br><span class="line"><span class="string">    kernel_size 卷积窗口大小</span></span><br><span class="line"><span class="string">    strides 步长</span></span><br><span class="line"><span class="string">    padding（边界填充）padding方式 same/valid</span></span><br><span class="line"><span class="string">    activation 激活函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 用same 保持整个还是 28 × 28</span></span><br><span class="line">model.add(Convolution2D(</span><br><span class="line">    input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>),filters=<span class="number">32</span>,kernel_size=<span class="number">5</span>,strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment">#第一个池化层</span></span><br><span class="line">model.add(MaxPooling2D(</span><br><span class="line">    pool_size=<span class="number">2</span>,strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"><span class="comment">#第二卷积层</span></span><br><span class="line">model.add(Convolution2D(<span class="number">64</span>,<span class="number">5</span>,strides=<span class="number">1</span>,padding=<span class="string">&#x27;same&#x27;</span>,activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment">#第二个池化层</span></span><br><span class="line">model.add(MaxPooling2D(</span><br><span class="line">    pool_size=<span class="number">2</span>,strides=<span class="number">2</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把第二个池化层的前出扁平化为1维</span></span><br><span class="line">model.add(Flatten())</span><br><span class="line"><span class="comment">#第一个全连接层</span></span><br><span class="line">model.add(Dense(units=<span class="number">1024</span>,activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"><span class="comment">#Dropout</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#第二个全连接层</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,input_dim=<span class="number">1024</span>,activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>优化器使用 Adam， 损失函数 选择 交叉熵   并编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义优化器  10的 -4次方</span></span><br><span class="line">adam = Adam(learning_rate=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= adam,loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,metrics=<span class="string">&quot;accuracy&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p> 一共 60000张训练图片 按批次训练 一批次64张   一共6w/64 个批次<br>训练完一轮6w张，表示一个epoch<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一共 60000张训练图片 按批次训练 一批次64张   </span></span><br><span class="line"><span class="comment"># 训练完一轮6w张，表示一个epoch</span></span><br><span class="line">model.fit(train_images_scale,train_labels_hot,batch_size=<span class="number">64</span>,epochs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/35cafae3dc0e431086f33cdf4a23dc52.png#pic_center" alt="在这里插入图片描述"><br>上图只跑了一次 epoch，因为笔记本太慢了<br><strong>注意： 最好用 GPU 来跑 ，不然笔记本非常的慢</strong></p>
<h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>就是在 测试集上的表现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(test_images_scale,test_labels_hot)</span><br></pre></td></tr></table></figure><br>也可以看一下 在训练集上的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(train_images_scale,train_labels_hot)</span><br></pre></td></tr></table></figure>
<p>下面是 结果（上训练集 下测试集）<br><img src="https://img-blog.csdnimg.cn/d93ee2873e72460e96c0c4a9a663985b.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="预测数据"><a href="#预测数据" class="headerlink" title="预测数据"></a>预测数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看下输入的形状</span></span><br><span class="line"><span class="built_in">print</span>(test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))))</span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输入的图像 变换后形状<br><img src="https://img-blog.csdnimg.cn/c6e4d5008f9c416ba48bea577a86c238.png#pic_center" alt="在这里插入图片描述"><br>模型预测 数据 输出的概率分类结果<br><img src="https://img-blog.csdnimg.cn/ba872c35347041b592db07d82b429d35.png#pic_center" alt="在这里插入图片描述"><br>选出其中最大的 以及 实际图片标签 均为 数字7<br><img src="https://img-blog.csdnimg.cn/5a585701d439431aa1853283c8592b46.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras  MNIST（数字识别）数据集分类（普通全神经网络）</title>
    <url>/2021/08/30/Keras%20%20MNIST%EF%BC%88%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%EF%BC%89%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E7%B1%BB%EF%BC%88%E6%99%AE%E9%80%9A%E5%85%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="Keras  MNIST（数字识别）数据集分类">TOC</a></p>
<h1 id="导入需要的包"><a href="#导入需要的包" class="headerlink" title="导入需要的包"></a>导入需要的包</h1><p>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span>  Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_backend())</span><br></pre></td></tr></table></figure>
<h1 id="载入MNIST-数据"><a href="#载入MNIST-数据" class="headerlink" title="载入MNIST 数据"></a>载入MNIST 数据</h1><p>该数据集一共有训练集 6w 张，测试集 1w 张<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_images,train_labels),(test_images,test_labels)= mnist.load_data()</span><br></pre></td></tr></table></figure></p>
<p>可以查看一下图像和标签  是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字5</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签5</span></span><br><span class="line"><span class="built_in">print</span>(train_labels[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 数字7</span></span><br><span class="line"><span class="built_in">print</span>(test_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签7</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以 打印 一下图片 看看是什么样子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.imshow(test_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/a745fc12bef94f93b93f80b2e89bb0d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="图片数据处理"><a href="#图片数据处理" class="headerlink" title="图片数据处理"></a>图片数据处理</h1><h2 id="查看图片原有-shape"><a href="#查看图片原有-shape" class="headerlink" title="查看图片原有 shape"></a>查看图片原有 shape</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train_images (60000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images&#x27;</span>, train_images.shape)</span><br><span class="line"><span class="comment"># train_labels (60000,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>, train_labels.shape)</span><br></pre></td></tr></table></figure>
<h2 id="图片数据处理：将图片压平"><a href="#图片数据处理：将图片压平" class="headerlink" title="图片数据处理：将图片压平"></a>图片数据处理：将图片压平</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment"># 将 (60000, 28, 28) -&gt; (60000, 784)  压平图片</span></span><br><span class="line">train_images_scale = train_images.reshape(train_images.shape[<span class="number">0</span>], train_images.shape[<span class="number">1</span>] * train_images.shape[<span class="number">2</span>])/<span class="number">255.0</span></span><br><span class="line">test_images_scale = test_images.reshape(test_images.shape[<span class="number">0</span>], test_images.shape[<span class="number">1</span>] * test_images.shape[<span class="number">2</span>])/<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_images变换后 (60000, 784)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images变换后&#x27;</span>, train_images_scale.shape)</span><br><span class="line"><span class="comment"># test_images变换后 (10000, 784)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_images变换后&#x27;</span>, test_images_scale.shape)</span><br></pre></td></tr></table></figure>
<h2 id="标签数据处理：转换成-one-hot-格式"><a href="#标签数据处理：转换成-one-hot-格式" class="headerlink" title="标签数据处理：转换成 one hot 格式"></a>标签数据处理：转换成 one hot 格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换 one hot 格式  共十个分类</span></span><br><span class="line"><span class="comment"># np_utils.to_categorical用于将标签转化为形如(nb_samples, nb_classes)的二值序列。</span></span><br><span class="line">train_labels_hot = np_utils.to_categorical(train_labels,num_classes=<span class="number">10</span>)</span><br><span class="line">test_labels_hot = np_utils.to_categorical(test_labels,num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_labels (60000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>,train_labels_hot.shape)</span><br><span class="line"><span class="comment"># test_labels (10000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_labels&#x27;</span>,test_labels_hot.shape)</span><br></pre></td></tr></table></figure>
<h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p>只有输入和输出层， 输入压平图像 维度为784   输出为 10分类<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 输入压平图像 维度为784   输出为 10分类</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,input_dim=<span class="number">784</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure><br>优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新定义 sgd 优化器  加速一下学习率</span></span><br><span class="line">sgd = SGD(learning_rate=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= sgd,loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,metrics=<span class="string">&quot;accuracy&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p> 一共 60000张训练图片 按批次训练 一批次32张   一共6w/32 = 1875 个批次<br>训练完一轮6w张，表示一个epoch<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一共 60000张训练图片 按批次训练 一批次32张   一共6w/32 = 1875 个批次</span></span><br><span class="line"><span class="comment"># 训练完一轮6w张，表示一个epoch</span></span><br><span class="line">model.fit(train_images_scale,train_labels_hot,batch_size=<span class="number">32</span>,epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/576f033299d04330a371c33eb6a2abac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="训练过程"></p>
<h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>就是在 测试集上的表现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(test_images_scale,test_labels_hot)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/eb52f38d3e944137a3ade6e5b9d1e1a9.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="预测数据"><a href="#预测数据" class="headerlink" title="预测数据"></a>预测数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看下输入的形状</span></span><br><span class="line"><span class="built_in">print</span>(test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>).shape)</span><br><span class="line"><span class="comment"># 模型预测  输出每个分类的 概率</span></span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>))))</span><br><span class="line"><span class="comment"># 选取最大的那个 就是预测的标签</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>)))))</span><br><span class="line"><span class="comment"># 实际该图片的 标签</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输入的图像 变换后形状<br><img src="https://img-blog.csdnimg.cn/4302df2ba0e44c04897aaf00f6955dad.png#pic_center" alt="在这里插入图片描述"><br>模型预测 数据 输出的概率分类结果<br><img src="https://img-blog.csdnimg.cn/3ffa135e578d486c8404588781678e0c.png#pic_center" alt="在这里插入图片描述"><br>选出其中最大的 以及 实际图片标签 均为 数字7<br><img src="https://img-blog.csdnimg.cn/5a585701d439431aa1853283c8592b46.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras  RNN 实现 MNIST 手写数字识别</title>
    <url>/2021/09/04/Keras%20%20RNN%20%E5%AE%9E%E7%8E%B0%20MNIST%20%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>@<a href="Keras  RNN 实现 MNIST 手写数字识别">TOC</a></p>
<p>我们就以 MNIST数据集的手写识别 为例子</p>
<h1 id="导入需要的包"><a href="#导入需要的包" class="headerlink" title="导入需要的包"></a>导入需要的包</h1><p>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span>  Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers.recurrent <span class="keyword">import</span> SimpleRNN</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_backend())</span><br></pre></td></tr></table></figure>
<h1 id="载入MNIST-数据"><a href="#载入MNIST-数据" class="headerlink" title="载入MNIST 数据"></a>载入MNIST 数据</h1><p>该数据集一共有训练集 6w 张，测试集 1w 张<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_images,train_labels),(test_images,test_labels)= mnist.load_data()</span><br></pre></td></tr></table></figure></p>
<p>可以查看一下图像和标签  是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字5</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签5</span></span><br><span class="line"><span class="built_in">print</span>(train_labels[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 数字7</span></span><br><span class="line"><span class="built_in">print</span>(test_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签7</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以 打印 一下图片 看看是什么样子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.imshow(test_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/a745fc12bef94f93b93f80b2e89bb0d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="图片数据处理"><a href="#图片数据处理" class="headerlink" title="图片数据处理"></a>图片数据处理</h1><h2 id="查看图片原有-shape"><a href="#查看图片原有-shape" class="headerlink" title="查看图片原有 shape"></a>查看图片原有 shape</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train_images (60000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images&#x27;</span>, train_images.shape)</span><br><span class="line"><span class="comment"># train_labels (60000,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>, train_labels.shape)</span><br></pre></td></tr></table></figure>
<h2 id="图片数据处理：归一化"><a href="#图片数据处理：归一化" class="headerlink" title="图片数据处理：归一化"></a>图片数据处理：归一化</h2><p>除以255.0 是为了归一化，使得元素点 全部变为在 0-1 之间<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment">#  (60000, 28, 28) </span></span><br><span class="line">train_images_scale = train_images/<span class="number">255.0</span></span><br><span class="line">test_images_scale = test_images/<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_images变换后 (60000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images变换后&#x27;</span>, train_images_scale.shape)</span><br><span class="line"><span class="comment"># test_images变换后 (10000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_images变换后&#x27;</span>, test_images_scale.shape)</span><br></pre></td></tr></table></figure></p>
<h2 id="标签数据处理：转换成-one-hot-格式"><a href="#标签数据处理：转换成-one-hot-格式" class="headerlink" title="标签数据处理：转换成 one hot 格式"></a>标签数据处理：转换成 one hot 格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换 one hot 格式  共十个分类</span></span><br><span class="line"><span class="comment"># np_utils.to_categorical用于将标签转化为形如(nb_samples, nb_classes)的二值序列。</span></span><br><span class="line">train_labels_hot = np_utils.to_categorical(train_labels,num_classes=<span class="number">10</span>)</span><br><span class="line">test_labels_hot = np_utils.to_categorical(test_labels,num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_labels (60000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>,train_labels_hot.shape)</span><br><span class="line"><span class="comment"># test_labels (10000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_labels&#x27;</span>,test_labels_hot.shape)</span><br></pre></td></tr></table></figure>
<h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p>先定义 RNN 所需的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义rnn 的参数</span></span><br><span class="line"><span class="comment"># 数据长度 一行一共有28个元素</span></span><br><span class="line">input_size = <span class="number">28</span></span><br><span class="line"><span class="comment"># 序列长度 一共有28个序列 也就是28行</span></span><br><span class="line">time_steps = <span class="number">28</span></span><br><span class="line"><span class="comment"># 隐藏层cell个数</span></span><br><span class="line">cell_size = <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再定义 RNN 模型<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line"><span class="comment">#循环神经网络</span></span><br><span class="line">model.add(SimpleRNN(</span><br><span class="line">    units=cell_size, <span class="comment">#输出</span></span><br><span class="line">    input_shape=(time_steps,input_size) <span class="comment">#输入</span></span><br><span class="line">))</span><br><span class="line"><span class="comment"># 输出层</span></span><br><span class="line">model.add(Dense(input_dim=cell_size,units=<span class="number">10</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure><br>优化器使用 Adam， 损失函数 选择 交叉熵   并编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义优化器  10的 -4次方</span></span><br><span class="line">adam = Adam(learning_rate=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= adam,loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,metrics=<span class="string">&quot;accuracy&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p> 一共 60000张训练图片 按批次训练 一批次64张   一共6w/64 个批次<br>训练完一轮6w张，表示一个epoch<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一共 60000张训练图片 按批次训练 一批次64张   </span></span><br><span class="line"><span class="comment"># 训练完一轮6w张，表示一个epoch</span></span><br><span class="line">model.fit(train_images_scale,train_labels_hot,batch_size=<span class="number">64</span>,epochs=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/35cafae3dc0e431086f33cdf4a23dc52.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>就是在 测试集上的表现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(test_images_scale,test_labels_hot)</span><br></pre></td></tr></table></figure><br>也可以看一下 在训练集上的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(train_images_scale,train_labels_hot)</span><br></pre></td></tr></table></figure>
<p>下面是 结果（上训练集 下测试集）<br><img src="https://img-blog.csdnimg.cn/d93ee2873e72460e96c0c4a9a663985b.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="预测数据"><a href="#预测数据" class="headerlink" title="预测数据"></a>预测数据</h1><font color="red">**有问题 输入的 数据维度不对 不知道错哪了？？？**</font>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看下输入的形状</span></span><br><span class="line"><span class="comment"># # 预测数据</span></span><br><span class="line"><span class="built_in">print</span>(test_images_scale[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images_scale[<span class="number">0</span>]/<span class="number">255.0</span>)))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images_scale[<span class="number">0</span>]/<span class="number">255.0</span>))))</span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输入的图像 变换后形状<br><img src="https://img-blog.csdnimg.cn/c6e4d5008f9c416ba48bea577a86c238.png#pic_center" alt="在这里插入图片描述"><br>模型预测 数据 输出的概率分类结果<br><img src="https://img-blog.csdnimg.cn/ba872c35347041b592db07d82b429d35.png#pic_center" alt="在这里插入图片描述"><br>选出其中最大的 以及 实际图片标签 均为 数字7<br><img src="https://img-blog.csdnimg.cn/5a585701d439431aa1853283c8592b46.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras 构建 线性模型和非线性模型</title>
    <url>/2021/08/24/Keras%20%E6%9E%84%E5%BB%BA%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>@<a href="Keras 构建 线性模型和非线性模型">TOC</a></p>
<h1 id="预测线性模型"><a href="#预测线性模型" class="headerlink" title="预测线性模型"></a>预测线性模型</h1><p>使用的数据 是我们随机生成的<br>、<br>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># matplotlib.use(&#x27;TkAgg&#x27;)</span></span><br><span class="line"><span class="comment"># print(matplotlib.get_backend())</span></span><br><span class="line"><span class="comment"># Sequential按顺序构成的模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="comment"># Dense全连接层</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br></pre></td></tr></table></figure>
<p>先准备我们需要的数据。随机生成100个随机值x，并随机产生100个噪声值。我们按 $y=0.1x+0.2$ 的公式，得到对应的y标签值。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用numpy 生成100个 随机点</span></span><br><span class="line">x_data = np.random.rand(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 测试集，但其实都是随机的 用x_data 也可以</span></span><br><span class="line">x_pre = np.random.rand(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 噪声 使得每个点不是 均匀在一条直线上</span></span><br><span class="line">noise = np.random.normal(<span class="number">0</span>,<span class="number">0.01</span>,x_data.shape)</span><br><span class="line">y_data = x_data * <span class="number">0.1</span> + <span class="number">0.2</span> + noise</span><br></pre></td></tr></table></figure>
<p>可以将 100个点的分布图画出。 注意图的显示可能有问题，自行解决一下哦。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x_data,y_data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Q：为什么我们要引入 噪声呢？<br>答：引入噪声可以让我们的数据更加的离散分布 在 我们设计的线性模型上。 使得假设的数据更加的合理。 如下图所示 。 <font color="orange">橙色</font>的是我们设定的线性模型，<font color="blue">蓝色</font>的是 加入噪声以后的数据分布<br><img src="https://img-blog.csdnimg.cn/92fd1e153f2845aba178b80a7845b8cb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p>使用 keras 中的 Sequential （顺序构成的模型） 构建模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个顺序模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 在模型中添加一个全连接层</span></span><br><span class="line"><span class="comment"># units 输出的维度</span></span><br><span class="line"><span class="comment"># input_dim 输入的维度</span></span><br><span class="line">model.add(Dense(units=<span class="number">1</span>,input_dim=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># sgd 随机梯度下降法</span></span><br><span class="line"><span class="comment"># mse Mean Squared Error 均方误差</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;sgd&#x27;</span>,loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>之后我们就按照批次训练。 共训练3001个批次。有两种写法。<br>方法一：<br>用一个循环体，循环3001次； 每500次 打印一次 损失值。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练3001个批次</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3001</span>):</span><br><span class="line">    <span class="comment">#每次训练一个批次</span></span><br><span class="line">    cost = model.train_on_batch(x_data,y_data)</span><br><span class="line">    <span class="comment"># 每500个 batch 打印一次 cost值</span></span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cost:&quot;</span>,cost)</span><br></pre></td></tr></table></figure><br>方法二： 直接使用 model.fit () 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(x_data,y_data,epochs=<span class="number">3001</span>)</span><br></pre></td></tr></table></figure>
<p> 可以查看 参数值 W （权重）和 b（偏置值）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W,b = model.layers[<span class="number">0</span>].get_weights()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;W：&#x27;</span>,W,<span class="string">&#x27;b:&#x27;</span>,b)</span><br></pre></td></tr></table></figure>
<p>预测 测试集的 结果 使用 model.predict () 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试集 输入网络中，得到预测值 y_pred</span></span><br><span class="line">y_pred = model.predict(x_pre)</span><br></pre></td></tr></table></figure>
<p>可以再 把预测的 图打出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x_pre,y_pred)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>我们的训练 使用方法二 <strong>结果如图所示：</strong><br><img src="https://img-blog.csdnimg.cn/45c3db30524a45a48e919881f6c36710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="预测非线性模型"><a href="#预测非线性模型" class="headerlink" title="预测非线性模型"></a>预测非线性模型</h1><p>使用的数据 也是我们随机生成的</p>
<p>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便） 注意SGD 需要 tensorflow.keras.optimizers 导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="comment"># Sequential按顺序构成的模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="comment"># Dense全连接层</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Activation</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> SGD</span><br></pre></td></tr></table></figure>
<p>先准备我们需要的数据。用等差数列生成200个值x，并随机产生200个噪声值。我们按 $y=x^{2}$ 的公式，得到对应的y标签值。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用numpy 生成 200 个随机点</span></span><br><span class="line">x_data = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line">x_pre = np.linspace(-<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">200</span>)</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>,<span class="number">0.02</span>,x_data.shape)</span><br><span class="line">y_data = np.square(x_data) + noise</span><br></pre></td></tr></table></figure>
<p>可以将 200个点的分布图画出。 注意图的显示可能有问题，自行解决一下哦。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x_data,y_data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>使用 keras 中的 Sequential （顺序构成的模型） 构建模型。 <font color="red">与线性模型的区别在，我们需要 增加激活函数，并且增加一个 中间层（含有10个神经元）。</font>  <font color="blue">并且增加一点 sgd 的学习率，不然学习度太慢，需要的训练次数就会非常大。</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个顺序模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 在模型中添加一个全连接层</span></span><br><span class="line"><span class="comment"># units 输出的维度  维度就是神经元个数</span></span><br><span class="line"><span class="comment"># input_dim 输入的维度</span></span><br><span class="line"><span class="comment"># 需要的神经模型为 1-10-1</span></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,input_dim=<span class="number">1</span>,activation=<span class="string">&#x27;tanh&#x27;</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">1</span>,input_dim=<span class="number">10</span>,activation=<span class="string">&#x27;tanh&#x27;</span>))</span><br><span class="line"><span class="comment"># sgd 随机梯度下降法</span></span><br><span class="line"><span class="comment"># mse Mean Squared Error 均方误差</span></span><br><span class="line"><span class="comment"># sgd 的学习率太小 训练次数可能非常多</span></span><br><span class="line"><span class="comment"># 需要修改一下 sgd的学习率</span></span><br><span class="line">sgd = SGD(lr=<span class="number">0.3</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= sgd,loss=<span class="string">&#x27;mse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>之后我们就按照批次训练。 共训练3001个批次。有两种写法。<br>方法一：<br>用一个循环体，循环3001次； 每500次 打印一次 损失值。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练3001个批次</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3001</span>):</span><br><span class="line">    <span class="comment">#每次训练一个批次</span></span><br><span class="line">    cost = model.train_on_batch(x_data,y_data)</span><br><span class="line">    <span class="comment"># 每500个 batch 打印一次 cost值</span></span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cost:&quot;</span>,cost)</span><br></pre></td></tr></table></figure><br>方法二： 直接使用 model.fit () 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(x_data,y_data,epochs=<span class="number">3001</span>)</span><br></pre></td></tr></table></figure>
<p> 可以查看 参数值 W （权重）和 b（偏置值）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W,b = model.layers[<span class="number">0</span>].get_weights()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;W：&#x27;</span>,W,<span class="string">&#x27;b:&#x27;</span>,b)</span><br></pre></td></tr></table></figure>
<p>预测 测试集的 结果 使用 model.predict () 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试集 输入网络中，得到预测值 y_pred</span></span><br><span class="line">y_pred = model.predict(x_pre)</span><br></pre></td></tr></table></figure>
<p>可以再 把预测的 图打出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x_pre,y_pred)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>我们的训练 使用方法二 <strong>结果如图所示：</strong><br><img src="https://img-blog.csdnimg.cn/79b89f1dec6e4327a2679c2c9882d6c7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
        <tag>线性模型</tag>
        <tag>非线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras MNIST 过拟合问题解决：Dropout 与 正则化</title>
    <url>/2021/09/02/Keras%20MNIST%20%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9ADropout%20%E4%B8%8E%20%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    <content><![CDATA[<p>@<a href="Keras MNIST 过拟合问题解决：Dropout 与 正则化">TOC</a></p>
<p>我们就以 MNIST数据集的手写识别 为例子<br>做 过拟合问题的应用  包括 Dropout 和 正则化</p>
<h1 id="导入需要的包"><a href="#导入需要的包" class="headerlink" title="导入需要的包"></a>导入需要的包</h1><p>首先导入我们需要的包（直接把Sequential 和 Dense 直接导入 这样之后方便）</p>
<h2 id="使用Dropout-需要导入的包"><a href="#使用Dropout-需要导入的包" class="headerlink" title="使用Dropout 需要导入的包"></a>使用Dropout 需要导入的包</h2><p>需要 导入 另一个包 keras.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span>  Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_backend())</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-正则化-需要导入的包"><a href="#使用-正则化-需要导入的包" class="headerlink" title="使用 正则化  需要导入的包"></a>使用 正则化  需要导入的包</h2><p>layers 层中 引入 keras.regularizers   中  l2 范式<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span>  Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.regularizers <span class="keyword">import</span> l2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(matplotlib.get_backend())</span><br></pre></td></tr></table></figure></p>
<h1 id="载入MNIST-数据"><a href="#载入MNIST-数据" class="headerlink" title="载入MNIST 数据"></a>载入MNIST 数据</h1><p>该数据集一共有训练集 6w 张，测试集 1w 张<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(train_images,train_labels),(test_images,test_labels)= mnist.load_data()</span><br></pre></td></tr></table></figure></p>
<p>可以查看一下图像和标签  是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字5</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签5</span></span><br><span class="line"><span class="built_in">print</span>(train_labels[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 数字7</span></span><br><span class="line"><span class="built_in">print</span>(test_images[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 标签7</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以 打印 一下图片 看看是什么样子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line">plt.imshow(test_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/a745fc12bef94f93b93f80b2e89bb0d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="图片数据处理"><a href="#图片数据处理" class="headerlink" title="图片数据处理"></a>图片数据处理</h1><h2 id="查看图片原有-shape"><a href="#查看图片原有-shape" class="headerlink" title="查看图片原有 shape"></a>查看图片原有 shape</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train_images (60000, 28, 28)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images&#x27;</span>, train_images.shape)</span><br><span class="line"><span class="comment"># train_labels (60000,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>, train_labels.shape)</span><br></pre></td></tr></table></figure>
<h2 id="图片数据处理：将图片压平"><a href="#图片数据处理：将图片压平" class="headerlink" title="图片数据处理：将图片压平"></a>图片数据处理：将图片压平</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line"><span class="comment"># 将 (60000, 28, 28) -&gt; (60000, 784)  压平图片</span></span><br><span class="line">train_images_scale = train_images.reshape(train_images.shape[<span class="number">0</span>], train_images.shape[<span class="number">1</span>] * train_images.shape[<span class="number">2</span>])/<span class="number">255.0</span></span><br><span class="line">test_images_scale = test_images.reshape(test_images.shape[<span class="number">0</span>], test_images.shape[<span class="number">1</span>] * test_images.shape[<span class="number">2</span>])/<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_images变换后 (60000, 784)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_images变换后&#x27;</span>, train_images_scale.shape)</span><br><span class="line"><span class="comment"># test_images变换后 (10000, 784)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_images变换后&#x27;</span>, test_images_scale.shape)</span><br></pre></td></tr></table></figure>
<h2 id="标签数据处理：转换成-one-hot-格式"><a href="#标签数据处理：转换成-one-hot-格式" class="headerlink" title="标签数据处理：转换成 one hot 格式"></a>标签数据处理：转换成 one hot 格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 换 one hot 格式  共十个分类</span></span><br><span class="line"><span class="comment"># np_utils.to_categorical用于将标签转化为形如(nb_samples, nb_classes)的二值序列。</span></span><br><span class="line">train_labels_hot = np_utils.to_categorical(train_labels,num_classes=<span class="number">10</span>)</span><br><span class="line">test_labels_hot = np_utils.to_categorical(test_labels,num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_labels (60000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_labels&#x27;</span>,train_labels_hot.shape)</span><br><span class="line"><span class="comment"># test_labels (10000, 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test_labels&#x27;</span>,test_labels_hot.shape)</span><br></pre></td></tr></table></figure>
<h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><h2 id="添加-Dropout"><a href="#添加-Dropout" class="headerlink" title="添加 Dropout"></a>添加 Dropout</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 输入压平图像 维度为784   输出为 10分类</span></span><br><span class="line"><span class="comment"># 加个隐层</span></span><br><span class="line">model.add(Dense(units=<span class="number">200</span>,input_dim=<span class="number">784</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;tanh&quot;</span>))</span><br><span class="line"><span class="comment"># 上层40%的神经元不工作</span></span><br><span class="line">model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">100</span>,input_dim=<span class="number">200</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;tanh&quot;</span>))</span><br><span class="line"><span class="comment"># 上层40%的神经元不工作</span></span><br><span class="line">model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,input_dim=<span class="number">100</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;softmax&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新定义 sgd 优化器  加速一下学习率</span></span><br><span class="line">sgd = SGD(learning_rate=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= sgd,loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,metrics=<span class="string">&quot;accuracy&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="添加-正则化项"><a href="#添加-正则化项" class="headerlink" title="添加 正则化项"></a>添加 正则化项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 输入压平图像 维度为784   输出为 10分类</span></span><br><span class="line"><span class="comment"># 加个隐层</span></span><br><span class="line">model.add(Dense(units=<span class="number">200</span>,input_dim=<span class="number">784</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;tanh&quot;</span>,kernel_initializer=l2(<span class="number">0.003</span>)))</span><br><span class="line">model.add(Dense(units=<span class="number">100</span>,input_dim=<span class="number">200</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;tanh&quot;</span>,kernel_initializer=l2(<span class="number">0.003</span>)))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,input_dim=<span class="number">100</span>,bias_initializer=<span class="string">&quot;one&quot;</span>,activation=<span class="string">&quot;softmax&quot;</span>,kernel_initializer=l2(<span class="number">0.003</span>)))</span><br></pre></td></tr></table></figure>
<p>优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新定义 sgd 优化器  加速一下学习率</span></span><br><span class="line">sgd = SGD(learning_rate=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 优化器使用加速学习率的 sgd ， 损失函数 选择 交叉熵</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer= sgd,loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,metrics=<span class="string">&quot;accuracy&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p> 一共 60000张训练图片 按批次训练 一批次32张   一共6w/32 = 1875 个批次<br>训练完一轮6w张，表示一个epoch<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一共 60000张训练图片 按批次训练 一批次32张   一共6w/32 = 1875 个批次</span></span><br><span class="line"><span class="comment"># 训练完一轮6w张，表示一个epoch</span></span><br><span class="line">model.fit(train_images_scale,train_labels_hot,batch_size=<span class="number">32</span>,epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/576f033299d04330a371c33eb6a2abac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="训练过程"></p>
<h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><h2 id="Dropout的结果"><a href="#Dropout的结果" class="headerlink" title="Dropout的结果"></a>Dropout的结果</h2><p>就是在 测试集上的表现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(test_images_scale,test_labels_hot)</span><br></pre></td></tr></table></figure><br>也可以看一下 在训练集上的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(train_images_scale,train_labels_hot)</span><br></pre></td></tr></table></figure>
<p>下面是 结果（上训练集 下测试集）<br><img src="https://img-blog.csdnimg.cn/7c46786df7d74ef383b14a1627e0cf9d.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="正则化的结果"><a href="#正则化的结果" class="headerlink" title="正则化的结果"></a>正则化的结果</h2><p>就是在 测试集上的表现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(test_images_scale,test_labels_hot)</span><br></pre></td></tr></table></figure><br>也可以看一下 在训练集上的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss,accuracy = model.evaluate(train_images_scale,train_labels_hot)</span><br></pre></td></tr></table></figure>
<p>下面是 结果（上训练集 下测试集）</p>
<p><font color="red"><strong>出现了错误 不知道是哪里的问题哎？</strong></font><br><img src="https://img-blog.csdnimg.cn/44c6138733e4436ba6d847fec0f88cfd.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TypeError: __call__() got an unexpected keyword argument <span class="string">&#x27;dtype&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e71199da4cfb4c2aaf69d39fc4dacfd3.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="预测数据"><a href="#预测数据" class="headerlink" title="预测数据"></a>预测数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 看下输入的形状</span></span><br><span class="line"><span class="built_in">print</span>(test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>).shape)</span><br><span class="line"><span class="comment"># 模型预测  输出每个分类的 概率</span></span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>))))</span><br><span class="line"><span class="comment"># 选取最大的那个 就是预测的标签</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images_scale[<span class="number">0</span>].reshape(-<span class="number">1</span>,<span class="number">784</span>)))))</span><br><span class="line"><span class="comment"># 实际该图片的 标签</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输入的图像 变换后形状<br><img src="https://img-blog.csdnimg.cn/4302df2ba0e44c04897aaf00f6955dad.png#pic_center" alt="在这里插入图片描述"><br>模型预测 数据 输出的概率分类结果<br><img src="https://img-blog.csdnimg.cn/3ffa135e578d486c8404588781678e0c.png#pic_center" alt="在这里插入图片描述"><br>选出其中最大的 以及 实际图片标签 均为 数字7<br><img src="https://img-blog.csdnimg.cn/5a585701d439431aa1853283c8592b46.png#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>Keras 实现 Kaggle 数据集 Titanic 预测</title>
    <url>/2021/09/17/Keras%20%E5%AE%9E%E7%8E%B0%20Kaggle%20%E6%95%B0%E6%8D%AE%E9%9B%86%20Titanic%20%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>@<a href="Keras 实现 Kaggle 数据集 Titanic 预测">TOC</a></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote>
<p>使用乘客数据(如姓名、年龄、性别、社会经济阶层等)，建立一个模型预测泰坦尼克号沉船上哪些乘客能够幸存。<br>数据被分成训练集和测试集两组，它们分别在train.csv和test.csv文档中。我们的模型将基于训练集的乘客的性别和阶级等特征建立。在测试集中每个乘客是否幸存的信息是缺省的，其将由我们模型预测出来作为答案提交。</p>
</blockquote>
<h1 id="加载本地下载的-Titanic-数据集"><a href="#加载本地下载的-Titanic-数据集" class="headerlink" title="加载本地下载的 Titanic 数据集"></a>加载本地下载的 Titanic 数据集</h1><p>这里使用的 是 pandas 的 read_csv() 方法。 读取的格式为 DataFrame。<br><img src="https://img-blog.csdnimg.cn/0c79c9053cc34cd39d609475f2ac37f3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xlsx训练数据导入</span></span><br><span class="line">train_filepath = <span class="string">r&quot;../dataset/Titanic/train.csv&quot;</span></span><br><span class="line">train_data = pd.read_csv(train_filepath)</span><br><span class="line">test_filepath = <span class="string">r&quot;../dataset/Titanic/test.csv&quot;</span></span><br><span class="line">test_data = pd.read_csv(test_filepath)</span><br></pre></td></tr></table></figure><br>同样可以用 shape函数查看 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#(891,12)</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br></pre></td></tr></table></figure>
<h1 id="数据分析与预处理"><a href="#数据分析与预处理" class="headerlink" title="数据分析与预处理"></a>数据分析与预处理</h1><p>在预处理数据前，首先整体分析各项数据对预测模型的重要性</p>
<p>（1）PassengerID：乘客的ID<br>（2）Survived：乘客是否幸存，取值为0或1，是我们预测/分类的目标。<br>（3）Pclass：客舱等级，可能蕴含着乘客的阶层、乘客客舱的位置等信息，比较重要。<br>（4）Name： 姓名，是无关信息。<br>（5）Sex：性别。灾难来临时常让妇女儿童先走，而同等条件女性体力普遍弱于男性，这些因素都会影响到一名乘客幸存的可能性，因此比较重要。<br>（6）Age：年龄，较为重要，理由同上。<br>（7）Parch：直系亲友数目，比较重要。<br>（8）SibSp：旁系亲友数目，比较重要。<br>（9）Ticket：票编号，是无关信息。<br>（10）Fare：票价，可能会反映乘客的社会阶层等。<br>（11）Cabin：客舱编号，可能会反映客舱位置等，但由于缺省太多，数据量很小不具有代表性，可以视为噪音剔除。<br>（12）Embarked：上船的港口编号。</p>
<p>在剔除了一些数据后，是否会因信息损失而降低模型的准确度？例如乘客的姓名可能暗含船上乘客之间家庭的关系。实际上我们的模型本来就是建立在不完全观测上（比如我们不知道船上的一对男女乘客有没有发生像Jack和Rose那样的故事），不确定性是必然存在的。把握主要矛盾，舍弃噪音信息是建立模型的一个好思路。</p>
<h2 id="训练数据预处理方法"><a href="#训练数据预处理方法" class="headerlink" title="训练数据预处理方法"></a>训练数据预处理方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line"><span class="comment"># 训练数据预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PreprocessTrainData</span>(<span class="params">train_data</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理1：筛除无关特征</span></span><br><span class="line">    <span class="comment"># 无关的有 乘客的ID 姓名 票编号客舱编号（数据量太少，当噪声剔除）</span></span><br><span class="line">    <span class="comment"># 是否幸存 客舱等级 性别 年龄 旁系亲友数目  直系亲友数目 票价  上船港口编号</span></span><br><span class="line">    cols=[<span class="string">&#x27;Survived&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Embarked&#x27;</span>]</span><br><span class="line">    <span class="comment"># colums表示列名  index 表示行名</span></span><br><span class="line">    train_data = pd.DataFrame(train_data, columns=cols)</span><br><span class="line">    <span class="comment">#(891,8)</span></span><br><span class="line">    <span class="built_in">print</span>(train_data.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理2：填充缺失特征并标准化特征</span></span><br><span class="line">    age_mean = train_data[<span class="string">&#x27;Age&#x27;</span>].mean()</span><br><span class="line">    <span class="comment"># fillna 为 无值的数据填充</span></span><br><span class="line">    train_data[<span class="string">&#x27;Age&#x27;</span>] = train_data[<span class="string">&#x27;Age&#x27;</span>].fillna(age_mean)</span><br><span class="line"></span><br><span class="line">    fare_mean = train_data[<span class="string">&#x27;Fare&#x27;</span>].mean()</span><br><span class="line">    train_data[<span class="string">&#x27;Fare&#x27;</span>] = train_data[<span class="string">&#x27;Fare&#x27;</span>].fillna(fare_mean)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理3：性别编码0-1  将&#123;&#x27;female&#x27;: 0, &#x27;male&#x27;: 1&#125;</span></span><br><span class="line">    train_data[<span class="string">&#x27;Sex&#x27;</span>]= train_data[<span class="string">&#x27;Sex&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;female&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;male&#x27;</span>: <span class="number">1</span>&#125;).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理4：登港地点转换为one-hot编码</span></span><br><span class="line">    <span class="comment"># 这是将 Embarked这一列 分成 one-hot形式 共有三个港口 所以分成了3列</span></span><br><span class="line">    x_OneHot_df = pd.get_dummies(data=train_data,columns=[<span class="string">&quot;Embarked&quot;</span>])</span><br><span class="line">    ndarray = x_OneHot_df.values</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ndarray&#x27;</span>,ndarray)</span><br><span class="line">    <span class="comment">#(891,10)</span></span><br><span class="line">    <span class="built_in">print</span>(ndarray.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理5：全体特征标准化，标签向量化</span></span><br><span class="line">    <span class="comment"># &#x27;Survived&#x27;</span></span><br><span class="line">    label = ndarray[:,:<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># label的shape： (891,1)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;label的shape：&quot;</span>,label.shape)</span><br><span class="line">    <span class="comment"># 除了&#x27;Survived&#x27; 其他全部特征</span></span><br><span class="line">    features = ndarray[:,<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># features的shape： (891, 9)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;features的shape：&quot;</span>, features.shape)</span><br><span class="line">    <span class="comment"># 求一个所有列的平均值</span></span><br><span class="line">    mean = features.mean(axis=<span class="number">0</span>)</span><br><span class="line">    features -= mean</span><br><span class="line">    <span class="comment"># 求一个所有列的方差</span></span><br><span class="line">    std = features.std(axis=<span class="number">0</span>)</span><br><span class="line">    features /= std</span><br><span class="line">    <span class="keyword">return</span> features,label</span><br></pre></td></tr></table></figure>
<h2 id="测试数据预处理方法"><a href="#测试数据预处理方法" class="headerlink" title="测试数据预处理方法"></a>测试数据预处理方法</h2><p>本质上与训练数据相同，只是少了一列 标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试数据预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PreprocessTestData</span>(<span class="params">test_data</span>):</span></span><br><span class="line">    <span class="comment"># 预处理1：筛除无关特征</span></span><br><span class="line">    <span class="comment"># 客舱等级 性别 年龄 旁系亲友数目 直系亲友数目 票价  上船港口编号</span></span><br><span class="line">    cols=[ <span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Embarked&#x27;</span>]</span><br><span class="line">    test_data = test_data[cols]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理2：填充缺失特征并标准化特征</span></span><br><span class="line">    age_mean = test_data[<span class="string">&#x27;Age&#x27;</span>].mean()</span><br><span class="line">    test_data[<span class="string">&#x27;Age&#x27;</span>] = test_data[<span class="string">&#x27;Age&#x27;</span>].fillna(age_mean)</span><br><span class="line"></span><br><span class="line">    fare_mean = test_data[<span class="string">&#x27;Fare&#x27;</span>].mean()</span><br><span class="line">    test_data[<span class="string">&#x27;Fare&#x27;</span>] = test_data[<span class="string">&#x27;Fare&#x27;</span>].fillna(fare_mean)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理3：性别编码0-1</span></span><br><span class="line">    test_data[<span class="string">&#x27;Sex&#x27;</span>]= test_data[<span class="string">&#x27;Sex&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;female&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;male&#x27;</span>: <span class="number">1</span>&#125;).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理4：登港地点转换为one-hot编码</span></span><br><span class="line">    x_OneHot_df = pd.get_dummies(data=test_data,columns=[<span class="string">&quot;Embarked&quot;</span>])</span><br><span class="line">    ndarray = x_OneHot_df.values</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理5：全体特征标准化，标签向量化</span></span><br><span class="line">    features = ndarray</span><br><span class="line">    mean = features.mean(axis=<span class="number">0</span>)</span><br><span class="line">    features -= mean</span><br><span class="line">    std = features.std(axis=<span class="number">0</span>)</span><br><span class="line">    features /= std</span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>
<h2 id="拿到处理后的数据"><a href="#拿到处理后的数据" class="headerlink" title="拿到处理后的数据"></a>拿到处理后的数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, y_train = PreprocessTrainData(train_data)</span><br><span class="line">x_test = PreprocessTestData(test_data)</span><br></pre></td></tr></table></figure>
<h1 id="构建网络模型"><a href="#构建网络模型" class="headerlink" title="构建网络模型"></a>构建网络模型</h1><p>构建网络时需要注意控制网络的大小。模型中容量（模型可学习的参数）不足可能导致欠拟合；但模型也不是越大越好，因为模型过大可能导致过拟合，泛化能力下降。其他降低过拟合的方法包括添加dropout正则化、权重正则化等。此外还需要在评估模型（将在下文阐述）的过程中尝试不同的超参数（学习率等）以找到最佳配置。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三步 构建网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TitanicModel</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建网络-模型定义</span></span><br><span class="line">    model = models.Sequential()</span><br><span class="line">    model.add(layers.Dense(input_dim=<span class="number">9</span>,units=<span class="number">64</span>, kernel_regularizer=regularizers.l1_l2(l1=<span class="number">0.001</span>,l2=<span class="number">0.001</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(layers.Dense(units=<span class="number">64</span>, kernel_regularizer=regularizers.l1_l2(l1=<span class="number">0.001</span>,l2=<span class="number">0.001</span>), activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(layers.Dense(units=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建网络-编译模型</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>, loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="训练模型（带验证集）"><a href="#训练模型（带验证集）" class="headerlink" title="训练模型（带验证集）"></a>训练模型（带验证集）</h1><h2 id="划分测试集和验证集"><a href="#划分测试集和验证集" class="headerlink" title="划分测试集和验证集"></a>划分测试集和验证集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 留出验证集</span></span><br><span class="line">num_val = <span class="number">300</span></span><br><span class="line"><span class="comment"># 将训练集样本顺序 随机打乱</span></span><br><span class="line">np.random.shuffle([x_train,y_train])</span><br><span class="line"><span class="comment"># 取出 前300个 训练样本作为 验证集</span></span><br><span class="line">x_val = x_train[:num_val]</span><br><span class="line"><span class="comment"># 其他的部分作为 真实的训练集</span></span><br><span class="line">partial_x_train = x_train[num_val:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出前三百个的标签 作为 验证集</span></span><br><span class="line">y_val = y_train[:num_val]</span><br><span class="line"><span class="comment"># 其他的 作为真实的训练集</span></span><br><span class="line">partial_y_train = y_train[num_val:]</span><br></pre></td></tr></table></figure>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = TitanicModel()</span><br><span class="line">model.fit(partial_x_train, partial_y_train, epochs = <span class="number">150</span>, batch_size=<span class="number">16</span>, validation_data=(x_val, y_val))</span><br></pre></td></tr></table></figure>
<h1 id="预测测试样本并评估"><a href="#预测测试样本并评估" class="headerlink" title="预测测试样本并评估"></a>预测测试样本并评估</h1><h2 id="预测测试样本"><a href="#预测测试样本" class="headerlink" title="预测测试样本"></a>预测测试样本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_test2 = model.predict_classes(x_test)</span><br><span class="line"><span class="built_in">print</span>(y_test2)</span><br></pre></td></tr></table></figure>
<h2 id="读取正确答案"><a href="#读取正确答案" class="headerlink" title="读取正确答案"></a>读取正确答案</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">real_label_filepath = <span class="string">r&quot;../dataset/Titanic/gender_submission.csv&quot;</span></span><br><span class="line">real_label = pd.read_csv(real_label_filepath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取正确数值一列</span></span><br><span class="line">onehot = pd.get_dummies(data=real_label)</span><br><span class="line">xarray = onehot.values</span><br><span class="line">real = xarray[:,<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(real.shape,y_test2.shape)</span><br></pre></td></tr></table></figure>
<h2 id="输出正确率与保存预测答案"><a href="#输出正确率与保存预测答案" class="headerlink" title="输出正确率与保存预测答案"></a>输出正确率与保存预测答案</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (y_pre,y_rel) <span class="keyword">in</span> <span class="built_in">zip</span>(y_test2,real):</span><br><span class="line">    <span class="keyword">if</span> y_pre == y_rel:</span><br><span class="line">        count = count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;count:&quot;</span>,count)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这个模型的正确率是：&quot;</span> ,count/y_test2.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;../dataset/Titanic/gender_submission_predict.csv&quot;</span>,<span class="string">&#x27;w+&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    csv_file = csv.writer(f)</span><br><span class="line">    csv_file.writerows(y_test2)</span><br></pre></td></tr></table></figure>
<h1 id="这个模型的优点"><a href="#这个模型的优点" class="headerlink" title="这个模型的优点"></a>这个模型的优点</h1><p>这个模型 来自 [<a href="https://zhuanlan.zhihu.com/p/278057962?utm_source=wechat_session&amp;ivk_sa=1024320u">https://zhuanlan.zhihu.com/p/278057962?utm_source=wechat_session&amp;ivk_sa=1024320u</a>]<br>此模型在kaggle上排名前12%。总结其优点如下：</p>
<p>（1）几乎完全没有人工干预。我们并不需要深入理解和分析每种因素对乘客幸存可能性的影响，而只需将数据几乎交由机器自己来学习便能得到准确度极高的预测结果。</p>
<p>（2）几乎没有引入数据集以外的新信息。引入新信息的行为包括将已知的乘客生存信息填入预测结果（kaggle上实现100%准确率的来源）等。此模型仅在数据处理阶段，引入部分常识判断的信息。</p>
<p>（3）<strong>模型泛化能力强</strong>。这里的“泛化”是指在模型建立过程中没有对该问题“过拟合”。实质上一味追求此问题的预测准确率是没有意义的。过度分析并设计复杂的特征工程也许可以提高测试集的准确率，但实质上很可能是对该问题的过拟合，不能在其他类似问题上泛化。</p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Keras</tag>
        <tag>刘二</tag>
        <tag>Kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy、Pandas、Matplotlib  常用代码</title>
    <url>/2021/08/21/Numpy%E3%80%81Pandas%E3%80%81Matplotlib%20%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>@<a href="Numpy、Pandas、Matplotlib  常用代码">TOC</a></p>
<h1 id="Numpy-常用代码"><a href="#Numpy-常用代码" class="headerlink" title="Numpy 常用代码"></a>Numpy 常用代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数组</span></span><br><span class="line">n = numpy.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数组，并做2行3列的分隔</span></span><br><span class="line">m = numpy.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据，分隔成3位数组</span></span><br><span class="line">t = numpy.arange(<span class="number">27</span>).reshape(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载文本，为int方式</span></span><br><span class="line">tx1 = numpy.loadtxt(<span class="string">&quot;numpy.txt&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>, dtype=<span class="string">&quot;int&quot;</span>)</span><br><span class="line"><span class="comment"># 横列替换</span></span><br><span class="line">tx2 = numpy.loadtxt(<span class="string">&quot;numpy.txt&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>, dtype=<span class="string">&quot;int&quot;</span>, unpack=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(tx1)</span><br><span class="line"><span class="built_in">print</span>(tx2)</span><br><span class="line"><span class="comment"># 1:2横截取，[1,2]为选取</span></span><br><span class="line">tx3 = tx1[<span class="number">1</span>:<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(tx3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 竖拼接</span></span><br><span class="line">tx4 = numpy.vstack((tx1, tx2))</span><br><span class="line"><span class="built_in">print</span>(tx4)</span><br><span class="line"><span class="comment"># 横拼接</span></span><br><span class="line">tx5 = numpy.hstack((tx1, tx2))</span><br><span class="line"><span class="built_in">print</span>(tx5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h2><h3 id="arrange-函数：用于创建数值范围并返回数组对象"><a href="#arrange-函数：用于创建数值范围并返回数组对象" class="headerlink" title="arrange 函数：用于创建数值范围并返回数组对象"></a>arrange 函数：用于创建数值范围并返回数组对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.arrange([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],dtype=numpy.int6或dtype=<span class="string">&#x27;i8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="linspace-函数：-用于创建等差数组"><a href="#linspace-函数：-用于创建等差数组" class="headerlink" title="linspace 函数： 用于创建等差数组"></a>linspace 函数： 用于创建等差数组</h3><p>numpy.linspace(start,stop,num,endpoint,retstep,dtype)</p>
<p>dtype：默认为 float64<br>num：设置生成的元素个数<br>endpoint：设置是否包含结束值（stop），False为不包含，<strong>默认为True</strong><br>retstep：设置是否返回步长（即公差），False表示返回，<strong>默认为False</strong>。当值为 True时，返回值为 二元组，包括数组与步长。</p>
<h3 id="logspace-函数：-用于创建等比数组"><a href="#logspace-函数：-用于创建等比数组" class="headerlink" title="logspace 函数： 用于创建等比数组"></a>logspace 函数： 用于创建等比数组</h3><p>numpy.logspace(start,stop,num,endpoint,base,dtype)</p>
<p>start：开始值，值为$base^{start}$    =》 base为底的 start次幂<br>stop：结束值，值为$base^{stop}$    =》base为底的 stop次幂<br>base：底数<br>dtype：默认数据类型 float64<br>endpoint：True为包含结束值，默认为True</p>
<h2 id="numpy-练习题一"><a href="#numpy-练习题一" class="headerlink" title="numpy 练习题一"></a>numpy 练习题一</h2><p><strong>numpy 的基本用法</strong><br>1.导入numpy库<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><br>2.建立一个一维数组 a 初始化为[4,5,6],<br>(1)输出a 的类型（type）<br>(2)输出a的各维度的大小（shape）<br>(3)输出 a的第一个元素（值为4）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(a.dtype)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><br>3.建立一个二维数组 b,初始化为 [ [4, 5, 6],[1, 2, 3]]<br> (1)输出各维度的大小（shape）<br> (2)输出 b(0,0)，b(0,1),b(1,1) 这三个元素（对应值分别为4,5,2）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">1</span>].shape)</span><br><span class="line"><span class="built_in">print</span>(b.shape)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>][<span class="number">0</span>],b[<span class="number">0</span>][<span class="number">1</span>],b[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>4  (1)建立一个全0矩阵 a, 大小为 3x3; 类型为整型（提示: dtype = int）(2)建立一个全1矩阵b,大小为4x5; (3)建立一个单位矩阵c ,大小为4x4; (4)生成一个随机数矩阵d,大小为 3x2.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.zeros([<span class="number">3</span>,<span class="number">3</span>],dtype=<span class="built_in">int</span>)</span><br><span class="line">d = np.ones([<span class="number">4</span>,<span class="number">5</span>],dtype=<span class="built_in">int</span>)</span><br><span class="line">e = np.identity(<span class="number">4</span>,dtype=<span class="built_in">int</span>)</span><br><span class="line">f = np.random.rand(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure><br>5  建立一个数组 a,(值为[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] ) ,(1)打印a; (2)输出 下标为(2,3),(0,0) 这两个数组元素的值<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>][<span class="number">3</span>],a[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><br>6.把上一题的 a数组的 0到1行 2到3列，放到b里面去，（此处不需要从新建立a,直接调用即可）(1),输出b;(2) 输出b 的（0,0）这个元素的值<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a[<span class="number">0</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"> <span class="comment">#？？？ 用ndarray不会</span></span><br></pre></td></tr></table></figure><br>7 把第5题中数组a的最后两行所有元素放到 c中，（提示： a[1:2, :]）(1)输出 c ; (2) 输出 c 中第一行的最后一个元素（提示，使用 -1 表示最后一个元素）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">c = a[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><br>8.建立数组a,初始化a为[[1, 2], [3, 4], [5, 6]]，输出 （0,0）（1,1）（2,0）这三个元素（提示： 使用 print(a[[0, 1, 2], [0, 1, 0]]) ）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#花式索引 第一种</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><br>9.建立矩阵a ,初始化为[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]，输出(0,0),(1,2),(2,0),(3,1) (提示使用 b = np.array([0, 2, 0, 1]) print(a[np.arange(4), b]))<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#花式索引 第二种</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>),b])</span><br></pre></td></tr></table></figure><br>10.对9 中输出的那四个元素，每个都加上10，然后重新输出矩阵a.(提示： a[np.arange(4), b] += 10 ）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组广播</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>),b]+<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br><strong>numpy 的 array 数学操作</strong></p>
<ol>
<li>执行 x = np.array([1, 2])，然后输出 x 的数据类型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure>
12.执行 x = np.array([1.0, 2.0]) ，然后输出 x 的数据类类型<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure>
13.执行 x = np.array([[1, 2], [3, 4]], dtype=np.float64) ，y = np.array([[5, 6], [7, 8]], dtype=np.float64)，然后输出 x+y ,和 np.add(x,y)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(x+y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x,y))</span><br><span class="line"><span class="comment">#总结：在numpy中，add和“+”是一样的</span></span><br></pre></td></tr></table></figure>
14  利用 13题目中的x,y 输出 x-y 和 np.subtract(x,y)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(x-y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x,y))</span><br><span class="line"><span class="comment">#总结：在numpy中，subtract和“-”是一样的</span></span><br></pre></td></tr></table></figure>
15  利用13题目中的x，y 输出 x*y ,和 np.multiply(x, y) 还有 np.dot(x,y),比较差异。然后自己换一个不是方阵的试试。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x,y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x,y))</span><br><span class="line"><span class="built_in">print</span>(x*y)</span><br><span class="line"></span><br><span class="line"><span class="comment">##总结：np.multiply()：数组和矩阵对应位置相乘，输出与相乘数组/矩阵大小一致。</span></span><br><span class="line"><span class="comment"># np.dot():执行矩阵乘法运算，若秩为1，则执行对应位置相乘再相加。</span></span><br><span class="line"><span class="comment"># *：对array执行对应位置相乘</span></span><br></pre></td></tr></table></figure>
16 利用13题目中的x,y,输出 x / y .(提示 ： 使用函数 np.divide())<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x,y))</span><br><span class="line"><span class="built_in">print</span>(x/y)</span><br><span class="line"><span class="comment">## np.divide()与 / 效果相同</span></span><br></pre></td></tr></table></figure>
17 利用13题目中的x,输出 x的 开方。(提示： 使用函数 np.sqrt() )<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure>
18.利用13题目中的x,y ,执行 print(x.dot(y)) 和 print(np.dot(x,y))<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x,y))</span><br><span class="line"><span class="comment">##总结：二维数组矩阵之间dot函数运算得到的乘积是矩阵乘积，一维数组是两个向量的内积</span></span><br></pre></td></tr></table></figure>
19.利用13题目中的 x,进行求和。提示：输出三种求和<br>(1)print(np.sum(x)): (2)print(np.sum(x，axis =0 )); (3)print(np.sum(x,axis = 1))<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment">##总结：axis为0是压缩行,即将每一列的元素相加,将矩阵压缩为一行</span></span><br><span class="line"><span class="comment">## axis为1是压缩列,即将每一行的元素相加,将矩阵压缩为一列，再转置</span></span><br></pre></td></tr></table></figure>
20.利用13题目中的 x,进行求平均数（提示：输出三种平均数(1)print(np.mean(x)) (2)print(np.mean(x,axis = 0))(3) print(np.mean(x,axis =1))）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.mean(x))</span><br><span class="line"><span class="built_in">print</span>(np.mean(x,axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.mean(x,axis =<span class="number">1</span>))</span><br><span class="line"><span class="comment">##总结：axis为0是压缩行,即将每一列的元素相加,将矩阵压缩为一行,再取平均值</span></span><br><span class="line"><span class="comment">## axis为1是压缩列,即将每一行的元素相加,将矩阵压缩为一列，再转置，再取平均值</span></span><br></pre></td></tr></table></figure>
21.利用13题目中的x，对x 进行矩阵转置，然后输出转置后的结果，（提示： x.T 表示对 x 的转置）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(x.T)</span><br></pre></td></tr></table></figure>
22.利用13题目中的x,求e的指数（提示： 函数 np.exp()）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(np.exp(x))</span><br></pre></td></tr></table></figure>
23.利用13题目中的 x,求值最大的下标（提示(1)print(np.argmax(x)) ,(2) print(np.argmax(x, axis =0))(3)print(np.argmax(x),axis =1))<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>]], dtype=np.float64)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(np.argmax(x))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(x, axis =<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(x,axis =<span class="number">1</span>))</span><br><span class="line"><span class="comment">##总结： numpy.argmax(array, axis) 用于返回一个numpy数组中最大值的索引值。</span></span><br><span class="line"><span class="comment"># axis=0则竖着看，当axis=0，是在列中比较，选出最大的 行 索引</span></span><br><span class="line"><span class="comment"># axis=1则横着看, 当axis=1，是在行中比较，选出最大的 列 索引</span></span><br></pre></td></tr></table></figure>
24,画图，y=x*x 其中 x = np.arange(0, 100, 0.1) （提示这里用到 matplotlib.pyplot 库）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x=np.arange(<span class="number">0</span>,<span class="number">100</span>,<span class="number">0.1</span>)</span><br><span class="line">y=x*x</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
25.画图。画正弦函数和余弦函数， x = np.arange(0, 3 * np.pi, 0.1)(提示：这里用到 np.sin() np.cos() 函数和 matplotlib.pyplot 库)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>, <span class="number">3</span>*np.pi, <span class="number">0.1</span>)</span><br><span class="line">y1=np.sin(x)</span><br><span class="line">y2=np.cos(x)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Pandas-常用代码"><a href="#Pandas-常用代码" class="headerlink" title="Pandas 常用代码"></a>Pandas 常用代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">df = pandas.read_csv(<span class="string">&quot;BeijingPM20100101_20151231.csv&quot;</span>)</span><br><span class="line"><span class="comment"># 展示</span></span><br><span class="line"><span class="comment"># print(df.head())</span></span><br><span class="line"><span class="comment"># print(df.info())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接时间</span></span><br><span class="line">period = pandas.PeriodIndex(year=df[<span class="string">&quot;year&quot;</span>], month=df[<span class="string">&quot;month&quot;</span>], day=df[<span class="string">&quot;day&quot;</span>], hour=df[<span class="string">&quot;hour&quot;</span>], freq=<span class="string">&quot;H&quot;</span>)</span><br><span class="line"><span class="comment"># 将时间数据赋值</span></span><br><span class="line">df[<span class="string">&quot;dataTime&quot;</span>] = period</span><br><span class="line"><span class="comment"># 设置索引</span></span><br><span class="line">df.set_index(<span class="string">&quot;dataTime&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># # print(period)</span></span><br><span class="line"><span class="comment"># print(df.head())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过月份统计</span></span><br><span class="line">df = df.resample(<span class="string">&quot;M&quot;</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># (统计)缺失</span></span><br><span class="line">data = df[<span class="string">&quot;PM_US Post&quot;</span>].dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pylot展示</span></span><br><span class="line">x = data.index</span><br><span class="line">y = data.values</span><br><span class="line"></span><br><span class="line">pyplot.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line">pyplot.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(x)), y)</span><br><span class="line">pyplot.xticks(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x), <span class="number">3</span>), x[::<span class="number">3</span>])</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<h1 id="Matplotlib-常用代码"><a href="#Matplotlib-常用代码" class="headerlink" title="Matplotlib 常用代码"></a>Matplotlib 常用代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">y_1 = [<span class="number">10</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">17</span>]</span><br><span class="line">y_2 = [<span class="number">17</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">pyplot.figure(figsize=(<span class="number">20</span>, <span class="number">12</span>), dpi=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整字体</span></span><br><span class="line">matplotlib.rc(<span class="string">&quot;font&quot;</span>, family=<span class="string">&quot;MicroSoft YaHei&quot;</span>,weight=<span class="string">&quot;bold&quot;</span>, size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变刻度</span></span><br><span class="line"><span class="comment"># pyplot.xticks([ i + 1 for i in range(max(x))], [ &quot;time&quot; + str(i + 1) for i in range(max(x))], rotation=45)</span></span><br><span class="line"><span class="comment"># 第一个参数x轴 第二个展示的内容 rotation 旋转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line">pyplot.xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">pyplot.ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">pyplot.title(<span class="string">&quot;折线图&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 折线图</span></span><br><span class="line">pyplot.plot(x, y_1)</span><br><span class="line"><span class="comment"># pyplot.plot(x, y_2)</span></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line"><span class="comment"># pyplot.scatter(x, y_1)</span></span><br><span class="line"><span class="comment"># pyplot.scatter(x, y_2)</span></span><br><span class="line"><span class="comment"># 柱状图</span></span><br><span class="line"><span class="comment"># pyplot.bar(x, y_1)</span></span><br><span class="line"><span class="comment"># pyplot.bar(x, y_2)</span></span><br><span class="line"><span class="comment"># 横版柱状图</span></span><br><span class="line"><span class="comment"># pyplot.barh(range(len(x)), y_1, height=0.3)</span></span><br><span class="line"><span class="comment"># pyplot.barh(range(len(x)), y_2, height=0.3)</span></span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line"><span class="comment"># pyplot.hist(x, (max(x)-min(x))//1)</span></span><br><span class="line">pyplot.xticks(<span class="built_in">range</span>(<span class="built_in">min</span>(x), <span class="built_in">max</span>(x) + <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># pyplot.grid()</span></span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line"><span class="comment"># pyplot.savefig(&quot;link.png&quot;)</span></span><br><span class="line"></span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python框架</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Numpy</tag>
        <tag>Pandas</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch CNN概念性解决</title>
    <url>/2021/09/16/Pytorch%20CNN%E6%A6%82%E5%BF%B5%E6%80%A7%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>@<a href="Pytorch CNN概念性解决">TOC</a><br>需要知道的几点</p>
<ol>
<li>卷积核里的参数都是超参数，是通过训练进行调整的</li>
</ol>
<h1 id="CNN的流程"><a href="#CNN的流程" class="headerlink" title="CNN的流程"></a>CNN的流程</h1><p>input——&gt;convolution——&gt;max pooling——&gt;…——&gt;flatten（压平）——&gt;fully connected network——&gt;output</p>
<h1 id="CNN的卷积操作运算"><a href="#CNN的卷积操作运算" class="headerlink" title="CNN的卷积操作运算"></a>CNN的卷积操作运算</h1><h2 id="单通道图像"><a href="#单通道图像" class="headerlink" title="单通道图像"></a>单通道图像</h2><p><img src="https://img-blog.csdnimg.cn/f37680551d064da8b5dfe82c2e998a8d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="卷积计算方式"></p>
<h2 id="多通道图像-如三通道RGB"><a href="#多通道图像-如三通道RGB" class="headerlink" title="多通道图像  如三通道RGB"></a>多通道图像  如三通道RGB</h2><p>用三个卷积核，分别对3个通道各自卷积，然后再相加整合输出。<br><img src="https://img-blog.csdnimg.cn/379e12b328b14abda21ae5a551f94f9a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="RGB卷积"></p>
<h1 id="如何看待卷积核的个数和通道数"><a href="#如何看待卷积核的个数和通道数" class="headerlink" title="如何看待卷积核的个数和通道数"></a>如何看待卷积核的个数和通道数</h1><p><img src="https://img-blog.csdnimg.cn/21b1a72bd38e4c7984d1b65e3e0f1d2f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="卷积核的个数和通道数"><br>记住两条规律就好：</p>
<ul>
<li>卷积核通道数 = 输入通道数</li>
<li>卷积核个数 = 输出通道数</li>
</ul>
<p>注意卷积层一般都是4维的 包括：批次，输入通道数，卷积核大小（宽，高）<br>可以参考下面的卷积程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入通道数为5  输出通道数为10</span></span><br><span class="line">in_channels,out_channels = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line"><span class="comment"># 初始化图像高度</span></span><br><span class="line">width,height = <span class="number">100</span>,<span class="number">100</span></span><br><span class="line"><span class="comment"># 卷积核的大小</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line"><span class="comment"># 批次</span></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line"><span class="comment"># 随机生成100×100的 图像</span></span><br><span class="line"><span class="built_in">input</span> = torch.randn(batch_size,in_channels,width,height)</span><br><span class="line"><span class="comment"># 设置卷积层 输入维度，输出维度，卷积核大小</span></span><br><span class="line">conv_layer = torch.nn.Conv2d(in_channels,out_channels,kernel_size=kernel_size)</span><br><span class="line"><span class="comment"># 将图片放入卷积层 输出结果</span></span><br><span class="line">output = conv_layer(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># torch.Size([1, 5, 100, 100])</span></span><br><span class="line"><span class="comment"># 分别为 batch_size,图片通道数，图像宽100，图像高100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"><span class="comment"># torch.Size([1, 10, 98, 98])</span></span><br><span class="line"><span class="comment"># 分别为 batch_size,输出通道数10（其实就是卷积核的个数），图像卷积后（由于卷积核是3×3 所以减去2）</span></span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"><span class="comment"># torch.Size([10, 5, 3, 3])</span></span><br><span class="line"><span class="comment"># 输出通道（卷积核数量） 输入通道（卷积核通道数） 卷积核大小</span></span><br><span class="line"><span class="built_in">print</span>(conv_layer.weight.shape)</span><br></pre></td></tr></table></figure>
<h1 id="如何看待-padding"><a href="#如何看待-padding" class="headerlink" title="如何看待 padding"></a>如何看待 padding</h1><p><strong>padding的目的是，为了规定输出图像的大小。</strong><br>例如 原来是  5×5 的原图，通过卷积核为 3×3 那 输出的图 是 3×3 的<br>但如果设置 padding 为1，那么相当于把原图扩充为 7×7 了。<br><img src="https://img-blog.csdnimg.cn/d6da81ad35f544e19c1b32e73f70714f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="padding为1时候的卷积"><br>可以参考一下如下的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 假设的灰度图片像素值 图片为5×5</span></span><br><span class="line"><span class="built_in">input</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,</span><br><span class="line">         <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,</span><br><span class="line">         <span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,</span><br><span class="line">         <span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 将输入的图片变成Tensor类型，并且reshape一下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 参数从左到右分别为</span></span><br><span class="line"><span class="string">    batch_size,in_channels,width,height</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">input</span> = torch.Tensor(<span class="built_in">input</span>).view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积核的大小</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; 从左到右分别为 </span></span><br><span class="line"><span class="string">    in_channels,out_channels,kernel_size</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">conv_layer = torch.nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,padding=<span class="number">1</span>,bias=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    自定义一个tensor向量 再将其 reshape</span></span><br><span class="line"><span class="string">    batch_size,in_channels,width,height</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">kernel = torch.Tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]).view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 初始化卷积层</span></span><br><span class="line">conv_layer.weight.data = kernel.data</span><br><span class="line"></span><br><span class="line">output = conv_layer(<span class="built_in">input</span>)</span><br><span class="line"><span class="comment"># torch.Size([1, 1, 5, 5])</span></span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/8123cd0423f9446ba513f9e8b03bb0d0.png#pic_center" alt="输出结果"></p>
<h1 id="如何看待步长-stride"><a href="#如何看待步长-stride" class="headerlink" title="如何看待步长 stride"></a>如何看待步长 stride</h1><p>设置一下 stride就可以了<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv_layer = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, bias=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br>改变步长的意义，其实就是为了缩小输出尺寸</p>
<h1 id="如何看待Max-Pooling"><a href="#如何看待Max-Pooling" class="headerlink" title="如何看待Max Pooling"></a>如何看待Max Pooling</h1><p><img src="https://img-blog.csdnimg.cn/84eff2cc1acd44c79a6cf251af071e3d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="MaxPooling示意图"><br>可以参考如下的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = [ <span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,</span><br><span class="line">          <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,</span><br><span class="line">          <span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,</span><br><span class="line">          <span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入的 batch_size为1 通道数为1 也就是灰度图像 大小是4×4</span></span><br><span class="line"><span class="built_in">input</span> = torch.Tensor(<span class="built_in">input</span>).view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">#  默认的步长 stride也是2</span></span><br><span class="line">maxpooling_layer = torch.nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">output = maxpooling_layer(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    这里只进行了一个 maxpooling操作</span></span><br><span class="line"><span class="string">    input = [ 3,4,6,5,</span></span><br><span class="line"><span class="string">            2,4,6,8,</span></span><br><span class="line"><span class="string">            1,6,7,8,</span></span><br><span class="line"><span class="string">            9,7,4,6] </span></span><br><span class="line"><span class="string">    变为</span></span><br><span class="line"><span class="string">       [4,8</span></span><br><span class="line"><span class="string">        9,8]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="设计一个网络并实现"><a href="#设计一个网络并实现" class="headerlink" title="设计一个网络并实现"></a>设计一个网络并实现</h1><h2 id="如图所示为-要设计的网络模型"><a href="#如图所示为-要设计的网络模型" class="headerlink" title="如图所示为 要设计的网络模型"></a>如图所示为 要设计的网络模型</h2><p><img src="https://img-blog.csdnimg.cn/b352a2f5626544ae924453466305321f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="要设计的网络模型"></p>
<h2 id="转换成流程图"><a href="#转换成流程图" class="headerlink" title="转换成流程图"></a>转换成流程图</h2><p><img src="https://img-blog.csdnimg.cn/5bbf95bc996345c9a8ae13238acaa8ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Pytorch-代码实现这个网络"><a href="#Pytorch-代码实现这个网络" class="headerlink" title="Pytorch 代码实现这个网络"></a>Pytorch 代码实现这个网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设计网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNNNet</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNNNet, self).__init__()</span><br><span class="line">        self.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = torch.nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.pooling = torch.nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">320</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># Flatten data from (n, 1, 28, 28) to (n, 784)</span></span><br><span class="line">        batch_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = self.pooling(torch.relu(self.conv1(x)))</span><br><span class="line">        x = self.pooling(torch.relu(self.conv2(x)))</span><br><span class="line">        <span class="comment"># flatten (n,320)</span></span><br><span class="line">        x = x.view(batch_size, -<span class="number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 实例化这个网络</span></span><br><span class="line">CNNmodel = CNNNet()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>CNN</tag>
        <tag>刘二</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch GoogleNet中的Inception</title>
    <url>/2021/09/21/Pytorch%20GoogleNet%E4%B8%AD%E7%9A%84Inception/</url>
    <content><![CDATA[<p>@<a href="Pytorch GoogleNet中的Inception">TOC</a></p>
<h1 id="GoogleNet-的概念"><a href="#GoogleNet-的概念" class="headerlink" title="GoogleNet 的概念"></a>GoogleNet 的概念</h1><p>是基于AlexNet，VGG 后的模型</p>
<h1 id="特殊点：Inception"><a href="#特殊点：Inception" class="headerlink" title="特殊点：Inception"></a>特殊点：Inception</h1><h2 id="为什么要提出-Inception"><a href="#为什么要提出-Inception" class="headerlink" title="为什么要提出 Inception"></a>为什么要提出 Inception</h2><p>一般来说，提升网络性能最直接的办法是<strong>增加网络深度和宽度</strong>，但一味地增加，会带来诸多问题：</p>
<ol>
<li>参数太多，如果训练数据集有限，很容易产生过拟合； </li>
<li>网络越大、参数越多，计算复杂度越大，难以应用；</li>
<li>网络越深，容易出现梯度消失问题（梯度越往后穿越容易消失），难以优化模型。</li>
</ol>
<blockquote>
<p><strong>梯度消失和梯度爆炸</strong> 是什么？<br>查看文章   <a href="https://www.jianshu.com/p/ece360b7fabb">如何理解梯度消失和梯度爆炸</a><br>以及本博客文章 <a href="https://jks88995656.github.io/2021/09/20/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E7%90%86%E8%A7%A3/">梯度消失和梯度爆炸的理解</a></p>
</blockquote>
<p>我们希望在增加网络深度和宽度的同时减少参数，为了减少参数，自然就想到将<strong>全连接变成稀疏连接</strong>。但是在实现上，全连接变成稀疏连接后实际计算量并不会有质的提升，因为<font color="blue">大部分硬件是针对密集矩阵计算优化的，稀疏矩阵虽然数据量少，但是计算所消耗的时间却很难减少。</font><br>在这种需求和形势下，Google研究人员提出了Inception的方法。</p>
<h2 id="Inception-模块的结构"><a href="#Inception-模块的结构" class="headerlink" title="Inception 模块的结构"></a>Inception 模块的结构</h2><p>Inception 模块 是GoogleNet 重复使用的重要部分。其最大的特点是 引入了 1×1 的卷积核。其目的是用于 缩小通道数，将像素信息融合，也叫做 <strong>通道压缩</strong>。<br><img src="https://img-blog.csdnimg.cn/img_convert/9f3c90923dc228229c3f6c1695777fa3.png#pic_center" alt="在这里插入图片描述"><br>同时其可以减少卷积核的参数数量 例如:如下的操作数对比（28×28表示 卷积的时候图片像素点也要乘的啊）<br><img src="https://img-blog.csdnimg.cn/img_convert/7e7182fa5f7155ca6f80ac1cc6689c08.png#pic_center" alt="参数变化 用1×1后"><br>Inception 模块的内容如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d98aae54e7979a26c11393e6c0fb7ad3.png#pic_center" alt="Inception 模块结构"></p>
<h2 id="Pytorch-实现-Inception-模块"><a href="#Pytorch-实现-Inception-模块" class="headerlink" title="Pytorch 实现 Inception 模块"></a>Pytorch 实现 Inception 模块</h2><p>下图中为每个部分的代码模块。 每个部分的 上侧是 pytorch中网络初始化部分，下侧是 pytorch中网络前馈实现的部分。<br><img src="https://img-blog.csdnimg.cn/img_convert/065b0f6abeae7092776e18a5b4755ac3.png#pic_center" alt="各部分实现图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InceptionA</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(InceptionA, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个部分</span></span><br><span class="line">        self.branch_pool = torch.nn.Conv2d(in_channels, <span class="number">24</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个部分</span></span><br><span class="line">        self.branch1x1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三个部分</span></span><br><span class="line">        self.branch5x5_1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_2 = torch.nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四个部分</span></span><br><span class="line">        self.branch3x3_1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_2 = torch.nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_3 = torch.nn.Conv2d(<span class="number">24</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 第一个部分</span></span><br><span class="line">        branch_pool = F.avg_pool2d(x, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个部分</span></span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三个部分</span></span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四个部分</span></span><br><span class="line">        branch3x3 = self.branch3x3_1(x)</span><br><span class="line">        branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">        branch3x3 = self.branch3x3_3(branch3x3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通道整合</span></span><br><span class="line">        outputs = [branch_pool, branch1x1, branch5x5, branch3x3]</span><br><span class="line">        <span class="comment"># 整合通道 通道的位置在1处  （batch,通道,宽度,长度）</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="GoogleNet-网络的整体模型"><a href="#GoogleNet-网络的整体模型" class="headerlink" title="GoogleNet 网络的整体模型"></a>GoogleNet 网络的整体模型</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/42c1625cbe9b8e8c37de67bfbf3d319a.png#pic_center" alt="GoogleNet 全貌"></p>
<h1 id="使用Mnist-使用Inception"><a href="#使用Mnist-使用Inception" class="headerlink" title="使用Mnist 使用Inception"></a>使用Mnist 使用Inception</h1><h2 id="构建网络"><a href="#构建网络" class="headerlink" title="构建网络"></a>构建网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = torch.nn.Conv2d(<span class="number">88</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.incep1 = InceptionA(in_channels=<span class="number">10</span>)</span><br><span class="line">        self.incep2 = InceptionA(in_channels=<span class="number">20</span>)</span><br><span class="line">        self.mp = torch.nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">1408</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        in_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = F.relu(self.mp(self.conv1(x)))</span><br><span class="line">        x = self.incep1(x)</span><br><span class="line">        x = F.relu(self.mp(self.conv2(x)))</span><br><span class="line">        x = self.incep2(x)</span><br><span class="line">        <span class="comment"># 变成列向量</span></span><br><span class="line">        x = x.view(in_size, -<span class="number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="Mnist-数据集-训练-整体代码"><a href="#Mnist-数据集-训练-整体代码" class="headerlink" title="Mnist 数据集 训练 整体代码"></a>Mnist 数据集 训练 整体代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步 准备数据</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 用均值和方差进行归一化</span></span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>,</span><br><span class="line">                               train=<span class="literal">True</span>,</span><br><span class="line">                               download=<span class="literal">True</span>,</span><br><span class="line">                               transform=transform)</span><br><span class="line"></span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>,</span><br><span class="line">                              train=<span class="literal">False</span>,</span><br><span class="line">                              download=<span class="literal">True</span>,</span><br><span class="line">                              transform=transform)</span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_dataset,</span><br><span class="line">                          shuffle=<span class="literal">True</span>,</span><br><span class="line">                          batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(test_dataset,</span><br><span class="line">                         shuffle=<span class="literal">False</span>,</span><br><span class="line">                         batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InceptionA</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(InceptionA, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个部分</span></span><br><span class="line">        self.branch_pool = torch.nn.Conv2d(in_channels, <span class="number">24</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个部分</span></span><br><span class="line">        self.branch1x1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三个部分</span></span><br><span class="line">        self.branch5x5_1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_2 = torch.nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四个部分</span></span><br><span class="line">        self.branch3x3_1 = torch.nn.Conv2d(in_channels, <span class="number">16</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_2 = torch.nn.Conv2d(<span class="number">16</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3_3 = torch.nn.Conv2d(<span class="number">24</span>, <span class="number">24</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 第一个部分</span></span><br><span class="line">        branch_pool = F.avg_pool2d(x, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个部分</span></span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三个部分</span></span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四个部分</span></span><br><span class="line">        branch3x3 = self.branch3x3_1(x)</span><br><span class="line">        branch3x3 = self.branch3x3_2(branch3x3)</span><br><span class="line">        branch3x3 = self.branch3x3_3(branch3x3)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通道整合</span></span><br><span class="line">        outputs = [branch_pool, branch1x1, branch5x5, branch3x3]</span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = torch.nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = torch.nn.Conv2d(<span class="number">88</span>, <span class="number">20</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.incep1 = InceptionA(in_channels=<span class="number">10</span>)</span><br><span class="line">        self.incep2 = InceptionA(in_channels=<span class="number">20</span>)</span><br><span class="line">        self.mp = torch.nn.MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.fc = torch.nn.Linear(<span class="number">1408</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        in_size = x.size(<span class="number">0</span>)</span><br><span class="line">        x = F.relu(self.mp(self.conv1(x)))</span><br><span class="line">        x = self.incep1(x)</span><br><span class="line">        x = F.relu(self.mp(self.conv2(x)))</span><br><span class="line">        x = self.incep2(x)</span><br><span class="line">        <span class="comment"># 变成列向量</span></span><br><span class="line">        x = x.view(in_size, -<span class="number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个网络模型</span></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 定义损失函数和优化器</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            outputs = model(data)</span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)</span><br><span class="line">            correct += predicted.eq(target.view_as(predicted)).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%) \n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    )) \</span><br><span class="line"> \</span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epochs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">                <span class="comment"># prepare data</span></span><br><span class="line">                inputs, labels = data</span><br><span class="line">                <span class="comment"># 前馈</span></span><br><span class="line">                y_predict = model(inputs)</span><br><span class="line">                loss = criterion(y_predict, labels)</span><br><span class="line">                <span class="comment"># 反馈</span></span><br><span class="line">                optimizer.zero_grad()</span><br><span class="line">                loss.backward()</span><br><span class="line">                <span class="comment"># 更新</span></span><br><span class="line">                optimizer.step()</span><br><span class="line">                <span class="keyword">if</span> (batch_idx + <span class="number">1</span>) % <span class="number">30</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                        epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                               <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/73857137">深度学习|经典网络：GoogLeNet（一）</a><br><a href="https://zhuanlan.zhihu.com/p/89002063">GoogLeNet</a></p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Pytorch</tag>
        <tag>GoogleNet</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 多分类问题的解决</title>
    <url>/2021/09/15/Pytorch%20%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>@<a href="Pytorch 多分类问题的解决">TOC</a></p>
<h1 id="多分类问题-激活函数的选择-Softmax"><a href="#多分类问题-激活函数的选择-Softmax" class="headerlink" title="多分类问题 激活函数的选择 Softmax"></a>多分类问题 激活函数的选择 Softmax</h1><p><img src="https://img-blog.csdnimg.cn/87f8f15a7fc0480d95ba08f55f1c6a4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="应该解决的条件"><br>选择 Softmax 函数的关键点是：</p>
<ul>
<li>确保输出的每一个概率都是 ≥ 0 的</li>
<li>所有的概率之和应该为 1</li>
</ul>
<p>Softmax 激活函数完美解决了这个问题：</p>
<p><img src="https://img-blog.csdnimg.cn/a3a45fd36d8d4f45a7c7347e26e7d744.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="Softmax公式"><br>举个简单的例子<br><img src="https://img-blog.csdnimg.cn/799dea5f0b8348cea9c294567d552202.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="算数案例"></p>
<h1 id="CrossEntropyLoss-和-NLLLoss区别"><a href="#CrossEntropyLoss-和-NLLLoss区别" class="headerlink" title="CrossEntropyLoss 和 NLLLoss区别"></a>CrossEntropyLoss 和 NLLLoss区别</h1><p>NLLLoss全称是Negative Log Likelyhood Loss，负对数似然损失函数。<br>softmax + NLLLoss = CrossEntropyLoss</p>
<p>在Pytorch中</p>
<ul>
<li>CrossEntropyLoss可以直接接到模型结果之后，直接得出交叉熵损失。</li>
<li>NLLLoss需要在模型结果后先接一个Softmax，将模型结果变成概率，再用NLLLoss求预测损失。</li>
</ul>
<h1 id="实现梯度下降"><a href="#实现梯度下降" class="headerlink" title="实现梯度下降"></a>实现梯度下降</h1><h2 id="Step1：准备数据"><a href="#Step1：准备数据" class="headerlink" title="Step1：准备数据"></a>Step1：准备数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_data = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">y_data = [<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Step2：初始化参数w"><a href="#Step2：初始化参数w" class="headerlink" title="Step2：初始化参数w"></a>Step2：初始化参数w</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始值w为1</span></span><br><span class="line">w = <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Step3：定义模型"><a href="#Step3：定义模型" class="headerlink" title="Step3：定义模型"></a>Step3：定义模型</h2><p><img src="https://img-blog.csdnimg.cn/45983f52cebc4ab2b4d3cf4e0ee7e16b.png#pic_center" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">x_data</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x_data * w</span><br></pre></td></tr></table></figure></p>
<h2 id="Step4：定义损失函数"><a href="#Step4：定义损失函数" class="headerlink" title="Step4：定义损失函数"></a>Step4：定义损失函数</h2><p><img src="https://img-blog.csdnimg.cn/fb6f96943d1b46a696049f6c07965484.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">x_data, y_data</span>):</span></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        y_pred = forward(x)</span><br><span class="line">        loss = loss + (y_pred - y) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> loss / <span class="built_in">len</span>(x_data)</span><br></pre></td></tr></table></figure>
<h2 id="Step5：定义梯度"><a href="#Step5：定义梯度" class="headerlink" title="Step5：定义梯度"></a>Step5：定义梯度</h2><p><img src="https://img-blog.csdnimg.cn/845af8941e0c4ee08fe574a29c869950.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求梯度 也就是 损失函数对w的偏导</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient</span>(<span class="params">x_data, y_data</span>):</span></span><br><span class="line">    grad = <span class="number">0</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    x = [1, 2, 3]</span></span><br><span class="line"><span class="string">    y = [4, 5, 6, 7]</span></span><br><span class="line"><span class="string">    xy = zip(x, y)</span></span><br><span class="line"><span class="string">    print xy</span></span><br><span class="line"><span class="string">    运行的结果是： [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data):</span><br><span class="line">        grad = grad + <span class="number">2</span> * x * (x * w - y)</span><br><span class="line">    <span class="keyword">return</span> grad / <span class="built_in">len</span>(x_data)</span><br></pre></td></tr></table></figure>
<h2 id="Step6：训练并更新参数-w"><a href="#Step6：训练并更新参数-w" class="headerlink" title="Step6：训练并更新参数 w"></a>Step6：训练并更新参数 w</h2><p><img src="https://img-blog.csdnimg.cn/731d4beb873c41938a42b58461044c56.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没训练过的时候 w是初始值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predict (before training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 这批数据样本 训练 99次</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 每次都是计算一整个数据集的 平均loss</span></span><br><span class="line">    loss_val = loss(x_data, y_data)</span><br><span class="line">    grad_val = gradient(x_data, y_data)</span><br><span class="line">    w = w - <span class="number">0.01</span> * grad_val</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, epoch, <span class="string">&#x27;w=&#x27;</span>, w, <span class="string">&#x27;loss=&#x27;</span>, loss_val)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predict (after training)&#x27;</span>, <span class="number">4</span>, forward(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h1 id="实现多分类"><a href="#实现多分类" class="headerlink" title="实现多分类"></a>实现多分类</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步 准备数据</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 用均值和方差进行归一化</span></span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>,</span><br><span class="line">                               train=<span class="literal">True</span>,</span><br><span class="line">                               download=<span class="literal">True</span>,</span><br><span class="line">                               transform=transform)</span><br><span class="line"></span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&#x27;../dataset/mnist/&#x27;</span>,</span><br><span class="line">                              train=<span class="literal">False</span>,</span><br><span class="line">                              download=<span class="literal">True</span>,</span><br><span class="line">                              transform=transform)</span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_dataset,</span><br><span class="line">                          shuffle=<span class="literal">True</span>,</span><br><span class="line">                          batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(test_dataset,</span><br><span class="line">                         shuffle=<span class="literal">False</span>,</span><br><span class="line">                         batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步 设计模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这个是必须写的</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 构建层次模型</span></span><br><span class="line">        self.l1 = torch.nn.Linear(<span class="number">784</span>, <span class="number">512</span>)</span><br><span class="line">        self.l2 = torch.nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line">        self.l3 = torch.nn.Linear(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">        self.l4 = torch.nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.l5 = torch.nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>,<span class="number">784</span>)</span><br><span class="line">        x = F.relu(self.l1(x))</span><br><span class="line">        x = F.relu(self.l2(x))</span><br><span class="line">        x = F.relu(self.l3(x))</span><br><span class="line">        x = F.relu(self.l4(x))</span><br><span class="line">        <span class="keyword">return</span> self.l5(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个网络模型</span></span><br><span class="line">model = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 定义损失函数和优化器</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 这个0 的意思表示 索引从0开始计</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">        inputs, target = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + update</span></span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">300</span> == <span class="number">299</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] loss: %.3f&#x27;</span> % (epoch + <span class="number">1</span>, batch_idx + <span class="number">1</span>, running_loss / <span class="number">300</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步 测试并检验</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">            images, labels = data</span><br><span class="line">            outputs = model(images)</span><br><span class="line">            <span class="comment">#输出每行最大的那个</span></span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, dim=<span class="number">1</span>)</span><br><span class="line">            total += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accuracy on test set: %d %%&#x27;</span> % (<span class="number">100</span> * correct / total))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(epoch)</span><br><span class="line">        test()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Pytorch</tag>
        <tag>分类问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 实现 简易逻辑回归模型 —— 刘二</title>
    <url>/2021/09/12/Pytorch%20%E5%AE%9E%E7%8E%B0%20%E7%AE%80%E6%98%93%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%20%E2%80%94%E2%80%94%20%E5%88%98%E4%BA%8C/</url>
    <content><![CDATA[<p>@<a href="Pytorch 实现 简易逻辑回归模型 —— 刘二">TOC</a></p>
<p>用Pytorch 实现 简单的逻辑回归。整个流程图可以如下图所示：<br><img src="https://img-blog.csdnimg.cn/ed9e3efcda894426bc9e66c6c0c5d408.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="逻辑回归预测流程"></p>
<p>大致的设计步骤 分为5步 如下所示：<br><img src="https://img-blog.csdnimg.cn/66ed2d3a9e914f229e8c67a8248b1dee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>第五步：是进行 评估模型并预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<h1 id="Step1：准备数据"><a href="#Step1：准备数据" class="headerlink" title="Step1：准备数据"></a>Step1：准备数据</h1><p><img src="https://img-blog.csdnimg.cn/91dc702ff784417993b5d0e5f63f75ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<h1 id="Step2：设计模型"><a href="#Step2：设计模型" class="headerlink" title="Step2：设计模型"></a>Step2：设计模型</h1><p>内涵的线性模型比较简单 为 $y=Wx+b$ 只有两个超参数 W 和 b</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二步 设计模型</span></span><br><span class="line"><span class="comment"># 构建一个线性模型类 所有的模型类都必须继承torch.nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类的构造 这步必须得有</span></span><br><span class="line">        <span class="built_in">super</span>(LogisticRegressionModel, self).__init__()</span><br><span class="line">        <span class="comment"># Linear 是一个模型类 这边实例化他给 linear</span></span><br><span class="line">        <span class="comment"># w 权重 = 1  b 偏置 = 1</span></span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 线性模型之后 在外套sigmoid激活函数</span></span><br><span class="line">        y_pred = torch.sigmoid(self.linear(x))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure>
<h2 id="torch-nn-Linear-in-features-out-features-bias-True-方法"><a href="#torch-nn-Linear-in-features-out-features-bias-True-方法" class="headerlink" title="torch.nn.Linear(in_features,out_features,bias=True) 方法"></a>torch.nn.Linear(in_features,out_features,bias=True) 方法</h2><p><img src="https://img-blog.csdnimg.cn/0e75527101244e56a7687acb4eaa9315.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>实例化这个模型为 model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化这个模型</span></span><br><span class="line">model = LogisticRegressionModel()</span><br></pre></td></tr></table></figure>
<h1 id="Step3：构建损失函数和优化器"><a href="#Step3：构建损失函数和优化器" class="headerlink" title="Step3：构建损失函数和优化器"></a>Step3：构建损失函数和优化器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三步 构建损失函数和优化器</span></span><br><span class="line"><span class="comment"># BCELoss  Binary Cross Entropy</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>) <span class="comment"># size_average = True 的话 就 乘以 1/N  默认为true</span></span><br><span class="line"><span class="comment">#model.parameters() 可以找到模型所有需要训练的参数</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>) </span><br></pre></td></tr></table></figure>
<h2 id="torch-nn-BCELoss-size-average-False-方法"><a href="#torch-nn-BCELoss-size-average-False-方法" class="headerlink" title="torch.nn.BCELoss(size_average=False) 方法"></a>torch.nn.BCELoss(size_average=False) 方法</h2><p>用于创建一个 BCE 损失函数<br><img src="https://img-blog.csdnimg.cn/c901445a0aad460d8c7c50e0a9287cd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="torch-optim-SGD-…-方法"><a href="#torch-optim-SGD-…-方法" class="headerlink" title="torch.optim.SGD(…) 方法"></a>torch.optim.SGD(…) 方法</h2><p>优化器选择 SGD   可调整学习率<br>$w^{*} = w - α\frac{\partial L}{\partial W}$<br><img src="https://img-blog.csdnimg.cn/aab4fe33c3844ea386a7c14cc9350865.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="Step4-训练模型"><a href="#Step4-训练模型" class="headerlink" title="Step4: 训练模型"></a>Step4: 训练模型</h1><p> 前两步 就是正向传播 forward</p>
<ol>
<li>预测 标签</li>
<li>预测 与 实际 算出损失值</li>
<li>反向传播 backward 优化参数</li>
<li>更新参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss.item() )</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br></pre></td></tr></table></figure>
<h1 id="Step5-评估模型并预测"><a href="#Step5-评估模型并预测" class="headerlink" title="Step5: 评估模型并预测"></a>Step5: 评估模型并预测</h1><p>这边没有准备 测试集及其标签</p>
<p>输出 超参数  权重w 和 偏置b<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出 超参数  权重w 和 偏置b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w = &#x27;</span>,model.linear.weight.item() )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>,model.linear.bias.item())</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测 </span></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x为4.0 预测的 y值为：&#x27;</span>,y_test.data)</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p><font color="red"> 这边少了 怎么输出 准确率？ </font><br><img src="https://img-blog.csdnimg.cn/e9bb2b08573e4016bb049d6289513ec9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="可以画一下图"><a href="#可以画一下图" class="headerlink" title="可以画一下图"></a>可以画一下图</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">x_t = torch.Tensor(x).view((<span class="number">200</span>, <span class="number">1</span>))</span><br><span class="line">y_t = model(x_t)</span><br><span class="line">y = y_t.data.numpy()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">10</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>], c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Hours&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Probability of Pass&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 第一步 载入数据</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步 设计模型</span></span><br><span class="line"><span class="comment"># 构建一个线性模型类 所有的模型类都必须继承torch.nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类的构造 这步必须得有</span></span><br><span class="line">        <span class="built_in">super</span>(LogisticRegressionModel, self).__init__()</span><br><span class="line">        <span class="comment"># Linear 是一个模型类 这边实例化他给 linear</span></span><br><span class="line">        <span class="comment"># w 权重 = 1  b 偏置 = 1</span></span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 线性模型之后 在外套sigmoid激活函数</span></span><br><span class="line">        y_pred = torch.sigmoid(self.linear(x))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个模型</span></span><br><span class="line">model = LogisticRegressionModel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 构建损失函数和优化器</span></span><br><span class="line"><span class="comment"># BCELoss  Binary Cross Entropy</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>) <span class="comment"># size_average = True 的话 就 乘以 1/N  默认为true</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>) <span class="comment">#model.parameters() 可以找到</span></span><br><span class="line"><span class="comment"># 模型所有需要训练的参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 前两步 就是正向传播 forward</span></span><br><span class="line"><span class="string">    1. 预测 标签</span></span><br><span class="line"><span class="string">    2. 预测 与 实际 算出损失值</span></span><br><span class="line"><span class="string">    3. 反向传播 backward 优化参数</span></span><br><span class="line"><span class="string">    4. 更新参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss.item() )</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步 评估模型</span></span><br><span class="line"><span class="comment"># 输出 超参数  权重w 和 偏置b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w = &#x27;</span>,model.linear.weight.item() )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>,model.linear.bias.item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x为4.0 预测的 y值为：&#x27;</span>,y_test.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">x_t = torch.Tensor(x).view((<span class="number">200</span>, <span class="number">1</span>))</span><br><span class="line">y_t = model(x_t)</span><br><span class="line">y = y_t.data.numpy()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">10</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>], c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Hours&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Probability of Pass&#x27;</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>刘二</tag>
        <tag>Pytorch</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 实现 多维特征的输入——糖尿病预测</title>
    <url>/2021/09/13/Pytorch%20%E5%AE%9E%E7%8E%B0%20%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81%E7%9A%84%E8%BE%93%E5%85%A5%E2%80%94%E2%80%94%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>@<a href="Pytorch 实现 多维特征的输入——糖尿病预测">TOC</a></p>
<p>整体的设计思路<br>大致的设计步骤 分为5步 如下所示：<br><img src="https://img-blog.csdnimg.cn/66ed2d3a9e914f229e8c67a8248b1dee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="实现的步骤"><br>第五步：是进行 评估模型并预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h1 id="Step1：准备数据"><a href="#Step1：准备数据" class="headerlink" title="Step1：准备数据"></a>Step1：准备数据</h1><p>数据格式包含759个样本，其中有8个特征已经其是否会加剧糖尿病的预测标签（1或0）。<br><img src="https://img-blog.csdnimg.cn/7475f37ead424166967915beceedd5ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="数据维度预览"><br>我们将759个样本，分为758个训练样本以及1个测试样本。</p>
<p>先读入本地 csv 文件内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    numpy读取本地文件</span></span><br><span class="line"><span class="string">    delimiter 分割号</span></span><br><span class="line"><span class="string">    dtype 读取数据类型  一般机器学习类的都是float32 </span></span><br><span class="line"><span class="string">    因为显卡一般他内核里面是按32位工作的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;./dataset/diabetes.csv&#x27;</span>,delimiter=<span class="string">&quot;,&quot;</span>,dtype=np.float32)</span><br></pre></td></tr></table></figure>
<p>可以查看一下 读入的数据维度情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (759,9) 759行 9列</span></span><br><span class="line"><span class="built_in">print</span>(xy.shape)</span><br></pre></td></tr></table></figure>
<p>其中758个样本作为测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">x_train = torch.from_numpy(xy[:-<span class="number">1</span>,:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line">y_train = torch.from_numpy(xy[:-<span class="number">1</span>,[-<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p>最后一个样本作为训练集，用于预测结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当测试样本 的 一组数据</span></span><br><span class="line">x_test = torch.from_numpy(xy[-<span class="number">1</span>:,:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_test.shape)</span><br><span class="line">y_test = torch.from_numpy(xy[-<span class="number">1</span>:,[-<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<h1 id="Step2：定义模型"><a href="#Step2：定义模型" class="headerlink" title="Step2：定义模型"></a>Step2：定义模型</h1><p>同样每一层都为 逻辑回归模型。但这边有8个特征，所以导入的应该是个矩阵。<br><img src="https://img-blog.csdnimg.cn/79a71c6a9f0245d9914e4fcef6607793.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="怎么构建线性模型"><br><img src="https://img-blog.csdnimg.cn/ad19f89d0a57481e8f2bdb1e37e8d7ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="数据维度的变换 输入n行8个特征得到n行1列的预测"></p>
<h2 id="torch-nn-Linear-in-features-out-features-bias-True-方法"><a href="#torch-nn-Linear-in-features-out-features-bias-True-方法" class="headerlink" title="torch.nn.Linear(in_features,out_features,bias=True) 方法"></a>torch.nn.Linear(in_features,out_features,bias=True) 方法</h2><p><img src="https://img-blog.csdnimg.cn/0e75527101244e56a7687acb4eaa9315.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="torch.nn.Linear函数详解"><br>下面这个函数 使得8维度线性变换为6维度<br>注：1.整个模型都是以 列向量为操作单位的（这么做其实是为了利用计算机的并行计算能力加快训练速度），所以维度指的是有多少列，比如左下角这个维度就是8。<br>2.激活函数的引入，其实就是为了引入非线性的因素。这样就可以使得我们可以非线性的变换矩阵维度。<br><img src="https://img-blog.csdnimg.cn/1c73a9cbdba047818bda33c1c9ab517f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="8D到6D的真正含义"><br>下面是我们 构建的整体的 线性网络模型<br><img src="https://img-blog.csdnimg.cn/06e1c8bb27054087bce6ccb4c0eee8c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="整体网络模型"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二部 定义模型</span></span><br><span class="line"><span class="comment"># 这个其实有点类似与 神经网络的结构了 每个线性层后面都加了一个sigmoid函数 做了次非线性变换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullLeanerModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 定义多层线性模型的结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FullLeanerModel,self).__init__()</span><br><span class="line">        <span class="comment"># 第一个线性转换 将8维转换为6维</span></span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前馈 运行输出结果</span></span><br><span class="line">    <span class="comment"># 会被自动调用 是方法的重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="comment"># 用一个变量比较 简单</span></span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        x = self.sigmoid(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span>  x</span><br></pre></td></tr></table></figure>
<p>实例化这个模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">FullLeanerModel = FullLeanerModel()</span><br></pre></td></tr></table></figure>
<h1 id="Step3：定义损失函数和优化器"><a href="#Step3：定义损失函数和优化器" class="headerlink" title="Step3：定义损失函数和优化器"></a>Step3：定义损失函数和优化器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三步 定义 损失函数和优化器</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(FullLeanerModel.parameters(),lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Step4：训练模型"><a href="#Step4：训练模型" class="headerlink" title="Step4：训练模型"></a>Step4：训练模型</h1><p>训练模型100次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 前两步 就是正向传播 forward</span></span><br><span class="line"><span class="string">    1. 预测 标签</span></span><br><span class="line"><span class="string">    2. 预测 与 实际 算出损失值</span></span><br><span class="line"><span class="string">    3. 反向传播 backward 优化参数</span></span><br><span class="line"><span class="string">    4. 更新参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    y_pred = FullLeanerModel(x_train)</span><br><span class="line">    loss = criterion(y_pred,y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss.item())</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br></pre></td></tr></table></figure>
<h1 id="评估模型并预测"><a href="#评估模型并预测" class="headerlink" title="评估模型并预测"></a>评估模型并预测</h1><h2 id="输出所有层次的-权重和偏置"><a href="#输出所有层次的-权重和偏置" class="headerlink" title="输出所有层次的 权重和偏置"></a>输出所有层次的 权重和偏置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># 输出各层  权重w 和 偏置b</span></span><br><span class="line"><span class="keyword">for</span> weight, bias <span class="keyword">in</span> FullLeanerModel.state_dict().items():  <span class="comment"># param is weight or bias(Tensor)</span></span><br><span class="line"><span class="built_in">print</span>( weight,bias)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5c3c93e1544a4005873d7fabd4f88e51.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="各层次的权重和偏置值"></p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测</span></span><br><span class="line">y_yuce = FullLeanerModel(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试样本的预测值为&quot;</span>,y_yuce.data,<span class="string">&quot;实际样本的标签值为&quot;</span>,y_test.data)</span><br></pre></td></tr></table></figure>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    numpy读取本地文件</span></span><br><span class="line"><span class="string">    delimiter 分割号</span></span><br><span class="line"><span class="string">    dtype 读取数据类型  一般机器学习类的都是float32 因为显卡一般他内核里面是按32位工作的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;./dataset/diabetes.csv&#x27;</span>,delimiter=<span class="string">&quot;,&quot;</span>,dtype=np.float32)</span><br><span class="line"><span class="comment"># (759,9) 759行 9列</span></span><br><span class="line"><span class="built_in">print</span>(xy.shape)</span><br><span class="line"><span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">x_train = torch.from_numpy(xy[:-<span class="number">1</span>,:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line">y_train = torch.from_numpy(xy[:-<span class="number">1</span>,[-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当测试样本 的 一组数据</span></span><br><span class="line">x_test = torch.from_numpy(xy[-<span class="number">1</span>:,:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_test.shape)</span><br><span class="line">y_test = torch.from_numpy(xy[-<span class="number">1</span>:,[-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二部 定义模型</span></span><br><span class="line"><span class="comment"># 这个其实有点类似与 神经网络的结构了 每个线性层后面都加了一个sigmoid函数 做了次非线性变换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullLeanerModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 定义多层线性模型的结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FullLeanerModel,self).__init__()</span><br><span class="line">        <span class="comment"># 第一个线性转换 将8维转换为6维</span></span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>,<span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前馈 运行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="comment"># 用一个变量比较 简单</span></span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        x = self.sigmoid(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span>  x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">FullLeanerModel = FullLeanerModel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 定义 损失函数和优化器</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(FullLeanerModel.parameters(),lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 前两步 就是正向传播 forward</span></span><br><span class="line"><span class="string">    1. 预测 标签</span></span><br><span class="line"><span class="string">    2. 预测 与 实际 算出损失值</span></span><br><span class="line"><span class="string">    3. 反向传播 backward 优化参数</span></span><br><span class="line"><span class="string">    4. 更新参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    y_pred = FullLeanerModel(x_train)</span><br><span class="line">    loss = criterion(y_pred,y_train)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss.item())</span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/f600a0b6fbe24b60b35a0f2bc26f9444.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16<span class="comment">#pic_center)</span></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步 评估模型</span></span><br><span class="line">    <span class="comment"># 输出各层  权重w 和 偏置b</span></span><br><span class="line"><span class="keyword">for</span> weight, bias <span class="keyword">in</span> FullLeanerModel.state_dict().items():  <span class="comment"># param is weight or bias(Tensor)</span></span><br><span class="line">    <span class="built_in">print</span>( weight,bias)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">y_yuce = FullLeanerModel(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试样本的预测值为&quot;</span>,y_yuce.data,<span class="string">&quot;实际样本的标签值为&quot;</span>,y_test.data)</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p><img src="https://img-blog.csdnimg.cn/d4fac45272664d249443217900408b79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="实验结果"><br>可以看到 最后一个样本模型预测概率是 0.6529 。&gt;0.5 我们可以推测其标签就是1，而实际标签也是1，所以这个模型预测结果目前看是正确的。</p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>刘二</tag>
        <tag>Pytorch</tag>
        <tag>多维度特征</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 实现 线性回归模型 —— 刘二</title>
    <url>/2021/09/08/Pytorch%20%E5%AE%9E%E7%8E%B0%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%20%E2%80%94%E2%80%94%20%E5%88%98%E4%BA%8C/</url>
    <content><![CDATA[<p>@<a href="Pytorch 实现 线性回归模型 —— 刘二">TOC</a></p>
<p>用Pytorch 实现 线性模型。整个流程图可以如下图所示：<br><img src="https://img-blog.csdnimg.cn/0728aba4a28542838fdb11f7bf4a668c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>大致的设计步骤 分为5步 如下所示：<br><img src="https://img-blog.csdnimg.cn/e1aa1c61b89b4e46adebe9d44c61ff2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>第五步：是进行 评估模型并预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<h1 id="Step1：准备数据"><a href="#Step1：准备数据" class="headerlink" title="Step1：准备数据"></a>Step1：准备数据</h1><p><img src="https://img-blog.csdnimg.cn/91dc702ff784417993b5d0e5f63f75ed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>],[<span class="number">2.0</span>],[<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>],[<span class="number">4.0</span>],[<span class="number">6.0</span>]])</span><br></pre></td></tr></table></figure>
<h1 id="Step2：设计模型"><a href="#Step2：设计模型" class="headerlink" title="Step2：设计模型"></a>Step2：设计模型</h1><p>这边的线性模型比较简单 为 $y=Wx+b$ 只有两个超参数 W 和 b<br><img src="https://img-blog.csdnimg.cn/51e148a09e1d452e8a4e9794e3c4035a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>要通过输入的维度和 输出的维度，才能明确 $W$ 和 $b$ 的维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个线性模型类 所有的模型类都必须继承torch.nn.Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">	<span class="comment"># 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类的构造 这步必须得有</span></span><br><span class="line">        <span class="built_in">super</span>(LinearModel,self).__init__()</span><br><span class="line">        <span class="comment"># Linear 是一个模型类 这边实例化他给 对象linear</span></span><br><span class="line">        <span class="comment"># w 权重 = 1  b 偏执 = 1</span></span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">	<span class="comment"># 方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    	<span class="comment"># 预测值 </span></span><br><span class="line">        y_pred = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure>
<h2 id="torch-nn-Linear-in-features-out-features-bias-True-方法"><a href="#torch-nn-Linear-in-features-out-features-bias-True-方法" class="headerlink" title="torch.nn.Linear(in_features,out_features,bias=True) 方法"></a>torch.nn.Linear(in_features,out_features,bias=True) 方法</h2><p><img src="https://img-blog.csdnimg.cn/0e75527101244e56a7687acb4eaa9315.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>实例化这个模型为 model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化这个模型</span></span><br><span class="line">model = LinearModel()</span><br></pre></td></tr></table></figure>
<h1 id="Step3：构建损失函数和优化器"><a href="#Step3：构建损失函数和优化器" class="headerlink" title="Step3：构建损失函数和优化器"></a>Step3：构建损失函数和优化器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数：mean squared error</span></span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>) <span class="comment"># size_average = True 的话 就 乘以 1/N  默认为true</span></span><br><span class="line"><span class="comment"># model.parameters() 可以找到模型所有需要训练的参数   优化器：SGD</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>) </span><br></pre></td></tr></table></figure>
<h2 id="torch-nn-MSELoss-size-average-False-方法"><a href="#torch-nn-MSELoss-size-average-False-方法" class="headerlink" title="torch.nn.MSELoss(size_average=False) 方法"></a>torch.nn.MSELoss(size_average=False) 方法</h2><p>用于创建一个MSE损失函数<br><img src="https://img-blog.csdnimg.cn/4921387ab8ea4db6a6aaca5ed892fef5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="torch-optim-SGD-…-方法"><a href="#torch-optim-SGD-…-方法" class="headerlink" title="torch.optim.SGD(…) 方法"></a>torch.optim.SGD(…) 方法</h2><p>优化器选择 SGD   可调整学习率<br>$w^{*} = w - α\frac{\partial L}{\partial W}$<br><img src="https://img-blog.csdnimg.cn/aab4fe33c3844ea386a7c14cc9350865.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="Step4-训练模型"><a href="#Step4-训练模型" class="headerlink" title="Step4: 训练模型"></a>Step4: 训练模型</h1><p> 前两步 就是正向传播 forward</p>
<ol>
<li>预测 标签</li>
<li>预测 与 实际 算出损失值</li>
<li>反向传播 backward 优化参数</li>
<li>更新参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"> <span class="comment">#数据跑 99次  range是不到那个数字的</span></span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br></pre></td></tr></table></figure>
<h1 id="Step5-评估模型并预测"><a href="#Step5-评估模型并预测" class="headerlink" title="Step5: 评估模型并预测"></a>Step5: 评估模型并预测</h1><p>这边没有准备 测试集及其标签</p>
<p>输出 超参数  权重w 和 偏置b<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出 超参数  权重w 和 偏置b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w = &#x27;</span>,model.linear.weight.item() )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>,model.linear.bias.item())</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测 </span></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x为4.0 预测的 y值为：&#x27;</span>,y_test.data)</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p><font color="red"> 这边少了 怎么输出 准确率？ </font><br><img src="https://img-blog.csdnimg.cn/c0013d6d060148b8ac02605d0fa0d163.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>],[<span class="number">2.0</span>],[<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>],[<span class="number">4.0</span>],[<span class="number">6.0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步 设计模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用父类的构造 这步必须得有</span></span><br><span class="line">        <span class="built_in">super</span>(LinearModel,self).__init__()</span><br><span class="line">        <span class="comment"># Linear 是一个模型类 这边实例化他给 linear</span></span><br><span class="line">        <span class="comment"># w 权重 = 1  b 偏执 = 1</span></span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        y_pred = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个模型</span></span><br><span class="line">model = LinearModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 构建损失函数和优化器</span></span><br><span class="line"><span class="comment"># mean squared error</span></span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>) <span class="comment"># size_average = True 的话 就 乘以 1/N  默认为true</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>) <span class="comment">#model.parameters() 可以找到</span></span><br><span class="line"><span class="comment"># 模型所有需要训练的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 前两步 就是正向传播 forward</span></span><br><span class="line"><span class="string">    1. 预测 标签</span></span><br><span class="line"><span class="string">    2. 预测 与 实际 算出损失值</span></span><br><span class="line"><span class="string">    3. 反向传播 backward 优化参数</span></span><br><span class="line"><span class="string">    4. 更新参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    loss = criterion(y_pred,y_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;迭代次数:&#x27;</span>,epoch,<span class="string">&quot;  损失值:&quot;</span>,loss)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad() <span class="comment"># 梯度清零</span></span><br><span class="line">    loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()   <span class="comment">#更新参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步 评估模型</span></span><br><span class="line"><span class="comment"># 输出 超参数  权重w 和 偏置b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w = &#x27;</span>,model.linear.weight.item() )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b = &#x27;</span>,model.linear.bias.item())</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">x_test = torch.Tensor([[<span class="number">4.0</span>]])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x为4.0 预测的 y值为：&#x27;</span>,y_test.data)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>刘二</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 封装函数</title>
    <url>/2021/09/17/Pytorch%20%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>@<a href="Pytorch 封装函数">TOC</a></p>
<h1 id="torch-tensor-view"><a href="#torch-tensor-view" class="headerlink" title="torch.tensor.view"></a>torch.tensor.view</h1><p>Tensor.view(*shape) → Tensor<br> view()的作用相当于numpy中的reshape，重新定义矩阵的形状。<br> <img src="https://img-blog.csdnimg.cn/95e47412ecb142e1b2f5dfcb469d9762.png#pic_center" alt="在这里插入图片描述"><br>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt;a:tensor([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>, <span class="number">12.</span>, <span class="number">13.</span>, <span class="number">14.</span>,</span><br><span class="line">        <span class="number">15.</span>, <span class="number">16.</span>, <span class="number">17.</span>, <span class="number">18.</span>, <span class="number">19.</span>, <span class="number">20.</span>, <span class="number">21.</span>, <span class="number">22.</span>, <span class="number">23.</span>, <span class="number">24.</span>, <span class="number">25.</span>, <span class="number">26.</span>, <span class="number">27.</span>, <span class="number">28.</span>,</span><br><span class="line">        <span class="number">29.</span>, <span class="number">30.</span>])</span><br><span class="line"></span><br><span class="line">b = a.view(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">&gt;&gt;b:tensor([[[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">         [ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>],</span><br><span class="line">         [<span class="number">11.</span>, <span class="number">12.</span>, <span class="number">13.</span>, <span class="number">14.</span>, <span class="number">15.</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">16.</span>, <span class="number">17.</span>, <span class="number">18.</span>, <span class="number">19.</span>, <span class="number">20.</span>],</span><br><span class="line">         [<span class="number">21.</span>, <span class="number">22.</span>, <span class="number">23.</span>, <span class="number">24.</span>, <span class="number">25.</span>],</span><br><span class="line">         [<span class="number">26.</span>, <span class="number">27.</span>, <span class="number">28.</span>, <span class="number">29.</span>, <span class="number">30.</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b.view(b.size(<span class="number">0</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(b.view(b.size(<span class="number">1</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(b.view(b.size(<span class="number">2</span>),-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>b是一个2组3行5列，<br>b.size(0)就是留下2组，后面3行5列拉直成15个数，行成2行15列；<br>b.size(1)就是留下3行，2组5列拉成10个数，行成3行10列；<br>b.size(2)就是留下5列，2组3行拉成6个数，行成5行6列</p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch 数据读取 DataLoader与Dataset 概念</title>
    <url>/2021/09/13/Pytorch%20%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%20DataLoader%E4%B8%8EDataset%20%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>@<a href="Pytorch 数据读取 DataLoader与Dataset 概念">TOC</a></p>
<p>在机器学习中，我们对数据的处理主要分为4个阶段，如下图所示：<br><img src="https://img-blog.csdnimg.cn/b32a357d69624036babcbab934d6ea0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>第一步，收集需要的数据，数据包括原始样本 和 对应标签；</li>
<li>第二步，对数据集进行划分，把数据集划分为 <strong>训练集、验证集和测试集</strong> ；训练集用于训练模型，验证集用于验证模型是否过拟合（也可以理解为用验证集挑选模型的超参数），测试集用于测试模型的性能，测试模型的泛化能力；</li>
<li><p>第三步，从本地读取数据，要按 Mini-batch 分批训练。一起训练，内存不够。使用的方法为 <strong>DataLoader</strong> ，其又分为两个部分：</p>
<ol>
<li><strong>Sample</strong>  用于生成索引，即样本的序号；</li>
<li><strong>Dataset</strong> 是根据索引去读取图片以及对应的标签；</li>
</ol>
</li>
<li><p>第四步，数据预处理，把数据读取进来往往还需要对数据进行一系列的图像预处理，比如说<strong>数据的中心化，标准化，旋转或者翻转</strong>等等。Pytorch 中数据预处理是通过 <strong>transforms</strong> 进行处理的；</p>
</li>
</ol>
<h1 id="DataLoader-和-Dataset"><a href="#DataLoader-和-Dataset" class="headerlink" title="DataLoader 和 Dataset"></a>DataLoader 和 Dataset</h1><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p><img src="https://img-blog.csdnimg.cn/d48e19e8e3a44038a1ee9e38c54ae4dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>torch.utils.data.DataLoader</strong></p>
<p>功能：构建可迭代的数据装载器；<br>dataset: Dataset类，决定数据从哪里读取及如何读取；<br>batchsize：批次样本数量大小；<br>num_works:是否多进程读取数据； 可以设置为几个进程<br>shuffle：每个epoch是否乱序；<br>drop_last：当样本数不能被 batchsize 整除时，是否舍弃最后一批数据；</p>
</blockquote>
<p>Epoch，Iteration，Batchsize的区别</p>
<blockquote>
<p>Epoch：所有训练样本都已输入到模型中，称为一个Epoch<br>Iteration：一批样本输入到模型中，称之为一个Iteration；<br>Batchsize：批次样本数量大小，决定一个Epoch中有多少个Iteration； Iteration = Epoch ➗ Batchsize<br><img src="https://img-blog.csdnimg.cn/9819b23c3821402ca0fe804a641bfd00.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">样本总数：<span class="number">87</span>，Batchsize=<span class="number">8</span> （样本不能被Batchsize整除）</span><br><span class="line"><span class="number">1</span> Epoch = <span class="number">10</span> Iteration，drop_last = <span class="literal">True</span></span><br><span class="line"><span class="number">1</span> Epoch = <span class="number">11</span> Iteration， drop_last = <span class="literal">False</span></span><br></pre></td></tr></table></figure><br>用法例如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_loader = DataLoader(dataset=diabetesdataset,batch_size=<span class="number">32</span>,num_workers=<span class="number">2</span>,shuffle=<span class="literal">True</span>,drop_last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p><img src="https://img-blog.csdnimg.cn/4cb1ec48dac047f3b025dd652a96e11b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>torch.utils.data.Dataset</strong><br>Dataset是用来定义数据从哪里读取，以及如何读取的问题；</p>
<p><font color="red">功能：Dataset抽象类，所有自定义的Dataset需要继承它，并且重写<strong>getitem</strong>()； </font><br><strong> getitem </strong>()：接收一个索引，返回一个样本</p>
</blockquote>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DiabetesDataset 继承 Dataset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiabetesDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filepath</span>):</span></span><br><span class="line">        xy = np.loadtxt(filepath,delimiter=<span class="string">&#x27;,&#x27;</span>,dtype=np.float32)</span><br><span class="line">        <span class="comment"># 一共有几个样本</span></span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">        self.x_train = torch.from_numpy(xy[:, :-<span class="number">1</span>])</span><br><span class="line">        self.y_train = torch.from_numpy(xy[:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 继承Dataset的方法并重写</span></span><br><span class="line">    <span class="comment"># 其实用来帮助找索引位置的  dataset[index]</span></span><br><span class="line">    <span class="comment"># 函数功能是根据index索引去返回数据样本以及标签label</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x_train[index],self.y_train[index]</span><br><span class="line">    <span class="comment"># 函数功能是用来查看数据的长度，也就是 dataset 样本的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br></pre></td></tr></table></figure>
<h2 id="Dataloader的运行机制"><a href="#Dataloader的运行机制" class="headerlink" title="Dataloader的运行机制"></a>Dataloader的运行机制</h2><h3 id="数据读取的三个问题：1、读哪些数据；2、从哪读数据；3、怎么读数据？"><a href="#数据读取的三个问题：1、读哪些数据；2、从哪读数据；3、怎么读数据？" class="headerlink" title="数据读取的三个问题：1、读哪些数据；2、从哪读数据；3、怎么读数据？"></a>数据读取的三个问题：1、读哪些数据；2、从哪读数据；3、怎么读数据？</h3><ol>
<li>从代码中可以发现，index 是从 sampler.py 中输出的，所以读哪些数据是由sampler得到的；</li>
<li>从代码中看，是从Dataset中的 文件地址参数 告诉我们 Pytorch 是从硬盘中的哪一个文件夹获取数据；</li>
<li>从代码中可以发现，Pytorch是从Dataset的getitem()中具体实现的，根据索引去读取数据；</li>
</ol>
<h3 id="DataLoader数据读取流程"><a href="#DataLoader数据读取流程" class="headerlink" title="DataLoader数据读取流程"></a>DataLoader数据读取流程</h3><p><img src="https://img-blog.csdnimg.cn/323718d3de4e415d9ba5af77011315cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>简单描述一下流程图，首先在for循环中去使用DataLoader，进入DataLoader之后是否采用多进程进入DataLoaderlter，进入DataLoaderIter之后会使用sampler去获取Index，拿到索引之后传输到DatasetFetcher，在DatasetFetcher中会调用Dataset，Dataset根据给定的Index，在getitem中从硬盘里面去读取实际的Img和Label，读取了一个batch_size的数据之后，通过一个collate_fn将数据进行整理，整理成batch_Data的形式，接着就可以输入到模型中训练；</p>
<p><strong>读哪些是由Sampler决定的，从哪读是由Dataset决定的，怎么读是由getitem决定的</strong></p>
<h1 id="详细原文转载"><a href="#详细原文转载" class="headerlink" title="详细原文转载"></a>详细原文转载</h1><p><a href="https://blog.csdn.net/qq_37388085/article/details/102663166">https://blog.csdn.net/qq_37388085/article/details/102663166</a></p>
<h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><p>糖尿病案例。 数据读取采用 批处理 DataLoader。<br>理论上 测试集和训练集 都应该分别有一个 DataLoader</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Dataset 是个抽象类，所以其不可以被实例化</span></span><br><span class="line"><span class="comment"># Dataset 可以为其他的子类所继承的</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;../dataset/diabetes.csv&#x27;</span>, delimiter=<span class="string">&quot;,&quot;</span>, dtype=np.float32)</span><br><span class="line"><span class="comment"># (759,9) 759行 9列</span></span><br><span class="line"><span class="comment"># 当测试样本 的 一组数据</span></span><br><span class="line">x_test = torch.from_numpy(xy[-<span class="number">1</span>:, :-<span class="number">1</span>])</span><br><span class="line">y_test = torch.from_numpy(xy[-<span class="number">1</span>:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># DiabetesDataset 继承 Dataset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiabetesDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath</span>):</span></span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)</span><br><span class="line">        <span class="comment"># 一共有几个样本</span></span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">        self.x_train = torch.from_numpy(xy[:, :-<span class="number">1</span>])</span><br><span class="line">        self.y_train = torch.from_numpy(xy[:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 继承Dataset的方法并重写</span></span><br><span class="line">    <span class="comment"># 其实用来帮助找索引位置的  dataset[index]</span></span><br><span class="line">    <span class="comment"># 函数功能是根据index索引去返回数据样本以及标签label</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x_train[index], self.y_train[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数功能是用来查看数据的长度，也就是 dataset 样本的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个类</span></span><br><span class="line">diabetesdataset = DiabetesDataset(<span class="string">&#x27;../dataset/diabetes.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 loader</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    batch_size 就是批次大小</span></span><br><span class="line"><span class="string">    shuffle True的话就表示要打乱数据</span></span><br><span class="line"><span class="string">    num_workers  读取Mni-batch的时候要多线程</span></span><br><span class="line"><span class="string">                2就表示由2个线程进行读取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 返回 （x,y）</span></span><br><span class="line">train_loader = DataLoader(dataset=diabetesdataset, batch_size=<span class="number">32</span>, num_workers=<span class="number">2</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二部 定义模型</span></span><br><span class="line"><span class="comment"># 这个其实有点类似与 神经网络的结构了 每个线性层后面都加了一个sigmoid函数 做了次非线性变换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullLeanerModel</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 定义多层线性模型的结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FullLeanerModel, self).__init__()</span><br><span class="line">        <span class="comment"># 第一个线性转换 将8维转换为6维</span></span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">8</span>, <span class="number">6</span>)</span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">        self.linear3 = torch.nn.Linear(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前馈 运行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 用一个变量比较 简单</span></span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        x = self.sigmoid(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">FullLeanerModel = FullLeanerModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步 定义 损失函数和优化器</span></span><br><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(FullLeanerModel.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步 训练</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"> 前两步 就是正向传播 forward</span></span><br><span class="line"><span class="string">    1. 预测 标签</span></span><br><span class="line"><span class="string">    2. 预测 与 实际 算出损失值</span></span><br><span class="line"><span class="string">    3. 反向传播 backward 优化参数</span></span><br><span class="line"><span class="string">    4. 更新参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 1. Prepare data</span></span><br><span class="line">            inputs, labels = data</span><br><span class="line">            <span class="comment"># 2. Forward</span></span><br><span class="line">            y_pred = FullLeanerModel(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            <span class="comment"># 3. Backward</span></span><br><span class="line">            optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">            loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">            <span class="comment"># 4. Update</span></span><br><span class="line">            optimizer.step()  <span class="comment"># 更新参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第五步 评估模型</span></span><br><span class="line">    <span class="comment"># 输出各层  权重w 和 偏置b</span></span><br><span class="line">    <span class="keyword">for</span> weight, bias <span class="keyword">in</span> FullLeanerModel.state_dict().items():  <span class="comment"># param is weight or bias(Tensor)</span></span><br><span class="line">        <span class="built_in">print</span>(weight, bias)</span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    y_yuce = FullLeanerModel(x_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试样本的预测值为&quot;</span>, y_yuce.data, <span class="string">&quot;实际样本的标签值为&quot;</span>, y_test.data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://img-blog.csdnimg.cn/6df0d9baee164ff69400094abdfff61a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>刘二</tag>
        <tag>Pytorch</tag>
        <tag>DataLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow 代码学习</title>
    <url>/2021/08/22/Tensorflow%20%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>@<a href="Tensorflow 代码学习">TOC</a></p>
<p>机器学习的整体思路为：</p>
<p><img src="https://img-blog.csdnimg.cn/d73975270b58452892a3cd9133defd42.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="用TensorFlow-预测线性模型"><a href="#用TensorFlow-预测线性模型" class="headerlink" title="用TensorFlow 预测线性模型"></a>用TensorFlow 预测线性模型</h1><p>我们以这个做最简单的栗子，题目描述如下图所示：<br><img src="https://img-blog.csdnimg.cn/e862ba592668447dadbb087a5a43ef87.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="问题描述"><br>这就是一个 最简单的数据模型。</p>
<p>首先我们要引入需要的包，这边使用的是 keras API包<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><br>先构建模型，构建的为一层的神经网络，输入只有一个变量x<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = keras.Sequential([keras.layers.Dense(units=<span class="number">1</span>,input_shape=[<span class="number">1</span>])])</span><br></pre></td></tr></table></figure><br>再设置 优化器 和 损失函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;sgd&#x27;</span>,loss=<span class="string">&#x27;mean_squared_error&#x27;</span>)</span><br></pre></td></tr></table></figure><br>准备训练数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xs = np.array([-<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line">ys = np.array([-<span class="number">3.0</span>,-<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">5.0</span>,<span class="number">7.0</span>],dtype=<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><br>训练模型 迭代500次<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(xs,ys,epochs=<span class="number">500</span>)</span><br></pre></td></tr></table></figure><br>使用模型，对一个 测试集 x 进行预测 y 并输出<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.predict([<span class="number">10.0</span>]))</span><br></pre></td></tr></table></figure></p>
<p>总体代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#构建模型</span></span><br><span class="line"><span class="comment">#构建一层的神经网络，并且输入只有1个值</span></span><br><span class="line">model = keras.Sequential([keras.layers.Dense(units=<span class="number">1</span>,input_shape=[<span class="number">1</span>])])</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;sgd&#x27;</span>,loss=<span class="string">&#x27;mean_squared_error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备训练数据</span></span><br><span class="line">xs = np.array([-<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line">ys = np.array([-<span class="number">3.0</span>,-<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">5.0</span>,<span class="number">7.0</span>],dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练模型</span></span><br><span class="line">model.fit(xs,ys,epochs=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用模型，对一个x 进行预测 y</span></span><br><span class="line"><span class="built_in">print</span>(model.predict([<span class="number">10.0</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>结果如下所示：<br><img src="https://img-blog.csdnimg.cn/e82d07bccb7441059c354a3bde71f0e8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="实验结果"><br>预测的结果是 18.977886   按照 正确的数学模型 $y = 2x - 1$ 结果应该是 19 。但深度学习不可能完美预测这个值，只能是近似。</p>
<h2 id="需要理解的几个点"><a href="#需要理解的几个点" class="headerlink" title="需要理解的几个点"></a>需要理解的几个点</h2><blockquote>
<p>Q1 ：请问 <code>model.fit(xs,ys,epochs=500)</code> 的 epochs 500 是什么意思？<br>就是针对同一批数据，利用各类算法（比如梯度下降算法），优化训练的次数，理论上训练次数越多，损失函数越小，准确度越高。</p>
<p>Q2：如何看待这个模型是不是正确的？ 第一，需要看输出的 loss 是不是越来越小 ，accuracy 越来越高。 如果loss<br>不是越来越小，那就说明有问题 第二，你可以看看在测试集 上表现怎么样。</p>
<p>Q3：请问 这个 epochs 越多越好么？ 当然不是，正常来说 模型在测试集上的表现 是不如训练集的。 要选取一个合适的 epochs 值，不然会出现 过拟合的现象。<img src="https://img-blog.csdnimg.cn/56bdd71ef3784049ad7ddd4003317a7e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>  <strong>注意：过拟合 是在测试集上的概念。是训练集上表现不错，但测试集表现不尽人意，叫做过拟合</strong></p>
</blockquote>
<h1 id="用TensorFlow-做全神经网络的图像识别分类"><a href="#用TensorFlow-做全神经网络的图像识别分类" class="headerlink" title="用TensorFlow 做全神经网络的图像识别分类"></a>用TensorFlow 做全神经网络的图像识别分类</h1><p>对 Fashion MNIST 进行图像分类 类别包括<br>0 T-shirt/top(体恤) 1 Trouser(裤子) 2 Pullover(套头衫) 3 Dress(连衣裙) 4 Coat(外套) 5 Sandal(凉鞋) 6 Shirt(衬衫) 7 Sneaker(运动鞋) 8 Bag(袋子) 9 Ankle boot(短靴）<br><img src="https://img-blog.csdnimg.cn/fd0a80f2af654b2d83c71cef332f3e53.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(train_images,train_labels),(test_images,test_labels) = fashion_mnist.load_data()</span><br><span class="line"><span class="comment">#具体值 每一个数字都是灰度值</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以可视化的 查看其中的图片</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建一个全连接的神经网络</span></span><br><span class="line">model = keras.Sequential()</span><br><span class="line"><span class="comment">#输入层</span></span><br><span class="line">model.add(keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)))</span><br><span class="line"><span class="comment">#中间层 128个神经元 激活函数使用relu</span></span><br><span class="line">model.add(keras.layers.Dense(<span class="number">128</span>,activation=tf.nn.relu))</span><br><span class="line"><span class="comment">#输出层 10个神经元 激活函数使用softmax</span></span><br><span class="line">model.add(keras.layers.Dense(<span class="number">10</span>,activation=tf.nn.softmax))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间层  参数共有 100480个</span></span><br><span class="line"><span class="comment">#为 784 × 128 = 100352  还要再加上 每个神经元都有的 bias 100352+128=100480</span></span><br><span class="line"><span class="comment"># 输出层  参数共有 1290个</span></span><br><span class="line"><span class="comment"># 同理 为 128 × 10 + 10 = 1290</span></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># optimizer 优化器   loss：损失函数</span></span><br><span class="line"><span class="comment"># 当标签是除了0，1以外有其他数字的  用sparse_categorical_crossentropy</span></span><br><span class="line"><span class="comment">#为 one-hot  只有一个1 如： [0,0,0,1]用 categorical_crossentropy</span></span><br><span class="line">train_images_scaled = train_images/<span class="number">255</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=tf.optimizers.Adam(),loss=tf.losses.sparse_categorical_crossentropy,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.fit(train_images_scaled,train_labels,epochs=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">test_images_scaled = test_images/<span class="number">255</span></span><br><span class="line"><span class="comment"># # 输出 loss 和 accuracy</span></span><br><span class="line"><span class="comment"># model.evaluate(test_images_scaled,test_labels)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.shape(test_images[<span class="number">0</span>]/<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要满足输入的维度, 并从</span></span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images[<span class="number">0</span>]/<span class="number">255</span>).reshape(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images[<span class="number">0</span>]/<span class="number">255</span>).reshape(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))))</span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先引入 需要的包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br></pre></td></tr></table></figure>
<h2 id="加载Fashion-MNIST数据集"><a href="#加载Fashion-MNIST数据集" class="headerlink" title="加载Fashion MNIST数据集"></a>加载Fashion MNIST数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(train_images,train_labels),(test_images,test_labels) = fashion_mnist.load_data()</span><br></pre></td></tr></table></figure>
<p>可以查看一下 图片内容是什么  是个 28 × 28 的二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#具体值 每一个数字都是灰度值</span></span><br><span class="line"><span class="built_in">print</span>(train_images[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>可以可视化的 查看一下 这张图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以可视化的 查看其中的图片</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.imshow(train_images[<span class="number">0</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c40c76a3833444aa9b950977e09d3a95.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="构造神经元网络模型"><a href="#构造神经元网络模型" class="headerlink" title="构造神经元网络模型"></a>构造神经元网络模型</h2><p>有两种表达方式<br>方式一 ：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建一个全连接的神经网络</span></span><br><span class="line">model = keras.Sequential()</span><br><span class="line"><span class="comment">#输入层</span></span><br><span class="line">model.add(keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)))</span><br><span class="line"><span class="comment">#中间层 128个神经元 激活函数使用relu</span></span><br><span class="line">model.add(keras.layers.Dense(<span class="number">128</span>,activation=tf.nn.relu))</span><br><span class="line"><span class="comment">#输出层 10个神经元 激活函数使用softmax</span></span><br><span class="line">model.add(keras.layers.Dense(<span class="number">10</span>,activation=tf.nn.softmax))</span><br></pre></td></tr></table></figure><br>方式二 ： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model=tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">512</span>, activation=tf.nn.relu),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=tf.nn.softmax)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>可以 用summary 函数  查看各层的信息 包括参数等;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4329a84b31e948dc82268215a010427c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Q： 中间层参数 100480 怎么来的？</strong><br> 中间层  参数共有 100480个  ：为 784 × 128 = 100352  还要再加上 每个神经元都有的 bias 100352+128=100480<br> 输出层  参数共有 1290个 ： 同理 为 128 × 10 + 10 = 1290</p>
</blockquote>
<h2 id="归一化与训练数据"><a href="#归一化与训练数据" class="headerlink" title="归一化与训练数据"></a>归一化与训练数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_images_scaled = train_images/<span class="number">255</span>  <span class="comment">#归一化</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=tf.optimizers.Adam(),loss=tf.losses.sparse_categorical_crossentropy,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.fit(train_images_scaled,train_labels,epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Q：为什么只对 1875个 进行训练？ epoch 5 的 含义是什么？</strong><img src="https://img-blog.csdnimg.cn/152d19d34215451c90b946d3d3bcbf7e.png#pic_center" alt="在这里插入图片描述"><br> 训练没有问题。正在对1875批次（每批次32张图像）而不是1875张图像进行模型训练。     1875 × 32 = 60000张图像</p>
</blockquote>
<h2 id="评估模型-与-测试数据"><a href="#评估模型-与-测试数据" class="headerlink" title="评估模型 与 测试数据"></a>评估模型 与 测试数据</h2><p>评估模型的 loss 和 accuracy 使用 <font color="red">evaluate (测试集全体数据，测试集全体标签) 方法</font><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_images_scaled = test_images/<span class="number">255</span></span><br><span class="line"><span class="comment"># # 输出 loss 和 accuracy</span></span><br><span class="line">model.evaluate(test_images_scaled,test_labels)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>如果要对 测试集图像 进行预测 需要使用<font color="red"> predict (测试集数据) 方法 </font>  输出最后的输出内容为 10维向量（因为一共0-9 10个分类 输出层已经设定好了） 然后再用 numpy的<font color="red">  argmax  </font> 取得向量中 值最大的那个 就是对应 预测的标签。<br><strong>要注意输入的维度 必须要与 输入层设定的维度 保持一致</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要满足输入的维度, 并从</span></span><br><span class="line"><span class="built_in">print</span>(model.predict((test_images[<span class="number">0</span>]/<span class="number">255</span>).reshape(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="comment">#输出预测的标签</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(model.predict((test_images[<span class="number">0</span>]/<span class="number">255</span>).reshape(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>))))</span><br><span class="line"><span class="comment">#对比一下 真实的标签是什么</span></span><br><span class="line"><span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="可以设定自动终止训练"><a href="#可以设定自动终止训练" class="headerlink" title="可以设定自动终止训练"></a>可以设定自动终止训练</h2><p>当损失值 小于 0.4 就终止 批次训练<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myCallback</span>(<span class="params">tf.keras.callbacks.Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self,epoch,logs=&#123;&#125;</span>):</span></span><br><span class="line">        <span class="keyword">if</span>(logs. get(<span class="string">&#x27;loss&#x27;</span>)&lt; <span class="number">0.4</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\ nLoss is low so cancelling training!&quot;</span>)</span><br><span class="line">            self.model.stop_training=<span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(model.predict((test_images[<span class="number">0</span>] / <span class="number">255</span>).reshape(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">            <span class="built_in">print</span>(np.argmax(model.predict((test_images[<span class="number">0</span>] / <span class="number">255</span>).reshape(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))))</span><br><span class="line">            <span class="built_in">print</span>(test_labels[<span class="number">0</span>])</span><br><span class="line">callbacks=myCallback()</span><br><span class="line">mnist=tf.keras.datasets.fashion_mnist</span><br><span class="line">(training_images, training_labels),(test_images, test_labels)=mnist.load_data()</span><br><span class="line">training_images_scaled=training_images/<span class="number">255.0</span></span><br><span class="line">test_images_scaled=test_images/<span class="number">255.0</span></span><br><span class="line">model=tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">512</span>, activation=tf.nn.relu),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>, activation=tf.nn.softmax)</span><br><span class="line">])</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>,loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.fit(training_images_scaled, training_labels, epochs=<span class="number">5</span>, callbacks=[callbacks])</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Tensorflow</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>argparse模块用法实例详解</title>
    <url>/2021/09/22/argparse%E6%A8%A1%E5%9D%97%E7%94%A8%E6%B3%95%E5%AE%9E%E4%BE%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>@<a href="argparse模块用法实例详解">TOC</a></p>
<p>argparse是python的命令行解析的标准模块，内置于python，不需要安装。这个库可以让我们直接在命令行（这边指的是 <strong>python的命令行</strong> 或者是 <strong>Anaconda Prompt</strong>）中就可以向程序中传入参数并让程序运行。<br>其实 argparse 就是一个键值对存储的方式。</p>
<h1 id="栗子一：传入一个参数并输出"><a href="#栗子一：传入一个参数并输出" class="headerlink" title="栗子一：传入一个参数并输出"></a>栗子一：传入一个参数并输出</h1><p>新建一个文件（如叫：arg_study），在该文件夹中新建一个python文件（如：demo.py）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;命令行中传入一个数字&#x27;</span>)</span><br><span class="line"><span class="comment"># type是要传入的参数的数据类型  help是该参数的提示信息</span></span><br><span class="line"><span class="comment"># integers 相当于键</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;传入的数字&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得传入的参数</span></span><br><span class="line"><span class="built_in">print</span>(args)</span><br></pre></td></tr></table></figure>
<h2 id="查看帮助提示"><a href="#查看帮助提示" class="headerlink" title="查看帮助提示"></a>查看帮助提示</h2><p>命令行中输入<code>python demo.py -h</code>或者 <code>python demo.py --help</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python demo.py -h</span><br><span class="line">python demo.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">usage: demo.py [-h] integers</span><br><span class="line"></span><br><span class="line">命令行中传入数字</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  integers    传入的数字</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure>
<h2 id="输入参数并输出"><a href="#输入参数并输出" class="headerlink" title="输入参数并输出"></a>输入参数并输出</h2><p>如输入5<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python demo.py <span class="number">5</span></span><br></pre></td></tr></table></figure><br>得到的结果<code>print(args)</code>为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Namespace(integers=<span class="string">&#x27;5&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>如何获取其中的数据呢？</strong><br><code>Namespace(integers=&#39;5&#39;)</code> 其实是一个类似于python字典的数据类型。<br>我们可以是哟个 <code>arg.参数名</code>  来提取这个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获得integers参数</span></span><br><span class="line"><span class="built_in">print</span>(args.integers)</span><br></pre></td></tr></table></figure>
<h1 id="栗子二：传入多个参数并输出"><a href="#栗子二：传入多个参数并输出" class="headerlink" title="栗子二：传入多个参数并输出"></a>栗子二：传入多个参数并输出</h1><p>nargs是用来说明传入的参数个数，’+’ 表示传入至少一个参数。这时候再重新在命令行中运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;命令行中传入一个数字&#x27;</span>)</span><br><span class="line"><span class="comment"># nargs是用来说明传入的参数个数，&#x27;+&#x27; 表示传入至少一个参数。</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, nargs=<span class="string">&#x27;+&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;传入的数字&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args.integers)</span><br></pre></td></tr></table></figure>
<p>这时候再重新在命令行中运行<code>python demo.py 1 2 3 4</code>得到<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="栗子三：改变数据类型"><a href="#栗子三：改变数据类型" class="headerlink" title="栗子三：改变数据类型"></a>栗子三：改变数据类型</h1><p>add_argument中有type参数可以设置传入参数的数据类型。我们看到代码中有type这个关键词，该关键词可以传入list, str, tuple, set, dict等。例如我们把上面的type=str，改成type=int,这时候我们就可以进行四则运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;命令行中传入一个数字&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;传入的数字&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#对传入的数据进行加总</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(args.integers))</span><br></pre></td></tr></table></figure>
<p>在命令行中输入 <code>python demo.py 1 2 3 4</code>, 运行结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="栗子四：位置参数"><a href="#栗子四：位置参数" class="headerlink" title="栗子四：位置参数"></a>栗子四：位置参数</h1><p>在命令行中传入参数时候，传入的参数的先后顺序不同，运行结果往往会不同，这是因为采用了位置参数,例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;param1&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;姓&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;param2&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;名&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印姓名</span></span><br><span class="line"><span class="built_in">print</span>(args.param1+args.param2)</span><br></pre></td></tr></table></figure>
<p>输出 张三 ：在命令行中分别输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python demo.py 张 三</span><br></pre></td></tr></table></figure>
<h2 id="使用可选参数"><a href="#使用可选参数" class="headerlink" title="使用可选参数"></a>使用可选参数</h2><p>为了在命令行中避免上述位置参数的bug（容易忘了顺序），可以使用可选参数，这个有点像关键词传参，但是需要在关键词前面加—，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--family&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;姓&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;名&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印姓名</span></span><br><span class="line"><span class="built_in">print</span>(args.family+args.name)</span><br></pre></td></tr></table></figure>
<p>在命令行中输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python demo.py --family=张 --name=三</span><br></pre></td></tr></table></figure>
<p>结果为 张三 。<br>可选参数虽然写法比较繁琐，但是增加了命令行中的可读性，不容易因为参数传入顺序导致数据错乱。</p>
<h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><p>add_argument中有一个<strong>default参数</strong>。有的时候需要对某个参数设置默认值，即如果命令行中没有传入该参数的值，程序使用默认值。如果命令行传入该参数，则程序使用传入的值。具体请看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--family&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;张&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;姓&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;三&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;名&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印姓名</span></span><br><span class="line"><span class="built_in">print</span>(args.family+args.name)</span><br></pre></td></tr></table></figure>
<h2 id="设置该参数一定要传入"><a href="#设置该参数一定要传入" class="headerlink" title="设置该参数一定要传入"></a>设置该参数一定要传入</h2><p>add_argument有一个<strong>required参数</strong>可以设置该参数是否必需。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--family&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;姓&#x27;</span>)</span><br><span class="line"><span class="comment"># name 必须传入</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;名&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印姓名</span></span><br><span class="line"><span class="built_in">print</span>(args.family+args.name)</span><br></pre></td></tr></table></figure>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/56922793">argparse模块用法实例详解 【非常的详细】</a><br><a href="https://www.cnblogs.com/yymn/p/8059220.html">python中argparse模块用法实例详解 【比较粗糙】</a></p>
]]></content>
      <categories>
        <category>python工具类</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>分类问题 Classification 案例一：神奇宝贝是水系还是普通系？</title>
    <url>/2021/08/04/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%20Classification%20%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%A5%9E%E5%A5%87%E5%AE%9D%E8%B4%9D%E6%98%AF%E6%B0%B4%E7%B3%BB%E8%BF%98%E6%98%AF%E6%99%AE%E9%80%9A%E7%B3%BB%EF%BC%9F/</url>
    <content><![CDATA[<p>@<a href="分类问题 Classification">TOC</a></p>
<blockquote>
<p>概念：（从概率生成模型到判别模型）<br>概率生成模型：由数据学习联合概率密度分布 <em>P(X,Y)</em> ，然后求出条件概率分布<em>P(Y|X)</em> 作为预测的模型。例如：朴素贝叶斯、隐马尔可夫（em算法）<br>判别模型：由数据直接学习决策函数 <em>Y=f(X)</em> 或者条件概率分布 <em>P(Y|X)</em>  作为预测的模型。例如：k近邻法、感知机、决策树、逻辑回归、线性回归、最大熵模型、支持向量机(SVM)、提升方法、条件随机场（CRF）</p>
</blockquote>
<p><strong>分类问题的思路</strong></p>
<ol>
<li>分类问题及其解决方法的讨论<pre><code> 1. 首先，什么是分类问题？
 2. 接着，分类问题该如何解决呢？
</code></pre></li>
<li>建立概率生成模型的步骤（以朴素贝叶斯分类器为例）<br>step1：求先验概率<br>step2：确定<strong>数据属于哪一个分布，用最大似然估计出分布函数的参数</strong><br>step3：求出后验概率</li>
<li>生成模型解决分类问题的总结以及逻辑回归方法（判别模型）的引出</li>
</ol>
<h1 id="分类问题及其解决方法的讨论"><a href="#分类问题及其解决方法的讨论" class="headerlink" title="分类问题及其解决方法的讨论"></a>分类问题及其解决方法的讨论</h1><h2 id="什么是分类问题？"><a href="#什么是分类问题？" class="headerlink" title="什么是分类问题？"></a>什么是分类问题？</h2><p><img src="https://img-blog.csdnimg.cn/06b2e30dc04b4fa1a871ee3acee382c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>说白了 就是输入一个事务的一些参数特征，通过数学模型，可以得到这个东西是什么。 这也包括二分问题（结果是由两面）与多分问题。</p>
<p>案例：<br>举个栗子，输入一个神奇宝贝，输出：他是属于什么属性的？ <strong>这是一个典型的多分问题，因为属性有好几种啊。</strong><br><img src="https://img-blog.csdnimg.cn/d6dd520c2c1b4c8d9e6396369b5b1f56.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>举个栗子，输入一个神奇宝贝图片，输出：他是可达鸭么？ <strong>这是一个典型的二分问题，因为结果只有两种 是还是不是。</strong><br>举个栗子，假设有两个类别（水系和普通系），每个类别有不同的精灵，现在我抓到一个精灵，那么它是属于水系和普通系的概率分别是多少。这也是个<strong>典型的二分问题</strong>。</p>
<h2 id="如何解决分类问题？"><a href="#如何解决分类问题？" class="headerlink" title="如何解决分类问题？"></a>如何解决分类问题？</h2><h3 id="如何解决二分问题？"><a href="#如何解决二分问题？" class="headerlink" title="如何解决二分问题？"></a>如何解决二分问题？</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>对于二分类问题，定义一个function也就是数学model，<strong>当输出函数值大于0就划分为<em>类别1</em>，否则就为<em>类别2</em>.</strong> <strong>而损失函数定义为在测试数据上误分类的次数</strong>。<img src="https://img-blog.csdnimg.cn/3ee112c779004e5da28ca9878930b369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="那这个function我到底怎么定义呢？"><a href="#那这个function我到底怎么定义呢？" class="headerlink" title="那这个function我到底怎么定义呢？"></a>那这个function我到底怎么定义呢？</h4><p>实际上，可以将其定义为一个<strong>概率模型</strong>。<br>它可以是一个<strong>条件概率模型 <em>P(C1 | X)</em></strong>,当  <strong><em>P(C1 | X) &gt; 0.5</em></strong> ,比如在神奇宝贝二分问题中，我们定义X是这张图片的参数，而C1表示是可达鸭，整个的意思就变为了在这些图片参数的条件下这张图片是可达鸭的概率是多少，概率大于一半，说明确实很有可能就是可达鸭。或者对于第二个栗子，同样的可以规定<strong>条件概率模型 <em>P(C2 | X)</em></strong>，表示在捕捉了一个精灵后，他的参数条件下，是水系的概率是多少？（这边C2表示，捕捉的是水系）</p>
<p>这边我们以栗子2为例，假如我们捕捉了一只神奇宝贝(其实他就是可达鸭)，问他是水系的概率是多少？（理论上其实，他就是水系的，但机器需要通过概率论去推，需要包括以下的概率推导）<br><img src="https://img-blog.csdnimg.cn/dfa3d538674d4dcd8cb32ccbd52ea7f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>如上图所示： 　 x就表示是可达鸭<br>先验概率：这里是P(C1)——训练样本中的精灵是水系的概率;同理P(C2)——训练样本中的精灵是普通系的概率<br>——————————————————————————————————————————————————————————————————<br><em>P(x | C1)</em>：这里是指在水系中是可达鸭的概率<br><em>P(x | C2)</em>：这里是指在普通系中是可达鸭的概率<br>两者可以用<strong>最大似然估计法</strong>求出——————————————————————————————————————————————————————————————————<br>后验概率：这里指抓到的神奇宝贝可达鸭是水系的概率。其用贝叶斯公式算出，公式如上图所示</p>
</blockquote>
<h5 id="求先验概率-P-C1-：训练样本中的精灵是水系的概率"><a href="#求先验概率-P-C1-：训练样本中的精灵是水系的概率" class="headerlink" title="求先验概率 P(C1)：训练样本中的精灵是水系的概率"></a>求先验概率 P(C1)：训练样本中的精灵是水系的概率</h5><p>根据训练样本，分别算出水系和普通系的概率<br><img src="https://img-blog.csdnimg.cn/67108f6b24044efbb896cb62ac2bd2c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="选择概率分布函数，用最大似然估计出分布函数的参数（就是调参）"><a href="#选择概率分布函数，用最大似然估计出分布函数的参数（就是调参）" class="headerlink" title="选择概率分布函数，用最大似然估计出分布函数的参数（就是调参）"></a>选择概率分布函数，用最大似然估计出分布函数的参数（就是调参）</h5><blockquote>
<p>注：</p>
<ul>
<li>当样本数据x取实数值时，采用正太分布(高斯分布)</li>
<li>当每种特征的数值都在0-1内时，采用伯努利分布</li>
<li>当每种特征取值在{1, 2 , 3 , …，K}，采用多项式分布（Multinomial Distribution）</li>
</ul>
</blockquote>
<ol>
<li>　首先，我们目标是求水系样本中的79个精灵中，抓到其中一种神奇宝贝的概率 <strong>P(x | C1)</strong> ，那么这个概率应该是跟精灵的属性有关的。<br>这里我们选择<strong>两种属性（物防和法防）讨论</strong>，此时数据中（x,水系）中的x应该是一个神奇宝贝<strong>向量（[x1物防，x2法防] , 水系）。</strong><br><img src="https://img-blog.csdnimg.cn/4eaa50360e3e4c8492b900326980f697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>2、然后，这里选择正太分布（二维）：也就是说在水系样本中的79个精灵中，抓到其中一种精灵的概率 <em>P( x | C1)</em> 呈正太分布。<br><img src="https://img-blog.csdnimg.cn/86f5ab53fd124a47918b1da54cef4c3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>接着，用最大似然估计法算出分布函数的参数<br>似然函数<em>L</em>：x1,x2…x79同时出现的概率函数。<br>最大似然估计：使似然函数最大时的参数估计。<img src="https://img-blog.csdnimg.cn/8ea6f6da88ba4657999c75674b70170b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>调整的参数<br><img src="https://img-blog.csdnimg.cn/528ff3d528f04fcb8a799f08f3712f4a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h5 id="最后求出后验概率-即P-C1-x-抓到的可达鸭是水系的概率"><a href="#最后求出后验概率-即P-C1-x-抓到的可达鸭是水系的概率" class="headerlink" title="最后求出后验概率 即P(C1 | x): 抓到的可达鸭是水系的概率"></a>最后求出后验概率 即P(C1 | x): 抓到的可达鸭是水系的概率</h5>利用的就是贝叶斯公式。<br>整体每个部分的逻辑可以看下图所示：<img src="https://img-blog.csdnimg.cn/e1d5794c439749dc8e2286bfe3af4ea3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h4 id="效果不好的解决方法"><a href="#效果不好的解决方法" class="headerlink" title="效果不好的解决方法"></a>效果不好的解决方法</h4><strong>实验结果</strong><br><img src="https://img-blog.csdnimg.cn/67640ca1732f41189f0bc43688a71a0e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>分类后，准确率并不高。理论上考虑其他因素，即增加维度可以增大准确率。但效果还是不佳，这该怎么办。<br><img src="https://img-blog.csdnimg.cn/841b72c2ccb243df9a91141dc200370f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>实验结果<br><img src="https://img-blog.csdnimg.cn/0b0ee16c14424df59cf27c80a49a0e1b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h2 id="生成模型解决分类问题的总结以及逻辑回归方法（判别模型）的引出"><a href="#生成模型解决分类问题的总结以及逻辑回归方法（判别模型）的引出" class="headerlink" title="生成模型解决分类问题的总结以及逻辑回归方法（判别模型）的引出"></a>生成模型解决分类问题的总结以及逻辑回归方法（判别模型）的引出</h2><h3 id="回到如何用机器学习的三大步骤解决分类问题："><a href="#回到如何用机器学习的三大步骤解决分类问题：" class="headerlink" title="回到如何用机器学习的三大步骤解决分类问题："></a>回到如何用机器学习的三大步骤解决分类问题：</h3><img src="https://img-blog.csdnimg.cn/b62ddf0753f84cce856bf1991f2d1f81.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="逻辑回归方法（判别模型）的引出"><a href="#逻辑回归方法（判别模型）的引出" class="headerlink" title="逻辑回归方法（判别模型）的引出　"></a>逻辑回归方法（判别模型）的引出　</h3><p><img src="https://img-blog.csdnimg.cn/5b57d3ebf742485eb514f106dba3de5a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="化简推到一下（纯数学）"><a href="#化简推到一下（纯数学）" class="headerlink" title="化简推到一下（纯数学）"></a>化简推到一下（纯数学）</h3><p><img src="https://img-blog.csdnimg.cn/f2323d6bd8474f5891cf63af3f18c47e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e8faa78abb0641adae81388745601c13.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以其实不用考虑，N1，N2，μ1，μ2，∑的值。 直接就是w和b两个参数，这也是为什么之前，我们将∑按权值分配后，图像由线性分类的原因。</p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>机器学习</tag>
        <tag>李宏毅</tag>
      </tags>
  </entry>
  <entry>
    <title>keras 包方法集合</title>
    <url>/2021/08/29/keras%20%E5%8C%85%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>@<a href="keras 包方法集合">TOC</a></p>
<h1 id="keras-util-库-np-utils"><a href="#keras-util-库-np-utils" class="headerlink" title="keras.util 库  np_utils"></a>keras.util 库  np_utils</h1><h2 id="np-utils-to-categorical"><a href="#np-utils-to-categorical" class="headerlink" title="np_utils.to_categorical"></a>np_utils.to_categorical</h2><p>np_utils.to_categorical用于将标签转化为形如(nb_samples, nb_classes)的二值序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_labels_hot = np_utils.to_categorical(train_labels,num_classes=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如将 $[1,2,3,……4]$ 转化成：<br><img src="https://img-blog.csdnimg.cn/379535ca64bc4e5987673ecd12af0c75.png#pic_center" alt="在这里插入图片描述"><br>这样的形态。</p>
]]></content>
      <categories>
        <category>Keras</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要Deep？深而不是宽</title>
    <url>/2021/08/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81Deep%EF%BC%9F%E6%B7%B1%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AE%BD/</url>
    <content><![CDATA[<p>@<a href="为什么要Deep？深而不是宽">TOC</a></p>
<blockquote>
<p><strong>Q：为什么要用要用深度？而不是广度？</strong><br>答：1.因为深度可以用少量的数据，就完成对数据的分类。<br>2.深度，每个层次都是基于上个层次得到的（其实就是学习的过程），我们可以将神经元的数量减少。如果层次很少的话，会导致神经元可能非常多。可以类比逻辑电路。<img src="https://img-blog.csdnimg.cn/3889abe5617e426d91f92e842ba3af83.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center=300×300" alt="在这里插入图片描述"></p>
<h1 id="模组化"><a href="#模组化" class="headerlink" title="模组化"></a>模组化</h1><p>在比较浅层网络与深层网络时，要让“矮胖”的网络和“高瘦”的网络的参数数目相等，这样比较才公平。<br><strong>但即便是在深层网络参数较少的情况下，深层网络也会比浅层网络表现好。</strong><br>这是因为<font color="red"> 深层”其实相当于“模组化”</font>，第一个隐层是最基本的分类器，第二个隐层是用第一个隐层建造的分类器，以此类推。</p>
<p><strong>举个栗子，为什么说深度好！</strong><br>左边第一幅图可以看到，我们需要分四个类，包括长发女，长发男，短发女，短发男。一共四类，其中长发男的数据样本很少，那区分这个类的能力就非常的弱。<br>这个时候，我们就可以先分为两个神经元，一个区分男女，一个区分长发短发，这样中间加一层，可以使得数据样本少的类 鉴定的效果更好。<br><img src="https://img-blog.csdnimg.cn/dc3ef77e42724c1ebbcb6d0d29067206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>对于分类一个图像来说，深度使得模块化。</strong><img src="https://img-blog.csdnimg.cn/81cf2b79b06440e789ad2a03937c7e2e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center=300×300" alt="在这里插入图片描述"></p>
</blockquote>
<h1 id="类比逻辑电路"><a href="#类比逻辑电路" class="headerlink" title="类比逻辑电路"></a>类比逻辑电路</h1><p><img src="https://img-blog.csdnimg.cn/8635e890e73f4834900ea683446b9f0a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center=300×300" alt="在这里插入图片描述"><br>浅层网络确实可以表示任意函数，但是使用深层结构更有效率。<br><strong>好比逻辑门电路，用两层逻辑门就可以实现任何布尔函数，但是用多层结构更简单、需要的逻辑门更少。</strong><br><img src="https://img-blog.csdnimg.cn/3889abe5617e426d91f92e842ba3af83.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center=300×300" alt="在这里插入图片描述"></p>
<p>神经网络也是如此，单隐层网络可以表示任何连续函数，但是多层结构表示起来更简单、需要的神经元更少，<strong>所以比较不容易overfitting，或只需较少的data。</strong>而且，深层结构可以比较有效率地使用data。</p>
<h1 id="类比图形"><a href="#类比图形" class="headerlink" title="类比图形"></a>类比图形</h1><p><img src="https://img-blog.csdnimg.cn/e4e96dfdc69b4c47b96640efa2f70be8.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center=300×300" alt="在这里插入图片描述"><br>1层hidden layer与3层hidden layer（相同数目的参数），3层的效果更好。<br>但理论上，3层可达到的效果，1层也能达到：要在1层learn的时候，target从真实label改为3层的output，这样1层的结果会接近3层的结果。</p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>各类 损失函数 详解与选择</title>
    <url>/2021/08/23/%E5%90%84%E7%B1%BB%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>@<a href="各类 损失函数 详解与选择">TOC</a></p>
<h1 id="mean-squared-error-均方误差"><a href="#mean-squared-error-均方误差" class="headerlink" title="mean_squared_error 均方误差"></a>mean_squared_error 均方误差</h1><p><img src="https://img-blog.csdnimg.cn/a55e390e62dd4e0b8bd1c9ff5cfb7826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>损失函数与激活函数</category>
      </categories>
      <tags>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>各类 优化器(调参工具) 详解与选择</title>
    <url>/2021/08/28/%E5%90%84%E7%B1%BB%20%E4%BC%98%E5%8C%96%E5%99%A8(%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7)%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>@<a href="各类 优化器 详解与选择">TOC</a></p>
<h1 id="sgd"><a href="#sgd" class="headerlink" title="sgd"></a>sgd</h1><h1 id="adam"><a href="#adam" class="headerlink" title="adam"></a>adam</h1>]]></content>
      <categories>
        <category>优化器</category>
      </categories>
      <tags>
        <tag>优化器</tag>
      </tags>
  </entry>
  <entry>
    <title>同济子豪兄 之 yolov1 详解</title>
    <url>/2021/09/26/%E5%90%8C%E6%B5%8E%E5%AD%90%E8%B1%AA%E5%85%84%20%E4%B9%8B%20yolov1%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>@<a href="同济子豪兄 之 yolov1 详解">TOC</a><br>yolov1 的主旨是 You Only Look Once：Unified，Real-Time Object Detection。<br>yolo 是一个典型的 将 目标检测 转化为  回归问题的方法。yolo与其他网络不同在，他的测试与训练方法不同，所以接下来我们主要 分预测以及训练两个阶段去介绍yolov1。 包括 预测阶段（以及后处理），训练阶段来讲。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6d831d5df7aff4ccf3dd13027b9fdbbb.png#pic_center" alt="训练阶段以及测试阶段"><br>将输入的图片 划分为 S×S个 grid cell<br><strong>训练阶段：</strong></p>
<ul>
<li>将标签 Ground truth 的 框 中心点落在哪个grid cell 中 就由 哪个 grid cell 来预测这个物体对象</li>
<li>每个 grid cell 可以 预测 B 个 bounding box， 与 Ground truth 的 框 IoU 最大的<br>bounding box 负责预测 这个物体对象。</li>
<li>每个 grid cell 只能 检测一个物体</li>
<li>包含和不包含 ground truth 标签的 grid cell 和 bounding box 都要依照损失函数 分别处理</li>
</ul>
<p><strong>测试阶段：</strong></p>
<ul>
<li>直接获得 S × S ×（S×B+C）向量 进行 NMS 后处理 得到目标检测结果。</li>
</ul>
<h1 id="目标检测的基础知识"><a href="#目标检测的基础知识" class="headerlink" title="目标检测的基础知识"></a>目标检测的基础知识</h1><h2 id="目标检测是什么？"><a href="#目标检测是什么？" class="headerlink" title="目标检测是什么？"></a>目标检测是什么？</h2><p>在计算机视觉领域，图像任务主要分为：图像分类，图像检测 和 图像分割（语义分割和实例分割）等<br>语义分割和实例分割的区别在于：语义分割是我对每个像素分类，我不管这个像素是属于哪几个物体的，只管他是属于什么类别的（也就是我只分类，同一个类别的不同实例不区分）；而实例分割是要把同一个类别的不同实例给区分开来</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/35b53c4cd1da18a70dca91d65e748d1b.png#pic_center" alt="任务区别图1"><br><img src="https://img-blog.csdnimg.cn/img_convert/636fe4401f3cfa7a5b8fdb3909646d63.png#pic_center" alt="任务区别图2"><br><img src="https://img-blog.csdnimg.cn/img_convert/56310ef740a07f9b2cf502c8a41f28eb.png#pic_center" alt="任务区别图3"></p>
<h2 id="目标检测主流的数据集来源"><a href="#目标检测主流的数据集来源" class="headerlink" title="目标检测主流的数据集来源"></a>目标检测主流的数据集来源</h2><p>yolo 是在  PASCAL-2007 和 MS-COCO上做的评测<br><img src="https://img-blog.csdnimg.cn/img_convert/0a3e3c44de4fb73523bc7d2026481089.png#pic_center" alt="主流目标检测数据集来源"></p>
<h2 id="目标检测的发展"><a href="#目标检测的发展" class="headerlink" title="目标检测的发展"></a>目标检测的发展</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8199110e14455de8cd7de50658a142f6.png#pic_center" alt="目标检测的发展"><br>目前这个主要的流派由两种，上面是单阶段模型 yolo 系列  下面是两阶段模型 RCNN系列。</p>
<ul>
<li>两阶段就是先从图像中提取若干候选框，再逐一的对这些候选框进行分类、甄别以及调整它们的坐标最后得出结果。</li>
<li>单阶段就是 我不提取候选框，我直接把全图喂到算法里面，能直接输出出来目标检测的结果。是一个统一的端到端的系统</li>
</ul>
<p>对于 RCNN系列的话，他比较慢但是 正确率比较高</p>
<ul>
<li>R-CNN 使用region proposal先提取候选框，再使用卷积神经网络逐一的对每个候选款进行甄别，对 bouning box 位置调整和回归和分类</li>
<li>Fast R -CNN 是把所有的图片用卷积神经网络过一遍，在生成的feature map上找候选框 投影到 feature map 上面，再进行甄别</li>
<li>Faster R-CNN 使用了 RPN 网络，也就是找候选框这个事情由 RPN 这个专业户干了</li>
</ul>
<p>对于 yolo系列的话，他的优势在于速度，正确率相比没有那么高<font color="blue">（待补充）</font></p>
<ul>
<li>yolov1 的缺点在于，单个grid cell 只能识别一种类别。识别小目标或者密集目标 能力不足，例如羊群、人群这种。</li>
<li>yolov2 是在 yolov1 的基础上 加了<strong>Batch Normalization</strong>、High Resolution Classifer、<strong>Anchor</strong>、Dimension Cluster、Direct location prediction、Fine-Graind Features、Muti-Scale Training</li>
<li>yolov3</li>
<li>yolov4 从v4开始 作者变了，前面的大作因为感慨yolo技术被用来干坏事而退出了计算机视觉领域。</li>
<li>yolov5</li>
</ul>
<h1 id="yolo-v1-的-预测阶段"><a href="#yolo-v1-的-预测阶段" class="headerlink" title="yolo v1 的 预测阶段"></a>yolo v1 的 预测阶段</h1><h2 id="yolo-v1-网络架构"><a href="#yolo-v1-网络架构" class="headerlink" title="yolo v1 网络架构"></a>yolo v1 网络架构</h2><p>输出的 7×7×30 这个tensor 就是我们预测阶段所需要的<br><img src="https://img-blog.csdnimg.cn/img_convert/38e7f43fea47802cb9d2b7564377db4b.png#pic_center" alt="yolov1 图像处理的网络架构"><br>我们来分析一下网络结构并写出各层次的padding。<br>计算公式为</p>
<script type="math/tex; mode=display">outputsize =\lfloor {\frac{inputsize + 2padding -filtersize}{步长}}\rfloor +1</script><p><img src="https://img-blog.csdnimg.cn/img_convert/28059cdcee997d3230d56657217dce43.png#pic_center" alt="算出padding"><br>之后最后两个全连接层。<br>他是怎么转为 4096个输入的呢。也就是输入的为7×7×1024 我们全连接层输出的 是 4096 的一维向量。我们采用 4096个 7×7×1024 的卷积核，然后 变成 1×1×4096  再使用降维 变为 一维的4096。<br>然后我们再将这个 reshap 成 4096×1的列向量 中间的 参数矩阵为 4096×1470  根据 线性回归的公式：</p>
<script type="math/tex; mode=display">y=w^{T}x</script><p>可以计算得到 1470×4096×4096×1 = 1470×1  然后我们在 reshape 一下变成三维 （7,7,30）</p>
<h2 id="yolo-v1-预测阶段-内容详解"><a href="#yolo-v1-预测阶段-内容详解" class="headerlink" title="yolo v1 预测阶段 内容详解"></a>yolo v1 预测阶段 内容详解</h2><blockquote>
<p>Q：为什么 输出的是 7×7×30 呢？<br><img src="https://img-blog.csdnimg.cn/img_convert/c466565d19154b1bc714cafe0d4614c6.png#pic_center" alt="yolo v1核心内容"><br>因为在 yolo v1 中图像被划分成了<strong>7×7的网格</strong>。每个格子叫做 grid cell ，也就是由49个grid cell。</p>
</blockquote>
<p>这里的 每个 grid cell 又能预测 B个 bounding box （也就是预测框） yolo v1中 B=2 也就是每个 grid cell 可以预测 2个 bounding box。这两个预测框可能很大也可能很小 也就是这个框是啥样的不一定。（<strong>注意这个框是由前面的网络结构得到的 就是这么神奇</strong>）。这个框覆盖其他的grid cell 是很正常的，只要这个 bounding box 的中心点 是落在这个 grid cell 里就ok。</p>
<p>每个grid cell 预测 B 个 bounding box。 在yolo v1 的实验中 B=2，也就是 每个 grid cell 由 2 个 bounding box。<br>bounding box 的由 5个 数值来表示 （x,y,h,w,c）</p>
<ul>
<li>x，y 表示中心点的位置</li>
<li>h，w表示这个 bounding box 的 高 和 宽</li>
<li>c 表示这个 bounding box 框的置信度。在图像中 一般用 框线的粗细来表示置信度的大小。<strong>置信度的意思是，这个bounding box 对自己含有物体对象的自信程度。（注意是识别的对象，而不是具体的类别）</strong></li>
</ul>
<p>在yolo v1的实验中，因为由 49 个 grid cell，所以 有 98 个 bounding box 如下图所示（粗细表示置信度高低）<br><img src="https://img-blog.csdnimg.cn/img_convert/049d6ea03b1129753555d38bdb1ed2e4.png#pic_center" alt="98个bounding box"></p>
<h2 id="grid-cell-输出所有类别的条件概率"><a href="#grid-cell-输出所有类别的条件概率" class="headerlink" title="grid cell 输出所有类别的条件概率"></a>grid cell 输出所有类别的条件概率</h2><p>每个 grid cell 还能生成所有类别的 <strong>条件概率</strong>，并且选择最高的一个概率表明，预测的是这个类别。这也就是 yolo v1 最大的弊端，每个 grid cell 只能预测一个类别，那一个 49个cell 最大只能预测 49个类别；并且如果类别对象很密集，一个 grid cell 中有多个不同的小对象的话，识别效果会很差。</p>
<p><font color="red">注意这里的概率是 条件概率 比如 p(cat|object) 是在有<strong>存在类别对象的情况下 是 猫的概率</strong>。</font><br>下图可以表示 49个cell 预测的类别情况（也就是各cell 选择的最高类别的 条件概率）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3dd9cb0d2cf0e1391ba7688e445d4886.png#pic_center" alt="每个grid cell 选择的最高类别的 条件概率"></p>
<h2 id="7×7×30-这个30是怎么来的呢"><a href="#7×7×30-这个30是怎么来的呢" class="headerlink" title="7×7×30 这个30是怎么来的呢"></a>7×7×30 这个30是怎么来的呢</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/c8cab634a723eaab685cf39f70e88511.png#pic_center" alt="7×7×30 这个30是怎么来的呢"><br>每个grid cell 有 2个bounding box。1个bounding box 中有5个数值 那就是10个数值，然后 yolo v1 预测了20个类别的物体，所以有20个类别的概率 所以是 30个输出。然后有 7×7个 grid cell 所以 输出的 是 7×7×30 的 tensor。</p>
<blockquote>
<p>Q：<strong>那 类别真正的概率怎么算出来呢？</strong><br>只有将 对应的 bounding box 置信度 × 这个grid cell 的类别条件概率才是 这个类别真正的概率值</p>
</blockquote>
<p> $全概率 = bounding box 置信度 × $</p>
<p>将这个grid cell 的两个 bouding box 都赋予 这个grid cell 选择的最高类别。再进行一系列的后处理（指的是 置信度很低的先给过滤掉，非极大值抑制（NMS））选择最佳 bounding box</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c928f7b0c5670984b7b21aaeabd0bd5c.png#pic_center" alt=""><br>7×7×30这个tensor中包含了 98个bounding box 49个grid cell 每个grid cell 的类别 bounding box的 5个数值   进行解析和后处理 最后得到了结果<br>以上我们说的都是 预测阶段 也就是 参数啥的已经调好了 我只要跑一跑 拿到个结果。</p>
<h1 id="预测阶段-的后处理部分"><a href="#预测阶段-的后处理部分" class="headerlink" title="预测阶段 的后处理部分"></a>预测阶段 的后处理部分</h1><p>一个 grid cell 可以得到 下图右侧中两列向量。每个向量 都表示 这个 grid cell 在其一个 bounding box 中 20个类别的全概率。<br>一个98个bounding box。 <strong>这个是由 每个bounding box 的置信度 乘以 tensor 中 输出的 该 grid cell 对20个类别的条件概率得到的。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/89ba9c3732e7722b15c9eebf175f7634.png#pic_center" alt="grid cell 输出其两个预测框的 20个类别的全概率"><br>现在我们得到如下的框框图像，一共有 98个 bounding box。不同颜色表示不同类别。（因为每个 grid cell 只会预测概率最高的那个类别 比如狗是黄色的 那他的两个bounding box 都是黄色的）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0b04396864fbcb9abb88839b0ca4cfce.png#pic_center" alt="需要后处理的 98个 预测框"><br>每个 bounding box  把他对20个分类的条件概率拿出来，乘以对应的置信度。得到20个分类的全概率向量。<br><img src="https://img-blog.csdnimg.cn/img_convert/62f2eb8e8436081525012232736fc888.png#pic_center" alt="拿到20个分类的条件概率"><br>我们把刚才 每个bounding box 输出的 20个分类的全概率向量拿出来。 假如第一行的是对狗的预测。我们要把98个列向量按狗的概率，从大到小排列。<font color="red"><strong>（他的意思就是 我按排列之后 每一个类别都按 NMS一遍  ）</strong> </font>整个的过程如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2afbebe5fbb7b772cf1f63a7f2e25127.png#pic_center" alt="如何使用NMS方法"></p>
<h2 id="NMS方法详解"><a href="#NMS方法详解" class="headerlink" title="NMS方法详解"></a>NMS方法详解</h2><p>假如 我们比较下图中 98个bounding box 狗这一行 的 前两个值， 也就是左边橙色和绿色连的bounding box ，我们计算一下 IoU  这边要预先设定一个门槛值（他这里是0.5，越小排异性越高），如果IoU超过0.5的话，表明这两个框预测的都是同一类别（这里也就是狗）。这样的话，保留值高的那个，低的那个全概率改为0，把这个bounding box 干掉。<br><img src="https://img-blog.csdnimg.cn/img_convert/9b4e674106e87245c29a5712b5c82de8.png#pic_center" alt="NMS 图1"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9cc8d08e234cc4c22826f68150b8ea98.png#pic_center" alt="结果把这个位置清0"><br>下图这个就是 IoU不到门槛值  说明两个 bounding box 预测的不是一个类别 两者都保留不动。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dce95176ac7ab31983097137667b0f1c.png#pic_center" alt="IoU不到门槛值的情况"><br>然后第一个和所有比完了 再从剩下里面最高的 再比。<br>最后我们可以得到一个稀疏的 98 列，选择有值的 列向量，找到其最大的概率的那一项，返回他的索引（也就是类别），以及他对于的概率值。然后在图片上打上对应的 bounding box。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/784a171229a817e12ba83f6e69be073a.png#pic_center" alt="然后第一个和所有比完了 再从剩下里面最高的 再比"><br><strong>注意奥 我们讲的是只是对预测阶段 需要 。在训练阶段是不需要NMS的。</strong> 因为每个框不管他是要被打入冷宫的还是负责预测物体的有用框 都要在损失函数中占据一席之地。里面的所有框的一举一动都会影响损失函数。所以不能随随便便在训练阶段 用NMS 把没用的框去掉，或者把概率抹零。</p>
<h1 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h1><p>首先奥这是个典型的 监督学习。所以我们是需要 ground truth。比如下图就是一个正确的标签：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9940687bd6b6c2f7cf5235fb14ba8369.png#pic_center" alt="正确的标签"></p>
<blockquote>
<p><font color="red">这里有个问题 每个grid cell 都有两个 bounding box 谁来 拟合 ground truth 做损失函数呢? </font><br>答：看谁和 ground truth的 IoU 更大。比如这里 就是由 外面这个大框 负责拟合 ground truth，让其尽量的逼近 调整成 ground truth 的样子，那么另外一个框就被打入冷宫了 ，它什么都不用做，尽量让他置信度降为0。<br><img src="https://img-blog.csdnimg.cn/img_convert/cfafbaa050469d1ce71b47affcdc3341.png#pic_center" alt="每个grid cell 有两个 bounding box"><br><img src="https://img-blog.csdnimg.cn/img_convert/ec519587d6180d710944340ab1713270.png#pic_center" alt="看看选择哪个 bounding box"></p>
</blockquote>
<p><strong>如果没有ground truth 中心点落下 的 grid cell 的两个 bounding box 全部打入冷宫。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3c083d8df79294e99cf3e223e49ffd9d.png#pic_center" alt="没有ground truth 中心点落下 的 grid cell"></p>
<h2 id="yolo-v1-的-损失函数-待补充与推理"><a href="#yolo-v1-的-损失函数-待补充与推理" class="headerlink" title="yolo v1 的 损失函数 (待补充与推理)"></a>yolo v1 的 损失函数 (待补充与推理)</h2><p>下面介绍一下 yolov1损失函数误差。主要分为5个部分。<br><img src="https://img-blog.csdnimg.cn/img_convert/b4f54e2a69268e05525cd063dbb06b93.png#pic_center" alt="yolo v1 的 损失函数"><br>现在有一个问题就是 我损失函数要去调整的参数到底是谁。是为了让选中的那个bounding box 框更加拟合 ground truth ，那我们要调整的岂不是 网络结构输出的东西，那也就是改的网络了？所以到底是在调整什么呢？</p>
<p>没毛病 就是返回框的参数 然后反向传播调整网络的参数</p>
<h1 id="总结yolov1的缺点"><a href="#总结yolov1的缺点" class="headerlink" title="总结yolov1的缺点"></a>总结yolov1的缺点</h1><ol>
<li>mAP相比 R-CNN 系列比较低</li>
<li>定位性能比较差，定位错误占总错误的比例很大</li>
<li>Recall比较低，就是把全部目标全部检测出来的能力比较差</li>
<li>检测密集和小目标的能力比较差</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://www.bilibili.com/video/BV15w411Z7LG?p=1">牛逼的子豪兄 yolo v1详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46309428">yolo 损失函数的详解</a></li>
<li><a href="https://blog.csdn.net/weixin_44523062/article/details/104717799">yolo 置信度的概念</a></li>
</ul>
]]></content>
      <categories>
        <category>Yolo</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title>各类 激活函数 详解与选择</title>
    <url>/2021/08/24/%E5%90%84%E7%B1%BB%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>@<a href="各类 激活函数 详解与选择">TOC</a></p>
<h1 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h1><h1 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h1><h1 id="sigmiod"><a href="#sigmiod" class="headerlink" title="sigmiod"></a>sigmiod</h1><h1 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h1>]]></content>
      <categories>
        <category>损失函数与激活函数</category>
      </categories>
      <tags>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集加载的各种方式方法</title>
    <url>/2021/09/17/%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>@<a href="数据集加载的各种方式方法">TOC</a></p>
<h1 id="np-loadtxt-读取本地-csv-文件"><a href="#np-loadtxt-读取本地-csv-文件" class="headerlink" title="np.loadtxt 读取本地 csv 文件"></a>np.loadtxt 读取本地 csv 文件</h1><p>读入本地 csv 文件内容。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    numpy读取本地文件</span></span><br><span class="line"><span class="string">    delimiter 数据的分割号</span></span><br><span class="line"><span class="string">    dtype 读取数据类型  一般机器学习类的都是float32 </span></span><br><span class="line"><span class="string">    因为显卡一般他内核里面是按32位工作的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">xy = np.loadtxt(<span class="string">&#x27;./dataset/diabetes.csv&#x27;</span>,delimiter=<span class="string">&quot;,&quot;</span>,dtype=np.float32)</span><br></pre></td></tr></table></figure>
<p>用Pytorch使用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">x_train = torch.from_numpy(xy[:-<span class="number">1</span>,:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_train.shape)</span><br><span class="line">y_train = torch.from_numpy(xy[:-<span class="number">1</span>,[-<span class="number">1</span>]])</span><br></pre></td></tr></table></figure></p>
<h1 id="批次读取-本地-csv-文件"><a href="#批次读取-本地-csv-文件" class="headerlink" title="批次读取 本地 csv 文件"></a>批次读取 本地 csv 文件</h1><p>使用 DataLoader+Dataset </p>
<h2 id="Step1：引入包"><a href="#Step1：引入包" class="headerlink" title="Step1：引入包"></a>Step1：引入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dataset 是个抽象类，所以其不可以被实例化</span></span><br><span class="line"><span class="comment"># Dataset 可以为其他的子类所继承的</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure>
<h2 id="Step2：定义一个自己的Dataset类-并继承原有的抽象类Dataset"><a href="#Step2：定义一个自己的Dataset类-并继承原有的抽象类Dataset" class="headerlink" title="Step2：定义一个自己的Dataset类 并继承原有的抽象类Dataset"></a>Step2：定义一个自己的Dataset类 并继承原有的抽象类Dataset</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DiabetesDataset 继承 Dataset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiabetesDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filepath</span>):</span></span><br><span class="line">        xy = np.loadtxt(filepath, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=np.float32)</span><br><span class="line">        <span class="comment"># 一共有几个样本</span></span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># numpy 转 张量  最后一组样本我们当测试样本吧  其余的当训练样本</span></span><br><span class="line">        self.x_train = torch.from_numpy(xy[:, :-<span class="number">1</span>])</span><br><span class="line">        self.y_train = torch.from_numpy(xy[:, [-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 继承Dataset的方法并重写</span></span><br><span class="line">    <span class="comment"># 其实用来帮助找索引位置的  dataset[index]</span></span><br><span class="line">    <span class="comment"># 函数功能是根据index索引去返回数据样本以及标签label</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.x_train[index], self.y_train[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数功能是用来查看数据的长度，也就是 dataset 样本的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化这个类</span></span><br><span class="line">diabetesdataset = DiabetesDataset(<span class="string">&#x27;../dataset/diabetes.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Step3：使用DataLoader"><a href="#Step3：使用DataLoader" class="headerlink" title="Step3：使用DataLoader"></a>Step3：使用DataLoader</h2><p>其返回的是 对应索引的数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个 loader</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    batch_size 就是批次大小</span></span><br><span class="line"><span class="string">    shuffle True的话就表示要打乱数据</span></span><br><span class="line"><span class="string">    num_workers  读取Mni-batch的时候要多进程</span></span><br><span class="line"><span class="string">                2就表示由2个进程进行读取</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 返回 （x,y）</span></span><br><span class="line">train_loader = DataLoader(dataset=diabetesdataset, batch_size=<span class="number">32</span>, num_workers=<span class="number">2</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Step4：用迭代的方式拿到数据"><a href="#Step4：用迭代的方式拿到数据" class="headerlink" title="Step4：用迭代的方式拿到数据"></a>Step4：用迭代的方式拿到数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            <span class="comment"># 1. Prepare data</span></span><br><span class="line">            inputs, labels = data</span><br><span class="line">            <span class="comment"># 2. Forward</span></span><br><span class="line">            y_pred = FullLeanerModel(inputs)</span><br><span class="line">            loss = criterion(y_pred, labels)</span><br><span class="line">            <span class="comment"># 3. Backward</span></span><br><span class="line">            optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">            loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">            <span class="comment"># 4. Update</span></span><br><span class="line">            optimizer.step()  <span class="comment"># 更新参数</span></span><br></pre></td></tr></table></figure>
<h1 id="用-pandas-的-read-csv-方法"><a href="#用-pandas-的-read-csv-方法" class="headerlink" title="用 pandas 的 read_csv 方法"></a>用 pandas 的 read_csv 方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_filepath = <span class="string">r&quot;../dataset/Titanic/train.csv&quot;</span></span><br><span class="line">train_data = pd.read_csv(train_filepath)</span><br></pre></td></tr></table></figure>
<p>pandas需要使用 DataFrame 的形式<br><img src="https://img-blog.csdnimg.cn/cb5ee55c852d4a66a120888969fdb170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>可用 pandas.DataFrame()来转换成 DataFrame 格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否幸存 客舱等级 性别 年龄 旁系亲友数目  直系亲友数目 票价  上船港口编号</span></span><br><span class="line">cols=[<span class="string">&#x27;Survived&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Embarked&#x27;</span>]</span><br><span class="line"><span class="comment"># colums表示列名  index 表示行名   选择需要的列</span></span><br><span class="line">train_data = pd.DataFrame(train_data, columns=cols)</span><br></pre></td></tr></table></figure>
<p>可以用 ndarray 将DataFrame 转为 普通的numpy 读取出来。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#x27;Survived&#x27;</span></span><br><span class="line">label = ndarray[:,:<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 除了&#x27;Survived&#x27; 其他全部特征</span></span><br><span class="line">features = ndarray[:,<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据集加载</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降算法 进阶</title>
    <url>/2021/08/04/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%20%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>@<a href="梯度算法 进阶">TOC</a></p>
<h1 id="回顾梯度算法"><a href="#回顾梯度算法" class="headerlink" title="回顾梯度算法"></a>回顾梯度算法</h1><p><strong>是一种迭代的算法，每看一个参数都会更新。</strong><br><img src="https://img-blog.csdnimg.cn/eee493cfe8f24755a2aa3cfd41f486f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/62ccf5ddd84348308c79a70233b0da19.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="学习率η（Learning-Rate）"><a href="#学习率η（Learning-Rate）" class="headerlink" title="学习率η（Learning Rate）"></a>学习率η（Learning Rate）</h1><h2 id="自定义的学习率对参数选择的影响"><a href="#自定义的学习率对参数选择的影响" class="headerlink" title="自定义的学习率对参数选择的影响"></a>自定义的学习率对参数选择的影响</h2><p><img src="https://img-blog.csdnimg.cn/6c39ce49d85048098ac7303a552bc184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>学习率需要选取合适的值，过小会导致模型调参的速度太慢，但过大会导致错失掉了最佳参数点</strong></p>
<h2 id="如何调整学习率η？"><a href="#如何调整学习率η？" class="headerlink" title="如何调整学习率η？"></a>如何调整学习率η？</h2><ol>
<li><p>在最开始的时候，随机点离目标点很远，我们一般会选取一个比较大的学习率；当做了几期后，我们离目标点很近了，所以我们会减小学习率 缩减为 如下图所示的公式<img src="https://img-blog.csdnimg.cn/b9bc45580c004a6cbb708595125b1a1a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>不同的参数应该设置不同的学习率</strong></p>
</li>
</ol>
<p>下面是常用的 调整学习率的方法：</p>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>Adagrad是解决不同参数应该使用不同的更新速率的问题。<strong>Adagrad自适应地为各个参数分配不同学习率的算法。</strong></p>
<blockquote>
<p><strong>其原理为：</strong><img src="https://img-blog.csdnimg.cn/4423c0afa60f462cb444f37cd1307576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>里面比较核心的部分在 每次σ的取值。<strong>每次σ规定为之前所有<em>g</em>平方对应的之和的均方根</strong>。例如下图所示：其中 <em>g</em> 是每次的偏导值<img src="https://img-blog.csdnimg.cn/82780afd2b0347ad8505db41024b9f7d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合之前说的 <em>η</em> 值的变化 可以得到如下的公式推导：<img src="https://img-blog.csdnimg.cn/cf79f34d94b44c72abdd283ebb0f3431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>提问:</strong>    发现一个现象，本来应该是随着gradient的增大，我们的学习率是希望增大的，也就是图中的g上标t；但是与此同时随着gradient的增大，我们的分母是在逐渐增大，也就对整体学习率是减少的，这是为什么呢？<img src="https://img-blog.csdnimg.cn/64154f52e91f4486be92171800f09815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这是因为随着我们更新次数的增大，我们是希望我们的学习率越来越慢。因为我们认为在学习率的最初阶段，我们是距离损失函数最优解很远的，随着更新的次数的增多，<strong>我们认为越来越接近最优解，于是学习速率也随之变慢。</strong>  为什么化简之后是如上这个式子呢，其在图像上的意义是 一阶导数比上二阶数的值。如下图所示：<img src="https://img-blog.csdnimg.cn/90fda3afedce4958a877451546c006e2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="Stochastic-Gradient-Descent（SGD随机梯度下降法）-？？？"><a href="#Stochastic-Gradient-Descent（SGD随机梯度下降法）-？？？" class="headerlink" title="Stochastic Gradient Descent（SGD随机梯度下降法） ？？？"></a>Stochastic Gradient Descent（SGD随机梯度下降法） ？？？</h3><p>其和 普通的梯度下降算法区别在。普通遍历在求和的时候需要浪费大量时间，进而去掉求和产生了随机梯度下降算法。<img src="https://img-blog.csdnimg.cn/e92e87942f4443cbac50e52369c68151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>和下图看到的一样：<br><img src="https://img-blog.csdnimg.cn/76673f0f26614df6a9ac37311fe015b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p> 只是要注意一下标准的梯度下降和随机梯度下降的区别：</p>
<ol>
<li><p>标准下降时在权值更新前汇总所有样例得到的标准梯度，随机下降则是通过考察每次训练实例来更新（<strong>就是随机选择一些按顺序的后续样本点来，而不是全体数据</strong>）。<img src="https://img-blog.csdnimg.cn/32da14cad9bf4a2ba439745929b7ec11.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>对于步长 <em>η</em> 的取值，标准梯度下降的 <em>η</em> 比随机梯度下降的大。因为标准梯度下降的是使用准确的梯度，理直气壮地走，随机梯度下降<strong>使用的是近似的梯度</strong>，就得小心翼翼地走，怕一不小心误入歧途南辕北辙了。</p>
</li>
<li>当损失函数有多个局部极小值时，随机梯度反而更可能避免进入局部极小值中。</li>
</ol>
</blockquote>
<h4 id="小批量随机梯度下降（batch-gradient-descent）"><a href="#小批量随机梯度下降（batch-gradient-descent）" class="headerlink" title="小批量随机梯度下降（batch gradient descent）"></a>小批量随机梯度下降（batch gradient descent）</h4><p>如果在每次迭代中，梯度下降是用整个训练数据集来计算梯度的话，则会带来大量的计算量。因此提出批量梯度下降来进行优化。<strong>每次优化不再是对整体数据集来计算损失，取而代之使用随机采样小批量的样本来计算梯度。</strong><img src="https://img-blog.csdnimg.cn/0d8e8d1e6c234e36b0972e5b95c9f46a.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="Feature-Scaling-（特征缩放）"><a href="#Feature-Scaling-（特征缩放）" class="headerlink" title="Feature Scaling （特征缩放）"></a>Feature Scaling （特征缩放）</h3><p>其意思就是说要<strong>将所有特征有相同的规模</strong>。例如下图所示，<em>X2</em> 的范围明显大宇 <em>X1</em>，所以要将 <em>X2</em> 进行缩放。<br><img src="https://img-blog.csdnimg.cn/2b4681ef27884c0bbf400db0624e8740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="为什么要做Feature-Scaling？"><a href="#为什么要做Feature-Scaling？" class="headerlink" title="为什么要做Feature Scaling？"></a>为什么要做Feature Scaling？</h4><blockquote>
<p>为什么要做Feature Scaling？<img src="https://img-blog.csdnimg.cn/456a5666c6bf40b7a1e5f7a8727b529f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如左图，<em>X1</em> 和 <em>X2</em> 数值规模大小相差很大，那 <em>W2</em> 这参数的变动会极大的影响损失函数，而 <em>W1</em> 影响度就很小。所以我们<strong>需要对 <em>X2</em> 进行特征缩放，使其与 <em>X1</em> 保持一个规模</strong>。并且其实从图像可以看出，如果按左图来做的话，我们很难找到一组合适的参数集合，因为他梯度下降的方法不是直线的而是曲线；而右图是近乎直线。（<strong>最里面圈的损失函数最小</strong>）</p>
</blockquote>
<h4 id="如何实现Feature-Scaling？"><a href="#如何实现Feature-Scaling？" class="headerlink" title="如何实现Feature Scaling？"></a>如何实现Feature Scaling？</h4><p><img src="https://img-blog.csdnimg.cn/f129b6a000c841ec926df684d2c77a15.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如上图所示，假如有R个数据样本，每个样本有<em>X1 - Xi</em> 个特征。我们用上面的公式计算出其应该的scale（其实说实在的这不就是化成标准正太分布么）</p>
<h1 id="梯度下降算法数学总结"><a href="#梯度下降算法数学总结" class="headerlink" title="梯度下降算法数学总结"></a>梯度下降算法数学总结</h1><p>提出问题：如下图所示<strong>（我怎么样才能在红圈里找到最小损失的那个点呢）</strong><img src="https://img-blog.csdnimg.cn/53c25201a11349b6bc3af9e1dfc9fcc6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="首先要回顾泰勒公式"><a href="#首先要回顾泰勒公式" class="headerlink" title="首先要回顾泰勒公式"></a>首先要回顾泰勒公式</h2><p><img src="https://img-blog.csdnimg.cn/c9b154d4d14c43c8bf5e2609789bb094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/205bb83b97d849fc9b8c7451e044fdab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>二元泰勒：<br><img src="https://img-blog.csdnimg.cn/2efa8bf67ffa419e90221154515a3712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="用泰勒展开损失函数"><a href="#用泰勒展开损失函数" class="headerlink" title="用泰勒展开损失函数"></a>用泰勒展开损失函数</h2><p><img src="https://img-blog.csdnimg.cn/3ce8a2749e644d1f978c43d485798dde.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>理解为点乘，反向180度的时候，损失函数才是最小的：<img src="https://img-blog.csdnimg.cn/235fc97c36b74012b0663975ba0dc8a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>最终可以表达成：<img src="https://img-blog.csdnimg.cn/83f0037797f64c048376868ee2c21fae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="梯度下降算法缺点在哪"><a href="#梯度下降算法缺点在哪" class="headerlink" title="梯度下降算法缺点在哪"></a>梯度下降算法缺点在哪</h1><p>其不仅仅包括可能有找到是局部最优解问题，有可能在中间的时候就有偏微分为0的时候，而这时这个点可能离全局最优解点 很远。<br><img src="https://img-blog.csdnimg.cn/cd31675e6d8e4c83925852218d4f2acc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>李宏毅</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度消失和梯度爆炸的理解</title>
    <url>/2021/09/20/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>@<a href="梯度消失和梯度爆炸的理解">TOC</a></p>
<h1 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h1><p>梯度消失和梯度爆炸的根本原因是由于深度神经网络过长的链，在反向传播通过链式法则求导过程中产生的。 换句话说，就是<strong>反向传播先天就有一定的毛病</strong>。</p>
<h1 id="根本原因的理解"><a href="#根本原因的理解" class="headerlink" title="根本原因的理解"></a>根本原因的理解</h1><p><img src="https://img-blog.csdnimg.cn/beb6cdfcd994483c9133ee88c0763034.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="前馈和反向传播过程"><br>左上角为 正向反馈的步骤（σ 表示 激活函数 $sigmoid$ ）。 Loss 使用的是 MSE损失函数。 根据反向传播，我们可以看到最后 loss 对 b1 参数的梯度。 可以看到 连乘的情况。</p>
<ul>
<li>看这个式子里的 $w<em>{i}$ 中，一般我们初始化权重参数 $w</em>{i}$ 时，通常都小于1。</li>
<li>激活函数 $sigmoid$  的求导如下所示 <img src="https://img-blog.csdnimg.cn/9f175038b5e74cfda605e8906a194416.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="求导sigmoid函数"></li>
<li>激活函数的导数 图像如下图所示：<img src="https://img-blog.csdnimg.cn/fe08669e4f3648ea89dec0b560ba422b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="sigmoid函数求导"></li>
<li>所以$|σ’(z) × w| ≤ 0.25$，多个小于1的数连乘之后，那将会越来越小，导致靠近输入层的层的权重的偏导几乎为0，也就是说梯度几乎为0，导致参数基本不更新，这就是梯度消失的根本原因。<br>梯度爆炸的原因，也就是说如果$|σ’(z) × w| ≥ 1$，连乘下来就会导致梯度过大，导致梯度更新幅度特别大，可能会溢出，导致模型无法收敛。<br>但 $sigmoid$ 的函数是不可能大于1了，上图看的很清楚，那只能是参数 $w<em>{i}$了，故只有当 $abs(w)&gt;4$ 时才可能出现梯度爆炸，<strong>这也就是经常看到别人博客里的一句话，初始权重过大</strong>。<br>但梯度爆炸的情况一般不会发生，对于$sigmoid$ 函数来说，$σ’(z)$的大小也与 $w</em>{i}$ 有关。<br><strong>其实梯度爆炸和梯度消失问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。</strong></li>
</ul>
<h1 id="如何解决梯度消失的问题（待补充）"><a href="#如何解决梯度消失的问题（待补充）" class="headerlink" title="如何解决梯度消失的问题（待补充）"></a>如何解决梯度消失的问题（待补充）</h1><ol>
<li>用 $ReLU、LeakyRelu、Elu$ 等激活函数激活函数取代 $sigmoid$ 激活函数。<br>将输出不要固定在0-1之间。$sigmoid$函数的梯度随着 $x$ 的增大或减小和消失，而 $ReLU$ 不会。<br><img src="https://img-blog.csdnimg.cn/3dc7f13adf6c402a94e53d27765e8e92.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="sigmoid与relu"></li>
<li>Batch Normalization 就是通过对每一层的输出规范为均值和方差一致的方法，消除了$w$带来的放大缩小的影响，进而解决梯度消失和爆炸的问题。</li>
<li>ResNet残差结构<br>具体待补充完善，查看 ResNet</li>
<li>LSTM结构<br>LSTM不太容易发生梯度消失，主要原因在于LSTM内部复杂的“门（gates）”，具体看LSTM基本原理解析</li>
<li>预训练加finetunning<br>此方法来自Hinton在06年发表的论文上，其基本思想是每次训练一层隐藏层节点，将上一层隐藏层的输出作为输入，而本层的输出作为下一层的输入，这就是逐层预训练。<br>训练完成后，再对整个网络进行“微调（fine-tunning）”。<br>此方法相当于是找全局最优，然后整合起来寻找全局最优，但是现在基本都是直接拿imagenet的预训练模型直接进行finetunning。</li>
<li>梯度剪切、正则<br>这个方案主要是针对梯度爆炸提出的，其思想是设值一个剪切阈值，如果更新梯度时，梯度超过了这个阈值，那么就将其强制限制在这个范围之内。这样可以防止梯度爆炸。<br>另一种防止梯度爆炸的手段是采用权重正则化，正则化主要是通过对网络权重做正则来限制过拟合，但是根据正则项在损失函数中的形式：<br>可以看出，如果发生梯度爆炸，那么权值的范数就会变的非常大，反过来，通过限制正则化项的大小，也可以在一定程度上限制梯度爆炸的发生。</li>
</ol>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25631496">神经网络训练中的梯度消失与梯度爆炸</a></li>
<li><a href="https://www.jianshu.com/p/3f35e555d5ba">梯度消失和梯度爆炸问题详解</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 Deep Learning 基础</title>
    <url>/2021/08/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20Deep%20Learning%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>@<a href="深度学习 Deep Learning 基础">TOC</a></p>
<p><strong>深度学习需要明白的几个问题？</strong><br>思路：</p>
<ol>
<li>什么是深度学习？为什么需要深度学习？深度学习和机器学习的关系？</li>
<li>深度学习的步骤</li>
<li>确定神经网络模型的损失函数，如何优化模型，即调参问题</li>
<li>如何使用Back Propagation（反向传播） 方法 update DNN（深度神经网络）参数</li>
</ol>
<h1 id="深度学习的概念"><a href="#深度学习的概念" class="headerlink" title="深度学习的概念"></a>深度学习的概念</h1><h2 id="什么是深度学习？"><a href="#什么是深度学习？" class="headerlink" title="什么是深度学习？"></a>什么是深度学习？</h2><p>深度学习（Deep Learning，DL）是指多层的人工神经网络和训练它的方法。一层神经网络会把大量矩阵数字作为输入，通过<strong>非线性激活方法</strong>取权重，再产生另一个数据集合作为输出。这就像生物神经大脑的工作机理一样，通过合适的矩阵数量，多层组织链接一起，形成神经网络“大脑”进行精准复杂的处理，就像人们识别物体标注图片一样。</p>
<ul>
<li>深度学习的model是一个深度神经网络结构（neural structure）</li>
<li>深度学习的“深度”是指神经网络的隐层（hidden layer）数量足够多</li>
<li>深度学习是<strong>自动提取特征</strong>（Feature extractor），<strong>不需要像逻辑回归那样特征转换</strong>（Feature engineering）</li>
</ul>
<h2 id="为什么需要深度学习？-深度学习和机器学习的关系？"><a href="#为什么需要深度学习？-深度学习和机器学习的关系？" class="headerlink" title="为什么需要深度学习？ 深度学习和机器学习的关系？"></a>为什么需要深度学习？ 深度学习和机器学习的关系？</h2><ul>
<li>传统机器学习的模型结构较简单，很依赖算法工程师做特征工程甚至子模型来提升模型效果。就像我们之前上节那个栗子一样，做多分类的问题，四个角对角是一个类的情况，没办法进行分类，所以只能使用特征工程来进行特征的变换。</li>
<li>深度学习由于其层次化的结构，理论上可以拟合任意函数，整个复杂结构即可以用来对特征进行自动组合（如图像），也可以用来构建复杂的模型（如nlp领域里的LSTM，能够考虑上下文）。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b8b8df57f814494d8199e0e7b708e597.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="深度学习的步骤"><a href="#深度学习的步骤" class="headerlink" title="深度学习的步骤"></a>深度学习的步骤</h1><p>其实和机器学习一样分为三步。<img src="https://img-blog.csdnimg.cn/514f075664384cdcb62f6062fd5bd722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Step-1：定义一个神经网络结构（neural-structure）"><a href="#Step-1：定义一个神经网络结构（neural-structure）" class="headerlink" title="Step 1：定义一个神经网络结构（neural structure）"></a>Step 1：定义一个神经网络结构（neural structure）</h2><p>神经网络的创建包括3部分：</p>
<ol>
<li>神经网络有多少<strong>隐层（layer）</strong></li>
<li>每一层有多少<strong>神经元（neuron）</strong></li>
<li>每个神经元之间如何连接</li>
</ol>
<p>常见的出名神经网络<img src="https://img-blog.csdnimg.cn/5394cd49b44545c8ab4b8c1191d69239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="神经元怎么定义？"><a href="#神经元怎么定义？" class="headerlink" title="神经元怎么定义？"></a>神经元怎么定义？</h3><p>每个神经元都有一个 bias 和一个 function ，每条输入的边都有一个 weight<img src="https://img-blog.csdnimg.cn/52bc001e984c4bdf980921c7f2458fdf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="一个神经网络的栗子"><a href="#一个神经网络的栗子" class="headerlink" title="一个神经网络的栗子"></a>一个神经网络的栗子</h3><p>下面是一个 3个隐层（layer）、六个神经元（neuron）（每个球都是一个神经元）、全连接<strong>前馈</strong>网络（Fully Connection Feedforward Network）</p>
<blockquote>
<p>“<strong>前馈</strong>”是指整个网络中无反馈，信号从输入层向输出层单向传播，可用一个有向无环图表示<br>其实我们常用的网络，都是前馈神经网络，从输入到输出是一个有向图，中间不会有环或者反向传播。<br>当然，我们在训练前馈神经网络的时候，会用到反向传播进行参数调整。但仍不影响整个网络的有向和前馈性质。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/748979f3a3c74e0ab0c19ea60bd13142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="神经网络如何工作？"><a href="#神经网络如何工作？" class="headerlink" title="神经网络如何工作？"></a>神经网络如何工作？</h3><p><img src="https://img-blog.csdnimg.cn/d685eb4da45646df93096525226bb59f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其实 这就是矩阵运算（可以使用GPU加速计算）<img src="https://img-blog.csdnimg.cn/34294cf6a4254049b0f8bbc0aaf631a1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>总体可以归纳为：<br><img src="https://img-blog.csdnimg.cn/9baa5b003ea04ff7ad3bc25076e2bb58.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="栗子：识别手写数字图像"><a href="#栗子：识别手写数字图像" class="headerlink" title="栗子：识别手写数字图像"></a>栗子：识别手写数字图像</h3><p>从图像中识别是数字几？<br><img src="https://img-blog.csdnimg.cn/5fb1bc809a444ff5bc19325453eb703d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="制作神经网络模型-的FAQ（最容易被问得问题）"><a href="#制作神经网络模型-的FAQ（最容易被问得问题）" class="headerlink" title="制作神经网络模型 的FAQ（最容易被问得问题）"></a>制作神经网络模型 的FAQ（最容易被问得问题）</h3><ul>
<li>Q1： 神经网络需要几个隐层（layers）？每个层需要多少个神经元呢？<ul>
<li>反复试验+ 直觉 （说白了就是要慢慢试= = 看经验呗）</li>
</ul>
</li>
<li>Q2：神经网络可以自动确定结构吗？<ul>
<li>理论上其实是可以的，不过这些方法我们还没学到。Evoluntionary Artifical Neural Networks</li>
</ul>
</li>
<li>Q3：我们可以设计层次之间的结构么？<ul>
<li>意思就是说例如Layer1 链接 Layer3 这样跳着的 等等。当然可以 CNN就是不按顺序来的，具体看下一节。<br><img src="https://img-blog.csdnimg.cn/6c74000cf96a4af0b33146e9dca6efc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h2 id="Step-2：确定神经网络模型的损失函数"><a href="#Step-2：确定神经网络模型的损失函数" class="headerlink" title="Step 2：确定神经网络模型的损失函数"></a>Step 2：确定神经网络模型的损失函数</h2><p>还是和逻辑回归一样，用<strong>交叉熵损失函数</strong>，调参使得交叉熵损失函数最小，如下图所示：<br><img src="https://img-blog.csdnimg.cn/29c36a171c584a36bead0693b41b9027.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当然上面只是一个点的，把每个样本结合起来看。 <img src="https://img-blog.csdnimg.cn/ef62afa46f1248a09b17cea823c91513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>不过这个地方有几个疑问？</p>
<blockquote>
<ul>
<li>Q1：神经网络里面有很多层，所以有很多 <em>w</em> 和 <em>b</em> 调整。那是全体都一次性调整么？</li>
<li>答：  <strong>现在不知道啊！</strong></li>
<li>Q2：上面我是把所有的 交叉熵 都加在一起 然后对 整个大的损失函数进行调参是这样嘛？ 那我的训练样本应该是 各个数字都有是吗？</li>
<li>答： <strong>现在不知道啊！</strong></li>
</ul>
</blockquote>
<h2 id="Step-3：如何找到一个最好的函数（最佳参数），即调参"><a href="#Step-3：如何找到一个最好的函数（最佳参数），即调参" class="headerlink" title="Step 3：如何找到一个最好的函数（最佳参数），即调参"></a>Step 3：如何找到一个最好的函数（最佳参数），即调参</h2><p>用的还是 <strong>梯度下降法</strong>  </p>
<ol>
<li>随机选取一组参数</li>
<li>输入所有的训练样本</li>
<li>然后样本数据不变，参数不断变，用梯度下降法更新参数</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/72b790c9e1764d88bfef2b9f447c36c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/24ebb0869baf46e899e8f509d26ba720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="Backpropagation（反向传播）-来优化调参速度"><a href="#Backpropagation（反向传播）-来优化调参速度" class="headerlink" title="Backpropagation（反向传播） 来优化调参速度"></a>Backpropagation（反向传播） 来优化调参速度</h1><p>神经网络可能有很多个隐层，因此可能有百万数量级的参数，为了在<strong>梯度下降时有效地快速计算梯度</strong>，使用<strong>反向传播</strong>。<br>下图是 使用的损失函数为：交叉熵损失函数 ， 梯度下降法就是对每个参数求偏导，然后根据偏导大小进行左右移动，找到偏导为0的点，就是最佳参数值。</p>
<h2 id="计算对参数偏导的表达式"><a href="#计算对参数偏导的表达式" class="headerlink" title="计算对参数偏导的表达式"></a>计算对参数偏导的表达式</h2><p><img src="https://img-blog.csdnimg.cn/52fb4c86e71843b3b44aec5e596d4324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>交叉熵损失函数，为 正确值乘以 ln的带入x样本的线性模型 +<br>（1-正确值）乘以ln（1-带入x样本线性模型）<img src="https://img-blog.csdnimg.cn/cf25205ad5354582b0355f3aba098387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>只考虑刚输入阶段的神经元，可以得到用 <em>sigmoid</em>激活函数之前的量 <em>z</em>，而 <em>z</em> 是由线性模型（按权重分配向量 + 偏值 <em>b</em> 得到）。如下图所示，可以看到对参数 w 的偏导可以按照链式法则为  <script type="math/tex">∂C/∂w=∂z/∂w × ∂C/∂z</script>  前项为前项传递，后项为后向传递<br><img src="https://img-blog.csdnimg.cn/0438d1f3d1384270bf8a8abc93a6fe81.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<ul>
<li>前项传递非常好看出来，就是对应的输入值，比如 <code>∂C/∂w1=∂z/∂w1 × ∂C/∂z</code> 。其中<code>∂z/∂w1</code> 看图上所示，不就是对 <em>w1</em> 进行偏导么，那就是 <em>x1</em>。</li>
<li>后项过程比较复杂，根据链式法则，<code>∂C/∂z=∂a/∂z × ∂C/∂a</code>，其中<code>∂a/∂z = σ&#39;(z)</code> 如下图所示<img src="https://img-blog.csdnimg.cn/636c2b53744d478ab268bf80073be7fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>归纳一下得到如下：<img src="https://img-blog.csdnimg.cn/c03a971beb4940cd93cb185b340bf470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这个时候我们从另一观点看待上面的式子：有另外一个神经元（下图中的三角形，表示乘法/放大器），input是<code>∂C/∂z</code>‘与<code>∂C/∂z′&#39;</code>  ，权重分别是 <em>w3,w4</em>，求和经过神经元（乘以σ′(z)），得到 <code>∂C/∂z</code>。（相当于反向传播，先线性加权再乘以一个σ′(z) 和正向非常类似）<img src="https://img-blog.csdnimg.cn/6ec05d31b6ed4eb89ab2c5bcc39b6282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h2 id="后项传递-的两种情况"><a href="#后项传递-的两种情况" class="headerlink" title="后项传递 的两种情况"></a>后项传递 的两种情况</h2><p>如上图所示是我们最后得到的后项传递的式子，其中我们还有两个项不知道。那我们现在需要计算这两个部分，但分为两种情况</p>
<h3 id="case-1：下一层是最终输出层"><a href="#case-1：下一层是最终输出层" class="headerlink" title="case 1：下一层是最终输出层"></a>case 1：下一层是最终输出层</h3><p>第一种情况，z′,z′′ 所接的neuron是output layer的neuron。<br>这个就比较简单，直接根据最后一层的输出反向写出即可。<img src="https://img-blog.csdnimg.cn/5683f53fae4b4b619a617d5513159510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="case-2：下一层不是最终输出层"><a href="#case-2：下一层不是最终输出层" class="headerlink" title="case 2：下一层不是最终输出层"></a>case 2：下一层不是最终输出层</h3><p>第二种情况，z′,z′′ 所接的neuron不是output layer的neuron。<img src="https://img-blog.csdnimg.cn/935435dd3b0b435c9ab31388786acd78.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">就上面那个图，我们可以推得类似后项传递的式子<img src="https://img-blog.csdnimg.cn/783ca76c842846efa9b6d89de1a874d9.png#pic_center" alt="在这里插入图片描述">就这样反复迭代(递归)，直到遇到case1的情况，就可以算出整个后项传递。然后结合之前的前项传递，就是我们要得到的对这个参数的偏微分值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/9796822a131546fabd92e1a1bac1a2d1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>梯度下降时需要计算损失函数对每个参数偏微分<code>∂C/∂w</code>，<em>w</em> 代表相邻隐层之间的一条连线（即权值），每个 <em>w</em> 只有一个所指的神经元。</p>
<ul>
<li>链式法则将计算 <code>∂C/∂w</code> 拆成前向过程与后向过程。</li>
<li>前向过程计算的是<code>∂z/∂w</code> ，这里 <em>z</em> 是 <em>w</em> 所指neuron的input，<strong>计算结果是与 <em>w</em> 相连的值。</strong><br>后向过程计算的是<code>∂C/∂z</code>，这里 <em>z</em> 仍是 <em>w</em> 所指neuron的input，计算结果通过从后至前递归得到。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
        <tag>反向传播</tag>
      </tags>
  </entry>
  <entry>
    <title>模型误差的来源分析</title>
    <url>/2021/08/02/%E6%A8%A1%E5%9E%8B%E8%AF%AF%E5%B7%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>@<a href="模型误差的来源分析">TOC</a></p>
<blockquote>
<p>思路：<br>1、首先，误差的两大来源 <em>bias</em>（偏差） 和 <em>variance</em>（方差） 是指什么<br>2、然后，<em>bias</em>（偏差）和 <em>variance</em>（方差）是怎么产生的<br>3、进一步，如何判断你的模型是 <em>bias大</em>（欠拟合）还是<em>variance大</em>（过拟合），如何解决 ？</p>
</blockquote>
<h1 id="模型的两大来源bias（偏差）和variance（方差）"><a href="#模型的两大来源bias（偏差）和variance（方差）" class="headerlink" title="模型的两大来源bias（偏差）和variance（方差）"></a>模型的两大来源bias（偏差）和variance（方差）</h1><blockquote>
<p>什么是bias和variance呢？<br>思路：</p>
<ol>
<li>首先要知道什么是误差</li>
<li>在了解什么是bias和variance</li>
</ol>
</blockquote>
<h2 id="什么是误差？"><a href="#什么是误差？" class="headerlink" title="什么是误差？"></a>什么是误差？</h2><p><strong>机器学习就是寻找一个函数，然后给它一个输入，就能得到一个理想的输出。</strong><br>f head是理论上找到的最佳函数，f star 是我们用模型预测出来的函数，<strong>两者的差值就是误差</strong>。<img src="https://img-blog.csdnimg.cn/39bb552a5ba348b88a8882c744f74566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="什么是bias和variance（偏差和方差）"><a href="#什么是bias和variance（偏差和方差）" class="headerlink" title="什么是bias和variance（偏差和方差）"></a>什么是bias和variance（偏差和方差）</h2><h3 id="什么是bias（偏差）？"><a href="#什么是bias（偏差）？" class="headerlink" title="什么是bias（偏差）？"></a>什么是bias（偏差）？</h3><p>举个栗子说明，下图是用一定样本数的均值m来估计假设的随机变量的<strong>平均值u</strong>，这是一种<strong>无偏估计（unbiased）</strong>。<img src="https://img-blog.csdnimg.cn/eaeb2438d6a645d7b1236e6a9df59da8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>也就是说，<strong>估计值的期望等于假设值</strong>（如上文的E(m)=u），<strong>即为无偏差，反之有偏差（bias）</strong>。<br><strong>当样本数越来越大时，m就越靠近u。</strong></p>
<h3 id="什么是variance（方差）"><a href="#什么是variance（方差）" class="headerlink" title="什么是variance（方差）"></a>什么是variance（方差）</h3><p><strong>方差表达的是数据的离散程度</strong><img src="https://img-blog.csdnimg.cn/28ad8de1e99b4c91a3f16a1088968ca4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里对于方差的估计是有差估计：<img src="https://img-blog.csdnimg.cn/c9ee7e91fff24cd498b5a21420ad1ed5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="总结直观理解"><a href="#总结直观理解" class="headerlink" title="总结直观理解"></a>总结直观理解</h3><p>最后，bias和variance的直观理解：<img src="https://img-blog.csdnimg.cn/357d51b0a7f34b06933c5a86c042c8dc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>bias表示的是预测的f bar（f star预测值的期望）与f head（实际正确值）的距离</li>
<li>variance表示的是每次预测的f star（预测值）与f bar（预测值的期望）的距离（看图）</li>
</ol>
<h2 id="bias和variance是怎么产生的"><a href="#bias和variance是怎么产生的" class="headerlink" title="bias和variance是怎么产生的"></a>bias和variance是怎么产生的</h2><blockquote>
<p>下面结合实际的实验说明，bias和variance是如何产生的。<br>————————————————————————————————————————————————————<br>bias如何知晓？，就要做多次实验，确定多个f star（一次实验一个预测值），然后求出f star 样本集的期望（E(f star)）<br>那么首先，我们虚拟出100个神奇宝贝平行宇宙（相当于设置了100组实验），每个预祝<strong>一个神奇宝贝训练家捕捉10只神奇宝贝</strong>（相当于每组实验10个数据），如下图：<img src="https://img-blog.csdnimg.cn/ef3d6cfdd1ca4c179d091c2f5130a42c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>然后思考，对于这样的数据，<strong>我们选用什么model比较好</strong> ?<strong>哪一个model最后的bias比较小</strong>？<img src="https://img-blog.csdnimg.cn/c05149fd285d4c96bd182567c2d891fd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如上图，不同宇宙的神奇宝贝数据非常随机，项次越高，模型越复杂</p>
</blockquote>
<h3 id="方差-variance"><a href="#方差-variance" class="headerlink" title="方差 variance"></a>方差 variance</h3><p><img src="https://img-blog.csdnimg.cn/fea8cce3d3b64a768fbf007ddefe0021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对于方差而言，其表示结果的离散程度，项次越高，模型越复杂，则其离散程度肯定是越大的。<strong>因为模型越简单，收到数据的影响也就越低</strong>，比如：我极端一点，f(x)=c，数据根本不会影响model最后的预测值</p>
<h3 id="偏差-bias"><a href="#偏差-bias" class="headerlink" title="偏差 bias"></a>偏差 bias</h3><p><img src="https://img-blog.csdnimg.cn/ade6e8be3e52487bafd38dd0f8e750a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/759ad31af9b04b6a8cdeb92364abe4f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>图中看出，简单model可能并不包含目标，因此会造成较大的bias，而复杂的model是涵盖目标的，所以bias小。</p>
<h3 id="偏差和方差的总结"><a href="#偏差和方差的总结" class="headerlink" title="偏差和方差的总结"></a>偏差和方差的总结</h3><blockquote>
<p>简单的模型（次数小），bias会比较大，但variance会比较小，预测值更加集中。<br>复杂的模型（次数大），bias会比较小，但variance会比较大，预测值更加的离散。<br>因此，我们理想中的目标是找到一个平衡点，使bias和variance尽可能小。<img src="https://img-blog.csdnimg.cn/c5a88735d7d94da79046122ca8310740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="判断你的模型是bias大（欠拟合）还是variance大（过拟合）并解决"><a href="#判断你的模型是bias大（欠拟合）还是variance大（过拟合）并解决" class="headerlink" title="判断你的模型是bias大（欠拟合）还是variance大（过拟合）并解决"></a>判断你的模型是bias大（欠拟合）还是variance大（过拟合）并解决</h2><h3 id="如何判断"><a href="#如何判断" class="headerlink" title="如何判断"></a>如何判断</h3><p><img src="https://img-blog.csdnimg.cn/c8150c9d246e4b10841294be51ab0f4a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="bias过大（欠拟合）"><a href="#bias过大（欠拟合）" class="headerlink" title="bias过大（欠拟合）"></a>bias过大（欠拟合）</h3><p>需要重新设计模型</p>
<ol>
<li>模型考虑的特征没有全，也就是很多其实没有作用。关键特征可能还没考虑到，需要加入进去</li>
<li>模型应该需要更加的复杂，增加更高的次项。</li>
</ol>
<h3 id="variance过大（过拟合）"><a href="#variance过大（过拟合）" class="headerlink" title="variance过大（过拟合）"></a>variance过大（过拟合）</h3><ol>
<li>需要更多的数据，有些数据不够有特点</li>
<li>可以增加一个 正则项，加强模型的平滑度，使其预测值分布不要太离散</li>
</ol>
<h3 id="解决实际测试比共有数据集误差更大的问题"><a href="#解决实际测试比共有数据集误差更大的问题" class="headerlink" title="解决实际测试比共有数据集误差更大的问题"></a>解决实际测试比共有数据集误差更大的问题</h3><p><img src="https://img-blog.csdnimg.cn/d742c18f9bc04a8ea7981b28a9c2970b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>将训练集，分为两部分。这叫做2-折交叉验证。一部分还是当做训练样本，帮助我们进行调参；另一部分用作验证，验证我的模型损失如何，是否合理（充当原来共有训练集的作用）。而现在原有训练集的部分用来充当实际样本数据，算出误差值，以便于真正在实际中误差太大。</p>
<p><img src="https://img-blog.csdnimg.cn/1c0fa7f4983a4dc585448876cab974d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>李宏毅</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础 - Batch Normalization</title>
    <url>/2021/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%20-%20Batch%20Normalization/</url>
    <content><![CDATA[<p>@<a href="深度学习基础 - Batch Normalization">TOC</a></p>
<p>在计算机的眼光里，对具有统一规格的数据，更能学习到其数据之间的规律特征。也就是下图所看的的这样，将杂乱的数据标准归一化。<br><img src="https://img-blog.csdnimg.cn/img_convert/7c0360d9080d48dce15371c941baea9b.png#pic_center" alt="数据标准归一化"></p>
<p>首先我们之前有Normalization（普通数据标准化），一般用作<strong>输入数据</strong>的样本归一化操作。那Batch Normalization 则可用在 每个层上包括隐藏层。</p>
<h1 id="机器学习中的Feature-Scaling"><a href="#机器学习中的Feature-Scaling" class="headerlink" title="机器学习中的Feature Scaling"></a>机器学习中的Feature Scaling</h1><p>如果特征大小差的比较远的话，loss function会很扁平，数值更大的feature的参数会对结果的影响更大，这样在训练过程中，不同的方向需要设定不同的学习率，这样子会不太方便，这不是我们想看到的，所以我们通常会去做feature scaling。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/196be414d2c05a542644613ab56c6213.png#pic_center" alt="使用Feature Scaling后"><br>具体的操作很简单，对每一维特征，我们对每一个数据减去这维特征的均值，再除以这位特征的标准差，得到缩放后的新的特征值，此时它的均值为0，方差为1。一般经过feature scaling之后，<strong>收敛速度会变快</strong>。</p>
<p><strong>那么在神经网络中又是什么情况呢？</strong></p>
<p>我们可以看到，其实在深度网络中，后一层的输入其实是前一层的输出。那么我们在做feature scaling的时候，应该对每一层的输入都去做一个feature scaling, 但是又不像传统的机器学习，由于神经网络每一层的参数都在不断变化，直接使用前面的feature scaling是不太合适的。所以我们需要一个新的技术，就是Batch Normalization了</p>
<h1 id="Batch-Normalization-放在神经网络的哪个部位？"><a href="#Batch-Normalization-放在神经网络的哪个部位？" class="headerlink" title="Batch Normalization 放在神经网络的哪个部位？"></a>Batch Normalization 放在神经网络的哪个部位？</h1><p>Batch Normalization 放在 线性层的后面，激活函数的前面。如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/be42f4f33882e58d12258995609ccb06.png#pic_center" alt="Batch Normalization 放在 线性层的后面，激活函数的前面"></p>
<h2 id="Batch-Normalization-基本原理"><a href="#Batch-Normalization-基本原理" class="headerlink" title="Batch Normalization 基本原理"></a>Batch Normalization 基本原理</h2><p>现在一般采用批梯度下降方法对深度学习进行优化，这种方法把数据分为若干组，按组来更新参数，一组中的数据共同决定了本次梯度的方向，下降时减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也下降了很多。</p>
<p>Batch Normalization(简称BN)中的batch就是批量数据，即每一次优化时的样本数目，通常BN网络层用在卷积层后，用于重新调整数据分布。假设神经网络某层一个batch的输入为X=[x1,x2,…,xn]，其中xi代表一个样本，n为batch size。</p>
<ol>
<li>首先，我们需要求得mini-batch里元素的均值：<script type="math/tex; mode=display">μ_{B}=\frac{1}{n}\sum_{i=1}^{n}x_{i}</script></li>
<li>接下来，求取mini-batch的方差：<script type="math/tex; mode=display">\sigma _{B}^{2} = \frac{1}{n}\sum_{i=1}^{n}(x_{i}-μ_{B})^{2}</script></li>
<li>这样我们就可以对每个元素进行归一化<script type="math/tex; mode=display">\hat{x_{i}}=\frac{x_{i}-μ_{B}}{\sqrt{\sigma _{B}^{2}+\varepsilon}}</script>这里的分母本来应该是 $\sigma$,但为了防止它为0，我们加上一个$\varepsilon$。</li>
<li>最后进行尺度缩放和偏移操作，这样可以变换回原始的分布，实现恒等变换，这样的目的是为了补偿网络的非线性表达能力，因为经过标准化之后，偏移量丢失。具体的表达如下，$y_{i}$就是网络的最终输出。$γ$与$β$是神经网络的参数，是网络自己学习的。<script type="math/tex; mode=display">y_{i}=γ\hat{x_{i}}+β</script></li>
</ol>
<p>从某种意义上来说，方差和均值代表的其实是输入数据分布的方差和偏移。对于没有BN的网络，这两个值与前一层网络带来的非线性性质有关，而经过变换后，就跟前面一层无关，变成了当前层的一个学习参数，这更加有利于优化并且不会降低网络的能力。</p>
<h1 id="举个-Batch-Normaliztion-计算栗子"><a href="#举个-Batch-Normaliztion-计算栗子" class="headerlink" title="举个 Batch Normaliztion 计算栗子"></a>举个 Batch Normaliztion 计算栗子</h1><p>他分为训练（训练 $γ$与$β$）和测试阶段（使用训练后得到的参数）。<br><img src="https://img-blog.csdnimg.cn/img_convert/ae36898be0aa225a92aaf50123680551.png#pic_center" alt="同济子豪兄的理解"><br>如下图 这个的 batch_size=8，也就是说输入的图像有8张，即8个输入；看第一个0.9 表示的是 第一张神经元对第4张图片的响应；后面的1.7就是 第一张神经元对第5张图片的响应；26.7 也就是最后一个神经元对 第4张图片的响应。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a5c5dfbc5e9f3d93b52b31b12dec84c7.png#pic_center" alt=""><br>就是先算出 平均值 再计算 均方差，按公式得到标准化的结果。</p>
<h1 id="Batch-Normaliztion-的效果"><a href="#Batch-Normaliztion-的效果" class="headerlink" title="Batch Normaliztion 的效果"></a>Batch Normaliztion 的效果</h1><ol>
<li>因为BN可以把输入都规整化在非饱和区内，所以他可以加快收敛（因为梯度变化的大，不缓慢）比如 sigmoid 和 tanh 函数 非饱和区和饱和区。</li>
<li>减少了训练时间，而且可以进行深层网络的训练，同时可以使用更大的学习率。</li>
<li>减轻了对参数初始化的依赖，这是利于调参的</li>
<li>可以起到正则化的作用 可以防止过拟合</li>
<li>BN一定程度上增加了泛化能力，dropout等技术可以去掉。</li>
</ol>
<p><strong>注意：BN与Dropout不能一起使用。</strong> 为什么有待于补充。</p>
<h2 id="可以看一下-效果"><a href="#可以看一下-效果" class="headerlink" title="可以看一下 效果"></a>可以看一下 效果</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/275bcf4be1343343b2e006268bed2b95.png#pic_center" alt="用了Batch Normalization 的效果"></p>
<h1 id="参考论文与博客"><a href="#参考论文与博客" class="headerlink" title="参考论文与博客"></a>参考论文与博客</h1><p>Batch Normalization论文：<a href="http://proceedings.mlr.press/v37/ioffe15.pdf">Batch Normalization论文</a><br>参考的博客：<br><a href="https://zhuanlan.zhihu.com/p/24810318">什么是批标准化？</a><br><a href="https://www.zhihu.com/question/38102762/answer/607815171">知乎第一个留言 深度学习中 Batch Normalization为什么效果好？</a><br><a href="https://zhuanlan.zhihu.com/p/54073204">精选 写的很好  Batch Normalization的通俗解释 </a></p>
]]></content>
      <categories>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测的中的指标的含义及其实现</title>
    <url>/2021/10/04/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9A%84%E4%B8%AD%E7%9A%84%E6%8C%87%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>@<a href="目标检测的中的指标的含义及其实现">TOC</a></p>
<h1 id="Precision和Recall"><a href="#Precision和Recall" class="headerlink" title="Precision和Recall"></a>Precision和Recall</h1><ul>
<li>Precision是查准率、精确率的意思。预测为正的结果中，有多少真正是正样本。</li>
<li>Recall是查全率、召回率的意思。对所有正样本有多少预测出来了。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cdb0fd90e720fb4261f93aa90c4dd2dc.png#pic_center" alt="举个栗子"><br>用另一个图理解<br><img src="https://img-blog.csdnimg.cn/img_convert/3fb660ada123e26a1f646c9962eefb8e.png#pic_center" alt="在这里插入图片描述"><br>快速记忆 左边这个是TF表示这个结果预测的对不对<br>    右边那个PN表示我预测的是正的还是负的（比如二分类 正的：是这个东西 负的：不是这个东西）<br>注意：这两个量都是：第一是你告诉我是正的里面有多少是对的，第二是关注我对ground truth是正的 也就是实际上就是正的的能力。这两个是相反的关系，一个高另一个就低。<br>比如如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/56443acb4016898926b67ac50eb7052a.png#pic_center" alt="提升评选的标准"><br>提升门槛值，那么也就是对的会越对。门槛值高了嘛，那我正样本预测的就越准的，那么我将负样本预测错误成正样本的概率就低了。所以我的 Precison上升了，但Recall 下降了。</p>
<h1 id="IoU-Intersection-over-Union"><a href="#IoU-Intersection-over-Union" class="headerlink" title="IoU (Intersection over Union)"></a>IoU (Intersection over Union)</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/88aa2935955dddb7556f2dcbd15c4e3e.png#pic_center" alt="IoU示意图"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateIoU</span>(<span class="params">candidateBound, groundTruthBound</span>):</span></span><br><span class="line">    cx1 = candidateBound[<span class="number">0</span>]</span><br><span class="line">    cy1 = candidateBound[<span class="number">1</span>]</span><br><span class="line">    cx2 = candidateBound[<span class="number">2</span>]</span><br><span class="line">    cy2 = candidateBound[<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">    gx1 = groundTruthBound[<span class="number">0</span>]</span><br><span class="line">    gy1 = groundTruthBound[<span class="number">1</span>]</span><br><span class="line">    gx2 = groundTruthBound[<span class="number">2</span>]</span><br><span class="line">    gy2 = groundTruthBound[<span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">    carea = (cx2 - cx1) * (cy2 - cy1) <span class="comment">#C的面积</span></span><br><span class="line">    garea = (gx2 - gx1) * (gy2 - gy1) <span class="comment">#G的面积</span></span><br><span class="line"> </span><br><span class="line">    x1 = <span class="built_in">max</span>(cx1, gx1)</span><br><span class="line">    y1 = <span class="built_in">max</span>(cy1, gy1)</span><br><span class="line">    x2 = <span class="built_in">min</span>(cx2, gx2)</span><br><span class="line">    y2 = <span class="built_in">min</span>(cy2, gy2)</span><br><span class="line">    w = <span class="built_in">max</span>(<span class="number">0</span>, x2 - x1)</span><br><span class="line">    h = <span class="built_in">max</span>(<span class="number">0</span>, y2 - y1)</span><br><span class="line">    area = w * h <span class="comment">#C∩G的面积</span></span><br><span class="line"> </span><br><span class="line">    iou = area / (carea + garea - area)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> iou</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="top1、top5-的含义"><a href="#top1、top5-的含义" class="headerlink" title="top1、top5 的含义"></a>top1、top5 的含义</h1><p>在图像分类中：</p>
<ul>
<li>Top-1 error<br>的意思是：假如模型预测某张动物图片（一只猫）的类别，且模型只输出1个预测结果，那么这一个结果正好能猜出来这个动物是只猫的概率就是Top-1正确率。猜出来的结果不是猫的概率则成为Top-1错误率。简单来说就是模型猜错的概率。</li>
<li>Top-5 error<br>的意思是：假如模型预测某张动物图片（还是刚才那只猫），但模型会输出来5个预测结果，那么这五个结果中有猫这个分类的概率成为Top-5正确率，相反，预测输出的这五个结果里没有猫这个分类的概率则成为Top-5错误率。</li>
</ul>
<p>一般来说，Top-1和Top-5错误率越低，模型的性能也就越好。且Top-5 error 在数值上会比Top-1 error 的数值要小，毕竟从1个结果猜对的几率总会比从5个结果里猜对的几率要小嘛！</p>
<p>在目标检测中：</p>
<ul>
<li>top-1正确率，就是你预测的label取最后概率向量里面最大的那一个作为预测结果，如过你的预测结果中概率最大的那个分类正确，则预测正确，否则预测错误。</li>
<li>top5就是最后概率向量最大的前五名中，只要出现了正确概率即为预测正确。否则预测错误。</li>
</ul>
<h1 id="Average-Precision-AP-与-mAP"><a href="#Average-Precision-AP-与-mAP" class="headerlink" title="Average Precision (AP)与 mAP"></a>Average Precision (AP)与 mAP</h1><p>多个类别目标检测中，每个类别都可以根据recall（召回率）和 percision（准确率）绘制一条曲线。AP就是该曲线下的面积，mAP意思是对每一类的AP再求平均。<br>mAP计算方法：<br>首先我们要先搞明白AP。<br>AP表示 整个的面积<br><img src="https://img-blog.csdnimg.cn/img_convert/56443acb4016898926b67ac50eb7052a.png#pic_center" alt="AP如右图"><br><img src="https://img-blog.csdnimg.cn/img_convert/245a8e1597441fc997ad6b64144a473b.png#pic_center" alt=""><br>我们一般用F1的值来 找到最适合的点  来均衡 Precison 和 Recall。<br>那什么是mAP呢，我们现在讨论的都是 比如预测有1和0，我们是针对1这个正样本。也可以反过来看0作为正样本呢。所以要加起来一起除以总体 数。<br><img src="https://img-blog.csdnimg.cn/img_convert/2d4feb910a3867622ae4e1c6e85d9aa8.png#pic_center" alt="mAP与AP"></p>
]]></content>
      <categories>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络与深度学习 学习笔记（第一章）</title>
    <url>/2021/09/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="神经网络与深度学习 邱锡鹏 学习笔记（第一章）">TOC</a></p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="浅层学习"><a href="#浅层学习" class="headerlink" title="浅层学习"></a>浅层学习</h2><blockquote>
<p>学习一个预测模型．一般需要首先将数据表示为一组特征（Feature），特征的表示形式可以是连续的数值、离散的符号或其他形式．然后将这些特征输入到预测模型，并输出预测结果．这类机器学习可以看作浅层学习（Shallow  Learning）</p>
</blockquote>
<h2 id="机器学习的步骤"><a href="#机器学习的步骤" class="headerlink" title="机器学习的步骤"></a>机器学习的步骤</h2><ol>
<li>数据预处理：对数据的原始形式进行初步的数据清理（比如去掉一些有缺失特征的样本，或去掉一些冗余的数据特征等）和加工（对数值特征进行缩放和归一化等），并构建成可用于训练机器学习模型的数据集．</li>
<li>特征提取：从数据的原始特征中提取一些对特定机器学习任务有用的高质量特征．比如在图像分类中提取边缘、尺度不变特征变换（Scale Invariant<br>Feature Transform，SIFT）特征，在文本分类中去除停用词等．</li>
<li>特征转换：对特征进行进一步的加工，比如降维和升维． 很多特征转换方法也都是机器学习方法．降维包括特征抽取（Feature Extraction）和特征选择（FeatureSelection）两种途径．常用的特征转换方法有主成分分析（Principal Components Analysis，PCA）、 线性判别分析（Linear Discriminant Analysis，LDA）等．</li>
<li>预测：机器学习的核心部分，学习一个函数并进行预测．</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/f3d73fb28f1342f48a6ca08638b8da68.png#pic_center" alt="传统机器学习的数据处理流程"><br>注：很多的机器学习问题变成了特征工程（Feature Engineering）问题．开发一个机器学习系统的主要工作量都消耗在了预处理、特征提取以及特征转换上。</p>
<h1 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h1><p>在表示学习中，有两个核心问题：</p>
<ul>
<li>一是“什么是一个好的表示”；即表示 需要包含更高层的语义信息</li>
<li>二是“如何学习到好的表示”．</li>
</ul>
<p>传统的特征学习一般是通过<font color="red">人为地设计一些准则</font>，然后根据这些准则来选取有效的特征。 所以 特征的学习是和最终预测模型的学习分开进行的，<font color="red">因此学习到的特征不一定可以提升最终模型的性能．</font></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将输入信息转换为有效的特征。<br>如果有一种算法可以自动地学习出有效的特征，并提高最终机器学习模型的性能，那么这种学习就可以叫作表示学习（Representation Learning）．</p>
<h2 id="语义鸿沟"><a href="#语义鸿沟" class="headerlink" title="语义鸿沟"></a>语义鸿沟</h2><p>语义鸿沟问题是指输入数据的底层特征和高层语义信息之间的不一致性和差异性。</p>
<blockquote>
<p>比如车，图片中每辆车的颜色和形状等属性都不尽相同，因此不同图片在像素级别上的表示（即底层特征）差异性也会非常大．但是我们理解这些图片是建立在比较抽象的高层语义概念上的</p>
</blockquote>
<h2 id="表示特征的方式"><a href="#表示特征的方式" class="headerlink" title="表示特征的方式"></a>表示特征的方式</h2><ol>
<li>局部表示：例如，one-hot向量 表示颜色。 缺点在于多个颜色就多个列或者行 </li>
<li>分布式表示：RGB 表示颜色</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/aa86242673364da09f8245d248914cbd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="局部表示和分布式表示示例"></p>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>嵌入通常指将一个度量空间中的一些对象映射到另一个低维的度量空间中，并尽可能保持不同对象之间的拓扑关系．<font color="blue">比如自然语言中词的分布式表示，也经常叫作词嵌入 </font></p>
<p><font color="red"><strong>例如：3维one-hot向量空间和一个2维嵌入空间的对比</strong></font><br><img src="https://img-blog.csdnimg.cn/007e99163fd044348e7061ebebc1af33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="one-hot向量空间与嵌入空间"><br>在低维的嵌入空间中，每个样本都不在坐标轴上，样本之间可以计算相似度．</p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="什么是深度"><a href="#什么是深度" class="headerlink" title="什么是深度"></a>什么是深度</h2><p>“深度”是指原始数据进行非线性特征转换的次数</p>
<h2 id="深度学习的优点"><a href="#深度学习的优点" class="headerlink" title="深度学习的优点"></a>深度学习的优点</h2><p>深度学习，其主要目的是从数据中<font color="red">自动学习到有效的特征表示 </font><br>其抽象在 数据通过多层的特征转换，学习到的表示可以代替人工设计的特征，从而避免“特征工程”<br><img src="https://img-blog.csdnimg.cn/f678fb27e01c4d989d099cfa06afe038.png#pic_center" alt="深度学习的数据处理流程"><br>其是 一种 <font color="red"><strong>端到端的学习方式</strong></font>   在学习过程中<strong>不进行分模块或分阶段训练</strong>，直接优化任务的总体目标．在端到端学习中，一般不需要明确地给出不同模块或阶段的功能，中间过程不需要人为干预</p>
<h2 id="深度学习的关键问题"><a href="#深度学习的关键问题" class="headerlink" title="深度学习的关键问题"></a>深度学习的关键问题</h2><p>深度学习需要解决的关键问题是 <strong>贡献度分配问题</strong>，即一个系统中不同的 <strong>组件</strong> 或其 <strong>参数</strong> 对最终系统输出结果的贡献或影响 </p>
<p>目前，深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以使用 <strong>误差反向传播算法</strong> ，从而可以比较好地解决贡献度分配问题</p>
<h1 id="深度学习相关的学术会议"><a href="#深度学习相关的学术会议" class="headerlink" title="深度学习相关的学术会议"></a>深度学习相关的学术会议</h1><ul>
<li>国际表示学习会议  ICLR ：主要聚焦于深度学习</li>
<li>神经信息处理系统年会 NeurIPS ：交叉学科会议，但偏重于机器学习</li>
<li>国际机器学习会议 ICML：机器学习顶级会议</li>
<li>国际人工智能联合会议 IJCAI ：人工智能领域最顶尖的综合性会议</li>
<li>美国人工智能协会年会  AAAI ：人工智能领域的顶级会议</li>
</ul>
<h2 id="计算机视觉领域"><a href="#计算机视觉领域" class="headerlink" title="计算机视觉领域"></a>计算机视觉领域</h2><ul>
<li>计算机视觉与模式识别大会  CVPR</li>
<li>国际计算机视觉会议  ICCV</li>
</ul>
<h2 id="自然语言处理领域"><a href="#自然语言处理领域" class="headerlink" title="自然语言处理领域"></a>自然语言处理领域</h2><ul>
<li>计算语言学年会 ACL</li>
<li>自然语言处理实证方法大会  EMNLP</li>
</ul>
]]></content>
      <categories>
        <category>深度学习基础-邱锡鹏</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>邱锡鹏</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络与深度学习 邱锡鹏 学习笔记（机器学习）</title>
    <url>/2021/09/11/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20%E9%82%B1%E9%94%A1%E9%B9%8F%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="神经网络与深度学习 邱锡鹏 学习笔记（机器学习）">TOC</a></p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习看作一个从有限、高维、有噪声的数据上得到更一般性规律的泛化问题．<br><img src="https://img-blog.csdnimg.cn/b5f2ae1f8a044527984d6b7a4e1d2190.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="机器学习过程"></p>
<h2 id="机器学习的三个基本要素"><a href="#机器学习的三个基本要素" class="headerlink" title="机器学习的三个基本要素"></a>机器学习的三个基本要素</h2><p><img src="https://img-blog.csdnimg.cn/0e48590c034949c6917b8eeeb555ad30.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="机器学习三要素"></p>
<ul>
<li>模型</li>
<li>学习准则</li>
<li>优化算法</li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>我们不知道 输入和输出是如何对应联系的，也就是数学函数究竟是什么。 我们假设一个可能的函数集合 $ℱ$ ，称为 假设空间 。 我们根据 观测 各函数在测试集 $𝒟$ 的表现，从中选择更理想的假设模型。<br>常用的假设空间分为 <strong>线性和非线性</strong> 两种</p>
<h2 id="学习准则"><a href="#学习准则" class="headerlink" title="学习准则"></a>学习准则</h2><p>令训练集 是由 $𝑁$ 个独立同分布的样本组成，即每个样本 (𝒙, 𝑦) ∈ 𝒳 × 𝒴 是从 𝒳  和 𝒴  的联合空间中按照某个未知分布 $𝑝_{r}(𝒙, 𝑦)$ 独立地随机产生的 。</p>
<p>学习准则包括：</p>
<ul>
<li>经验风险最小化</li>
<li>结构风险最小化</li>
<li>最大似然估计</li>
<li>最大后验估计</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>用来量化模型预测和真实标签之间的差异</p>
<h4 id="0-1损失函数"><a href="#0-1损失函数" class="headerlink" title="0-1损失函数"></a>0-1损失函数</h4><h4 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h4><p>经常用在预测标签 $𝑦$ 为实数值的任务中</p>
<script type="math/tex; mode=display">L(y,f(x;θ)) = \frac{1}{2}(y-f(x;θ))</script><p><strong>平方损失函数一般不适用于分类问题</strong> </p>
<h4 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h4><p>一般用于分类问题</p>
<script type="math/tex; mode=display">L(y,f(x;θ)) =-\sum_{c=1}^{C}y_{c}\log f_{c}(x;θ)</script><p>例如，对于一个三分类的问题，一个样本的标签向量为 $𝒚 = [0, 0, 1]^{T}$，模型预测的标签分布为 $f(x;θ) = [0.3, 0.3, 0.4]^{T}$。<br>则它们的交叉熵为 $−(0 × log(0.3) + 0 ×log(0.3) + 1 × log(0.4)) = − log(0.4)$</p>
<h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><blockquote>
<p><strong>过拟合</strong><br>模型在训练集上错误率 很低，但是在未知数据上错误率很高，这就是所谓的过拟合。<br>过拟合的 3种 方法： 参数在过拟合之前就停止更新；正则化Regularization；<br>dropout</p>
<p><strong>欠拟合</strong><br>模型不能很好地拟合训练数据，在训练集上的错误率比较高．欠拟合一般是由于模型能力不足造成的。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/0bb493818f134cfe924b74c3f5e9a772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><h4 id="参数与超参数"><a href="#参数与超参数" class="headerlink" title="参数与超参数"></a>参数与超参数</h4><ul>
<li>参数：模型 𝑓(𝒙; 𝜃)中的 𝜃 称为模型的参数，可以通过优化算法进行学习</li>
<li>超参数：用来定义模型结构或优化策略的。 <font color="blue">常见的超参数有：聚类算法中的类别个数、梯度下降法中的步长、正则化项的系数、神经网络的层数、支持向量机中的核函数等 </font></li>
</ul>
<p>参数的优化一般都是由优化器优化，而超参数优化是机器学习的 一个经验性很强的技术 ，通常是按照人的经验设定，或者通过搜索的方法对一组超参数组合进行不断试错调整。</p>
<h4 id="批量梯度下降法"><a href="#批量梯度下降法" class="headerlink" title="批量梯度下降法"></a>批量梯度下降法</h4><p>缺点在于 局部最优问题<br>用下面的迭代公式来计算计算训练集 𝒟 上风险函数的最小值：<br><img src="https://img-blog.csdnimg.cn/4703fad601d345569a9950cc173f436d.png#pic_center" alt="批量梯度下降法"><br>𝛼 一般称为学习率（Learning Rate）．</p>
<blockquote>
<p>批量梯度下降法在  每次迭代时<strong>需要计算每个样本（也就是所有样本）</strong>上损失函数的梯度并求和。当训练集中的样本数量 𝑁 很大时，空间复杂度比较高，每次迭代的计算开销也很大．</p>
</blockquote>
<h4 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h4><p>缺点在于 局部最优问题，但相比于批量，更容易脱离局部最优</p>
<blockquote>
<p>为了减少每次迭代的计算复杂度，我们也可以在每次迭代时<strong>只采集一个样本</strong>，计算这个样本损失函数的梯度并更新参数，即随机梯度下降法。当经过足够次数的迭代时，随机梯度下降 也可以收敛到局部最优解。<br><img src="https://img-blog.csdnimg.cn/4770f90631bb4ef3aa53847f7242a206.png#pic_center" alt="随机梯度下降法"></p>
<h4 id="小批量梯度下降法"><a href="#小批量梯度下降法" class="headerlink" title="小批量梯度下降法"></a>小批量梯度下降法</h4><p><font color="red">现在 大规模的机器学习 常用这个。</font><br><strong>利用了计算机的并行计算能力</strong><br>每次迭代时，我们随机选取一小部分训练样本来计算梯度并更新参数，这样既可以兼顾随机梯度下降法的优点，也可以提高训练效率。<br><img src="https://img-blog.csdnimg.cn/36fa218d071f4a399d141fa6641232ae.png#pic_center" alt="小批量梯度下降法"></p>
<h1 id="机器学习的简单示例——线性回归"><a href="#机器学习的简单示例——线性回归" class="headerlink" title="机器学习的简单示例——线性回归"></a>机器学习的简单示例——线性回归</h1><p>自变量数量 为1时称为 <strong>简单回归</strong>， 自变量数量大于1时称为 <strong>多元回归</strong>．</p>
<script type="math/tex; mode=display">𝑓(𝒙; 𝒘) = 𝒘^{T}𝒙</script></blockquote>
<h2 id="不明白-先跳过"><a href="#不明白-先跳过" class="headerlink" title="不明白 先跳过"></a>不明白 先跳过</h2><h1 id="偏差-方差分解"><a href="#偏差-方差分解" class="headerlink" title="偏差- 方差分解"></a>偏差- 方差分解</h1><p>其用在，对如何对模型的拟合能力和复杂度之间取得一个良好的平衡，偏差与方差起这很好的分析和指导作用。</p>
<p>对于单个样本 𝒙，不同训练集 𝒟 得到模型 $𝑓_{D}(𝒙)$ 和最优模型 $𝑓^{*}(𝒙)$ 的期望  差距为：<br><img src="https://img-blog.csdnimg.cn/0568101873af46f9ac794e591d7cfb19.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>偏差：指一个模型在 <font color="red">不同训练集</font> 上的<strong>平均性能和最优模型的差异</strong>，可以用来衡量一个模型的<strong>拟合能力</strong></li>
<li>方差：一个模型在不同训练集上的差异 ，可以用来衡量一个模型是否容易过拟合 ．</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/99942f3b15814cacbb5dcfb5a53cb056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="机器学习模型的四种偏差和方差组合情况"><br>每个图的中心点为<br>最优模型 $𝑓^{*}(𝒙)$，黑点为不同训练集𝐷 上得到的模型 $𝑓_{D}(𝒙)$</p>
<ul>
<li>高偏差<strong>低方差</strong>的情况，表示模型的泛化能力很好，但<strong>拟合能力不足</strong></li>
<li>低偏差<strong>高方差</strong>的情况，表示模型的<strong>拟合能力很好</strong>，但泛化能力比较差．当训练数据比较少时会导致过拟合</li>
</ul>
<p>总结的来看：<br>模型在<strong>训练集</strong>上的错误率比较高时，说明模型的<strong>拟合能力不够</strong>，<strong>偏差比较高</strong>。这种情况可以通过</p>
<ul>
<li>增加数据特征</li>
<li>提高模型复杂度</li>
<li>减小正则化系数</li>
</ul>
<p>模型在训练集上的错误率比较低，但验证集上的错误率比较高时，说明模型过拟合，方差比较高．这种情况可以通过</p>
<ul>
<li>降低模型复杂度</li>
<li>加大正则化系数</li>
<li>引入先验</li>
<li>此外，还有一种有效降低方差的方法为<strong>集成模型</strong>，即通过多个高方差模型的平均来降低方差．</li>
</ul>
<h1 id="学习算法分类"><a href="#学习算法分类" class="headerlink" title="学习算法分类"></a>学习算法分类</h1><p>按照训练样本提供的信息以及反馈方式的不同，将机器学习算法分为以下几类：</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>机器学习的特征 𝒙 和标签 𝑦 之间可以用 数学模型表示出来，并且训练集中每个样本都有标签。（数据集标签一般都需要由人工进行标注，成本很高）<br>根据标签的类型还可以分为：</p>
<ul>
<li>回归。 标签 𝑦 与 模型的输出 都是连续值</li>
<li>分类。 标签 𝑦 是离散的类别（符号）。这种模型又叫做 分类器 。 分类问题可以分为 二分类 多分类。</li>
<li>结构化学习。 特殊的分类问题。标签 𝒚 通常是结构化的对象，比如序列、树或图等。 由于结构化学习的输出空间比较大，因此我们一般定义一个联合特征空间，将 𝒙 ,  𝒚 映射为该空间中的联合特征向量 𝜙(𝒙, 𝒚)，预测模型可以写为 <img src="https://img-blog.csdnimg.cn/e6f1ad9f44424166b35a7bf4def1dbb4.png#pic_center" alt="在这里插入图片描述"><br>其中 Gen(𝒙) 表示输入 𝒙 的所有可能的输出目标集合．计算 arg max 的过程也称为<strong>解码</strong>（Decoding）过程，一般通过<strong>动态规划</strong>的方法来计算。</li>
</ul>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 是指从不包含目标标签的训练样本中自动学习到一些有价值的信息。典型的无监督学习问题有 </p>
<ul>
<li>聚类</li>
<li>密度估计</li>
<li>特征学习</li>
<li>降维</li>
</ul>
<h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p> 是一类通过交互来学习的机器学习算法．在强化学习中，智能体根据环境的状态做出一个动作，并得到即时或延时的奖励．智能体在和环境的交互中不断学习并调整策略，以取得最大化的期望总回报．</p>
<h2 id="弱监督和半监督"><a href="#弱监督和半监督" class="headerlink" title="弱监督和半监督"></a>弱监督和半监督</h2><p>弱监督学习和半监督学习的方法，希望从大规模的无标注数据中充分挖掘有用的信息，降低对标注样本数量的要求。</p>
<p>强化学习和监督学习的不同在于，强化学习不需要显式地以“输入/输出对”的方式给出训练样本，是一种在线的学习机制。</p>
<h1 id="数据的特征表示"><a href="#数据的特征表示" class="headerlink" title="数据的特征表示"></a>数据的特征表示</h1><p><img src="https://img-blog.csdnimg.cn/deb2a7eee01647089fa86ebbd5f6acd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamtzODg5OTU2NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>需要将这些不同类型的数据转换为向量表示 。</p>
<p>如何选取有效的特征，具体可分为两种：特征选择和特征抽取。 <strong>传统的是和预测模型的学习分离的。</strong></p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>特征选择就是保留有用特征，移除冗余或无关的特征。<br>方法包括 子集搜索和 L1正则化 </p>
<h3 id="子集搜索"><a href="#子集搜索" class="headerlink" title="子集搜索"></a>子集搜索</h3><ul>
<li>过滤式方法：不依赖具体机器学习模型的特征选择方法。每次增加最有信息量的特征，或删除最没有信息量的特征。</li>
<li>包裹式方法（Wrapper Method）是使用后续机器学习模型的准确率作为评价来选择一个特征子集的方法．每次增加对后续机器学习模型最有用的特征，或删除对后续机器学习任务最无用的特征。</li>
</ul>
<h3 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h3><p>由于 L1 正则化会导致稀疏特征，因此间接实现了特征选择．</p>
<h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p> 构造一个新的特征空间，并将原始特征投影在新的空间中得到新的表示。 其方法分为 <strong>有监督和无监督</strong>两类。</p>
<ul>
<li><strong>监督</strong>的特征学习的目标是抽取对一个特定的预测任务最有用的特征，比如线性判别分析。</li>
<li><strong>无监督</strong>的特征学习和具体任务无关，其目标通常是减少冗余信息和噪声，比如<strong>主成分分析PCA</strong>和<strong>自编码器 AE</strong>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/502589206ad64f6898d51126bd9233ba.png#pic_center" alt="传统的特征选择和特征抽取方法"><br>特征选择和特征抽取的优点是可以用较少的特征来表示原始特征中的大部分相关信息，去掉噪声信息，并进而提高计算效率和减小维度灾难。<br>对于很多没有正则化的模型，特征选择和特征抽取非常必要。 经过特征选择或特征抽取后，特征的数量一般会减少，因此特征选择和特征抽取。 也经常称为<strong>维数约减或降维</strong>。</p>
<h1 id="模型的评价指标"><a href="#模型的评价指标" class="headerlink" title="模型的评价指标"></a>模型的评价指标</h1><ul>
<li>准确率（Accuracy）</li>
<li>错误率（Error Rate）： 1 - 准确率</li>
<li>查准率（Precision）</li>
<li>查全率（Recall）</li>
<li>F值（F Measure）</li>
</ul>
<h2 id="如何理解-精确率、召回率和F值"><a href="#如何理解-精确率、召回率和F值" class="headerlink" title="如何理解 精确率、召回率和F值"></a>如何理解 精确率、召回率和F值</h2><p>模型在测试集上的结果可以分为以下四种情况：<br>比如我们现在 预测标签 C</p>
<ul>
<li>真正例（TP）：样本的预测与实际标签相同</li>
<li>假负例（FN）：样本实际标签为C，模型预测错了</li>
<li>假正例（FP）：样本实际标签不是C，但模型预测成C了</li>
<li>真负例（TN）：样本实际为其他类，模型也预测为其他类</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/e157318baff446ce9215cf7854120df2.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h3><p>类别 𝑐 的查准率  是所有预测为 类别C 的样本中 预测正确  的比例<br>精确率 $P_{C}$ 的计算 公式为：</p>
<script type="math/tex; mode=display">P_{C} = \frac{TP_{c}}{TP_{c}+FP_{c}}</script><h3 id="查全率"><a href="#查全率" class="headerlink" title="查全率"></a>查全率</h3><p>类别𝑐的查全率 是所有真实标签为 类别𝑐 的样本中预测正确的比例：</p>
<script type="math/tex; mode=display">R_{C} = \frac{TP_{c}}{TP_{c}+FN_{c}}</script><h3 id="F值"><a href="#F值" class="headerlink" title="F值"></a>F值</h3><p>F值（F Measure）是一个综合指标，为精确率和召回率的调和平均：</p>
<script type="math/tex; mode=display">F_{C} = \frac{(1+β^{2})×P_{C}×R_{C}}{β^{2}×P_{C}+R_{C}}</script><p>其中 𝛽 用于平衡精确率和召回率的重要性，一般取值为1．𝛽 = 1时的F值称为 <strong>F1 值</strong>，是精确率和召回率的调和平均．</p>
<h2 id="宏平均和微平均"><a href="#宏平均和微平均" class="headerlink" title="宏平均和微平均"></a>宏平均和微平均</h2><p>为了计算分类算法在<strong>所有类别上的总体查准率、查全率和 F1值</strong>，经常使用两种平均方法，分别称为 宏平均 和 微平均</p>
<ul>
<li>宏平均是每一类的性能指标的算术平均值</li>
<li>微平均是每一个样本的性能指标的算术平均值</li>
</ul>
<h1 id="理论和定理"><a href="#理论和定理" class="headerlink" title="理论和定理"></a>理论和定理</h1><h2 id="PAC学习理论："><a href="#PAC学习理论：" class="headerlink" title="PAC学习理论："></a>PAC学习理论：</h2><p>指该学习算法能够在多项式时间内从合理数量的训练数据中学习到一个近似正确的𝑓(𝒙)．</p>
<h2 id="没有免费午餐定理"><a href="#没有免费午餐定理" class="headerlink" title="没有免费午餐定理"></a>没有免费午餐定理</h2><p>没有免费午餐定理   就是不存在一种机器学习算法适合于任何领域或任务。</p>
<h2 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h2><p>简单的模型泛化能力更好．如果有两个性能相近的模型，我们应该选择<strong>更简单的模型</strong>。<br>因此，在机器学习的学习准则上，我们经常会引入参数正则化来限制模型能力，避免过拟合．</p>
<h2 id="丑小鸭定理"><a href="#丑小鸭定理" class="headerlink" title="丑小鸭定理"></a>丑小鸭定理</h2><p>世界上不存在相似性的客观标准，一切相似性的标准都是主观的</p>
<h2 id="归纳偏置"><a href="#归纳偏置" class="headerlink" title="归纳偏置"></a>归纳偏置</h2><p>预测模型前，先假设。<br>比如在最近邻分类器中，我们会假设在特征空间中，一个小的局部区域中的大部分样本同属一类。<br>在朴素贝叶斯分类器中，我们会假设每个特征的条件概率是互相独立的。</p>
]]></content>
      <categories>
        <category>深度学习基础-邱锡鹏</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>邱锡鹏</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归Regression 案例一：宝可梦进化CP值</title>
    <url>/2021/07/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Regression%20%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%AE%9D%E5%8F%AF%E6%A2%A6%E8%BF%9B%E5%8C%96CP%E5%80%BC/</url>
    <content><![CDATA[<p>@<a href="线性回归Regression 案例一：宝可梦进化CP值">TOC</a></p>
<blockquote>
<p>本栗子：预测Pokemon精灵攻击力。<br>输入：进化前的CP值、物种（Bulbasaur）、血量（HP）、重量（Weight）、高度（Height）<br>输出：进化后的CP值</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d53b2b95d30c7af9574c7a0bbaba2c82.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="实现回归的步骤（机器学习的步骤）"><a href="#实现回归的步骤（机器学习的步骤）" class="headerlink" title="实现回归的步骤（机器学习的步骤）"></a>实现回归的步骤（机器学习的步骤）</h1><h2 id="Step1-确定一个model-线性模型"><a href="#Step1-确定一个model-线性模型" class="headerlink" title="Step1 确定一个model - 线性模型"></a>Step1 确定一个model - 线性模型</h2><blockquote>
<p>输入的特征包括：进化前的CP值（<em>Xcp</em>）、物种（Bulbasaur）（<em>Xs</em>）、血量（HP）（<em>Xhp</em>）、重量（Weight）（<em>Xw</em>）、高度（Height）（<em>Xh</em>）</p>
</blockquote>
<p>先从简单的<strong>单个特征</strong> 进化前的CP值（<em>Xcp</em>）开始（<strong>后面改进再考虑多个特征</strong>）。<br><img src="https://img-blog.csdnimg.cn/img_convert/5b4df493600379c7aa0372e103eb7d79.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Step2-goodness-of-function（函数优化）——损失函数"><a href="#Step2-goodness-of-function（函数优化）——损失函数" class="headerlink" title="Step2 goodness of function（函数优化）——损失函数"></a>Step2 goodness of function（函数优化）——损失函数</h2><ol>
<li>确定model后（案例为线性模型），开始训练数据（使用的为训练样本集）<img src="https://img-blog.csdnimg.cn/img_convert/ebd00bf7bee79841d6c35eac2865fd61.png#pic_center" alt="在这里插入图片描述"></li>
<li>训练10个训练样本后得到10个的预测进化CP值（<em>y</em>）如下图所示。左侧为训练样本本身真实的进化CP值，右侧为横轴为进化前CP值（<em>Xcp</em>）<img src="https://img-blog.csdnimg.cn/img_convert/fbba4351217b730cd11ca92a7427cd51.png#pic_center" alt="在这里插入图片描述"></li>
<li><strong>确定损失函数</strong>。损失函数用于评价一个模型的好坏。损失函数的值越小，那么模型越好。<strong>对于本案例，损失函数采用最简单的距离表示</strong>。即求<strong>实际进化后的CP值与模型预测的CP值差</strong>，来判定模型的好坏。<img src="https://img-blog.csdnimg.cn/img_convert/3abae7108681dbad20cc15a952d20bba.png#pic_center" alt="在这里插入图片描述"><ol>
<li>List item</li>
</ol>
</li>
</ol>
<h2 id="Step3-best-function（找出最好的一个函数-即调参）——使用梯度下降法"><a href="#Step3-best-function（找出最好的一个函数-即调参）——使用梯度下降法" class="headerlink" title="Step3 best function（找出最好的一个函数 即调参）——使用梯度下降法"></a>Step3 best function（找出最好的一个函数 即调参）——使用梯度下降法</h2><ol>
<li>案例采用<strong>梯度下降法</strong>来帮助选择 <em>w</em> 和 <em>b</em> 两个参数取何值时损失函数最小，也就意味着构建的模型越准确。 <img src="https://img-blog.csdnimg.cn/img_convert/7d75962cbe0b2dc3c54f370383912138.png#pic_center" alt="在这里插入图片描述"><blockquote>
<p>什么是梯度下降法？梯度指的是？<br>………………………………………………………………………………………………………<br>梯度？<br>在<strong>单变量的函数</strong>中，梯度其实就是对应点<strong>函数的微分</strong>，代表着这个函数在<strong>某个给定点的切线的斜率</strong><br>在<strong>多变量函数</strong>中，梯度是一个<strong>向量</strong>，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向  <strong>即例如二维就是 偏导 i + 偏导 j</strong><br>………………………………………………………………………………………………………<br>梯度下降法(SGD  Stochastic gradient descent）？答： “下山最快路径”的一种算法<br>我们是尝试使用偏导来衡量函数随自变量的值变化关系，选择变化更为平缓的那一处  对应的 <em>w</em> 和 <em>b</em> 作为调整后的参数</p>
</blockquote>
</li>
</ol>
<h3 id="一维视角：只考虑一个参数-w"><a href="#一维视角：只考虑一个参数-w" class="headerlink" title="一维视角：只考虑一个参数 w"></a>一维视角：只考虑一个参数 <em>w</em></h3><p><img src="https://img-blog.csdnimg.cn/3c72961665a942ac87f066a129a30183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>如上图  learning rate（学习率）：移动的步长 一般用η来表示<br>………………………………………………………………………………………………………<br>如何寻找一个最合适的 <em>w</em> ？<br>步骤1：随机在横轴上选取一个 <em>w0</em> 。<br>步骤2：计算微分，也就是当前的斜率，根据斜率来判定移动的方向。微分大于0应向右移动（增加 <em>w</em> ）；微分小于0向左移动（减少 <em>w</em> ）<br>步骤3：根据学习率，按步骤2得到的方向移动<br>重复步骤2和步骤3，直到找到<strong>最低点</strong>。横轴即对于的最佳 <em>w</em>  参数<br>………………………………………………………………………………………………………<br>如下图，是经过迭代多次后找到的最佳点（得是全局最优解） 。注：大部分损失函数都为正<br><img src="https://img-blog.csdnimg.cn/588186b690dd43c38a10a80600802ab0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="二维视角：考虑两个参数-w-和-b"><a href="#二维视角：考虑两个参数-w-和-b" class="headerlink" title="二维视角：考虑两个参数 w 和 b"></a>二维视角：考虑两个参数 <em>w</em> 和 <em>b</em></h3><p><img src="https://img-blog.csdnimg.cn/55f2f295750242bfa35f9ac576602194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如何寻找一个最合适的 <em>w</em> ？<br>步骤1：随机在横轴上选取一个 <em>w0</em> ，<em>b0</em> 。<br>步骤2：计算各偏导，也就是当前偏导的斜率，根据斜率来判定移动的方向。微分大于0应向右移动（增加 <em>w</em> 或 <em>b</em>）；微分小于0向左移动（减少 <em>w</em> 或 <em>b</em>）<img src="https://img-blog.csdnimg.cn/6a082b40869947c2a0723b298cd36027.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>步骤3：根据学习率，按步骤2得到的方向移动<br>重复步骤2和步骤3，直到找到<strong>最低点</strong>。横轴即对于的最佳 <em>w</em> 和 <em>b</em>  参数</p>
</blockquote>
<p>二维情况：梯度下降法的效果<br>颜色约深的区域代表的损失函数越小？ <strong>为什么呢？</strong><br><img src="https://img-blog.csdnimg.cn/299d0d615f6640a6ae092e51579d09ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="梯度算法的优缺点"><a href="#梯度算法的优缺点" class="headerlink" title="梯度算法的优缺点"></a>梯度算法的优缺点</h3><blockquote>
<p>总结一下梯度下降法：<br>　　　我们要解决使<strong>损失函数<em>L(w,b)</em></strong> 最小时参数的最佳值，梯度下降法是每次update参数值，直到损失函数最小时找到对应最佳的参数<em>w，b</em></p>
</blockquote>
<p><strong>缺点1</strong>：求解的未必是全局最优解，有可能是局部最优解。</p>
<blockquote>
<p><strong>用下山的例子讲</strong>：<br>　　　比如我们在一座大山上的某处位置，由于我们不知道怎么下山，于是决定走一步算一步，也就是在<strong>每走到一个位置的时候</strong>，<strong>求解当前位置的梯度</strong>，沿着<strong>梯度的负方向</strong>，也就是<strong>当前最陡峭的位置向下走一步</strong>，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。这样一步步的走下去，一直走到觉得我们已经到了山脚。当然这样走下去，<strong>有可能我们不能走到山脚，而是到了某一个局部的山峰低处。</strong><br>………………………………………………………………………………………………………<br>　　　从上面的解释可以看出，<strong>梯度下降不一定能够找到全局的最优解，有可能是一个局部最优解</strong>。当然，如果损失函数是<strong>凸函数</strong>，梯度下降法得到的解就<strong>一定是</strong>全局最优解。</p>
</blockquote>
<p><strong>优点1</strong>：无论随机从哪个点出发，得到的最佳参数一定是同一组</p>
<blockquote>
<p><strong>用下山的例子讲</strong>：<br>　　　因为山只有一处是最低点，在确保能找到全局最优解的情况下，无论人从山上哪一点出发，一定能找到这特定一处的最低洼处。</p>
</blockquote>
<h2 id="Step4-回归结果分析"><a href="#Step4-回归结果分析" class="headerlink" title="Step4 回归结果分析"></a>Step4 回归结果分析</h2><blockquote>
<p>经过上述三个步骤后，得到了<strong>训练后</strong>的“最佳参数<em>w</em>，<em>b</em>”，那么现在这个模型在<strong>测试集</strong>上是什么表现呢？<br>得到的结果是：<br><strong>测试集的误差比在训练集上得到的损失值大</strong> 这个事非常正常。因为你训练集里面可能有些数据是不典型的，同样测试集中很多也包含了训练集中没有的因素。所以一个函数模型在实际应用中，效果基本上时打折扣的。<strong>一般会采用两种方式来加强这个函数模型</strong>：<br>　　　select another model（选择另一个模型）即增加维度，增加高此项多项式<br>　　　consider the hidden factors（考虑其他隐藏因素）</p>
</blockquote>
<h3 id="优化模型方法一：增加高次项（一般用于拟合度不够的情况）"><a href="#优化模型方法一：增加高次项（一般用于拟合度不够的情况）" class="headerlink" title="优化模型方法一：增加高次项（一般用于拟合度不够的情况）"></a>优化模型方法一：增加高次项（一般用于拟合度不够的情况）</h3><p><strong>回到Step1</strong></p>
<ol>
<li>尝试二次项、三次项、四次项、五次项…… 右上图为训练集损失，下图是测试集的损失。第五次<strong>过拟合</strong>导致了，测试集损失度很高。<img src="https://img-blog.csdnimg.cn/c707638cef5c4d698813e6acfe4ec172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/ce26490bbfc64ea6967cd7b8e1e8184d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/166aef516df14c339c45fee48a78e16a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/87e7491ce6a1464dad4c023dc9004274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li><strong>选择合适的模型</strong>，即我到底要加到几次项呢？</li>
</ol>
<blockquote>
<p>越复杂的模型所包含的函数也就越多，那么它包含理想模型的可能性也就越大，但是如果过分地去拟合理想模型，就会出现<strong>过拟合</strong>的情况。<br><img src="https://img-blog.csdnimg.cn/6a394ba6b4a648a994472d8969668601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<ol>
<li>横向比较各个多项次，训练集和测试集的失误。理论上，失误会随着高次项而变小，如果变大，则表示模型<strong>过拟合</strong>了。<img src="https://img-blog.csdnimg.cn/979417ba98f6475d941753e0cb71b91c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以，如上图所示，在为3次的时候，训练集和测试集的误差差值最小。并且4次开始，以及存在过拟合现象了。因此本案例可选择3次项线性模型。</li>
</ol>
<h3 id="优化模型方法二：考虑其他隐藏因素"><a href="#优化模型方法二：考虑其他隐藏因素" class="headerlink" title="优化模型方法二：考虑其他隐藏因素"></a>优化模型方法二：考虑其他隐藏因素</h3><p><strong>回到Step1</strong></p>
<blockquote>
<p>输入的特征包括：进化前的CP值（<em>Xcp</em>）、物种（Bulbasaur）（<em>Xs</em>）、血量（HP）（<em>Xhp</em>）、重量（Weight）（<em>Xw</em>）、高度（Height）（<em>Xh</em>）<br>除了之前考虑的进化前的CP值（<em>Xcp</em>），其他均为隐藏因素<br>………………………………………………………………………………<br><strong>这里另外考虑的是神奇宝贝的种类</strong>？因为，有时候一个模型恰恰只能符合一种神奇宝贝，也就是<strong>不同神奇宝贝应该有不同的预测模型</strong>。<img src="https://img-blog.csdnimg.cn/72a4aadb2ba24aefb4584a8a8ca2801e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<ol>
<li>不同的神奇宝贝有不同的预测模型<img src="https://img-blog.csdnimg.cn/46fe5297bddb46a4bd511a7cea422e3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>拟合这个模型的曲线，可以看出不同神奇宝贝拟合成了不同的类线性直线<img src="https://img-blog.csdnimg.cn/7a55f95269d642038715e355437600f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>如果还考虑了其他隐藏元素。如图是横轴是对应的隐藏元素，纵轴是对应进化后的CP值。<img src="https://img-blog.csdnimg.cn/591a6aa5537443428687ba15886ab11d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>如果都采用最高二次项，考虑所有其他的隐藏因素。该案例的数学模型就变成 如图所示的式子。<img src="https://img-blog.csdnimg.cn/0a80407d715e4dcc978bd86dee3451a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><blockquote>
<p> 考虑更多的因素反而出现了过拟合的问题，<strong>说明有些因素跟本次实验的CP值预测没有关系</strong>！<br>………………………………………………………………………………<br><strong>过拟合这么讨厌，到底如何减少过拟合问题呢？往下看！</strong></p>
</blockquote>
</li>
</ol>
<h3 id="优化模型：防止过拟合（为损失函数加一个正则项）"><a href="#优化模型：防止过拟合（为损失函数加一个正则项）" class="headerlink" title="优化模型：防止过拟合（为损失函数加一个正则项）"></a>优化模型：防止过拟合（为损失函数加一个正则项）</h3><h4 id="正则项是什么"><a href="#正则项是什么" class="headerlink" title="正则项是什么?"></a>正则项是什么?</h4><blockquote>
<p><strong>方法：正则化</strong>?<br>比如先考虑一个参数w，正则化就是在损失函数上加上一个与w（斜率）相关的值（正则项），那么要是loss function越小的话，w也会越小，w越小就使function更加平滑（function没那么大跳跃）<img src="https://img-blog.csdnimg.cn/7a87a38ed54c438c8af37860e982f775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="正则化的缺点"><a href="#正则化的缺点" class="headerlink" title="正则化的缺点"></a>正则化的缺点</h4><p>正则化虽然能够减少过拟合的现象，但是因为加在损失函数后面的值是平白无故加上去的，所以正则化过度的话会导致<strong>bias偏差增大</strong>   ？？？？<img src="https://img-blog.csdnimg.cn/f4c9ea7efb144c8a89b7fee964b75fa8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1）实现参数的稀疏有什么好处吗？<br>一个好处是可以简化模型，避免过拟合。<strong>因为一个模型中真正重要的参数可能并不多，如果考虑所有的参数起作用，那么可以对训练数据可以预测的很好，但是对测试数据表现性能极差</strong>。另一个好处是参数变少可以使整个模型获得更好的可解释性。<br>2）参数值越小代表模型越简单吗？<br>是的。为什么参数越小，说明模型越简单呢，这是因为越复杂的模型，<strong>越是会尝试对所有的样本进行拟合，甚至包括一些异常样本点</strong>，这就容易造成在<strong>较小的区间里预测值产生较大的波动</strong>，这种较大的波动也反映了在这个区间里的<strong>导数很大</strong>，而<strong>只有较大的参数值才能产生较大的导数。因此复杂的模型，其参数值会比较大。</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/9dcfac9366564857a226de8d73bf512e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>李宏毅</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归 Logistic Regression</title>
    <url>/2021/08/05/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%20Logistic%20Regression/</url>
    <content><![CDATA[<p>@<a href="逻辑回归问题 Logistic Regression">TOC</a></p>
<p><strong>逻辑回归需要明白的几个问题？</strong></p>
<p>1、逻辑回归(Logistics Regression) 与 线性回归(Linear Regression)的区别在哪<br><img src="https://img-blog.csdnimg.cn/d50c9e51dfae4dadba381f980f05752a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2、生成模型(Generative Model) 与 判别模型(Discriminative Model）的区别在哪</p>
<ul>
<li>生成模型就是要学习 x 和 y 的联合概率分布 <em>P(x,y)</em>，然后根据贝叶斯公式来求得条件概率 <em>P(y|x)</em>，预测条件概率最大的 y。</li>
<li>判别模型就是直接学习条件概率分布 <em>P(y|x)</em>。</li>
</ul>
<p>3、逻辑回归(Logistics Regression) 与  深度学习（ VS Deep Learning）<br>逻辑回归具有缺陷，需要做特征工程来转变特征，但是这个人为步骤非常麻烦，所以引入了深度学习。</p>
<h1 id="逻辑回归与线性回归"><a href="#逻辑回归与线性回归" class="headerlink" title="逻辑回归与线性回归"></a>逻辑回归与线性回归</h1><h2 id="什么是逻辑回归？"><a href="#什么是逻辑回归？" class="headerlink" title="什么是逻辑回归？"></a>什么是逻辑回归？</h2><ul>
<li>逻辑回归是<strong>解决分类问题的一种算法</strong></li>
<li>它与 <strong>线性模型</strong> 形式上有点像（本质上是在线性模型外面“裹”一个<strong>sigmoid激活函数</strong>，来表示概率的函数）</li>
<li>它是一种<strong>判别模型</strong>，与前面说的生成模型不同</li>
<li>它是深度学习的基础</li>
</ul>
<h2 id="对比逻辑回归与线性回归"><a href="#对比逻辑回归与线性回归" class="headerlink" title="对比逻辑回归与线性回归"></a>对比逻辑回归与线性回归</h2><h3 id="区别一：模型不同"><a href="#区别一：模型不同" class="headerlink" title="区别一：模型不同"></a>区别一：模型不同</h3><p>本质上是在线性模型外面“裹”一个<strong>sigmoid激活函数</strong>，来表示概率的函数<br><img src="https://img-blog.csdnimg.cn/559dca41ef354a65b9e73ad4d8bb8222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2c3580835cbe4497a28537f12f972bf9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>总结的来看<img src="https://img-blog.csdnimg.cn/e591d052433d421da59cc20086e67959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="区别二：损失函数Loss不同"><a href="#区别二：损失函数Loss不同" class="headerlink" title="区别二：损失函数Loss不同"></a>区别二：损失函数Loss不同</h3><p><strong>逻辑回归的</strong><br><img src="https://img-blog.csdnimg.cn/81b9e6bbaf8743c8811b04dab97ae6cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>为什么似然函数最大，参数就越有可能，越合理？</strong><br>最大似然估计：现在已经拿到了很多个样本（你的数据集中所有因变量），这些样本值已经实现，最大似然估计就是去找到那个（组）参数估计值，使得前面已经实现的样本值发生概率最大。因为你手头上的样本已经实现了，其发生概率最大才符合逻辑。这时是求样本所有观测的联合概率最大化，是个连乘积，只要取对数，就变成了线性加总。此时通过对参数求导数，并令一阶导数为零，就可以通过解方程（组），得到最大似然估计值。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/d853c71170e743b58d68534399dbcd5a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/09f5eac31e1e4c90a1ca26b713423f2c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>总结一下：</strong><br><img src="https://img-blog.csdnimg.cn/c1c93acf9e1a46f9b6b3d821a168ebdf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>问题：为什么逻辑回归不采用线性回归的差平方来做？<br>例如，其实目前离目标点还很远，但梯度已经为0了，这显然不合理。<img src="https://img-blog.csdnimg.cn/2dee2450c8d34bf1b56a4e5c8d305db9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="区别三：如何调参的方式是一致的"><a href="#区别三：如何调参的方式是一致的" class="headerlink" title="区别三：如何调参的方式是一致的"></a>区别三：如何调参的方式是一致的</h3></blockquote>
<ul>
<li><strong>化简逻辑回归损失函数左侧部分</strong><br><img src="https://img-blog.csdnimg.cn/5a911af3aeb7475b832369858f503b7f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li><strong>化简逻辑回归右侧部分</strong><img src="https://img-blog.csdnimg.cn/c627e39a6c9348d0a3e81c0099430536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>化简，调参如下<img src="https://img-blog.csdnimg.cn/ccfda49ca7004f8f87fc76f238dd5337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://img-blog.csdnimg.cn/771e437cc99945d8b884f331f09132eb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h1><h2 id="什么是生成模型和判别模型？"><a href="#什么是生成模型和判别模型？" class="headerlink" title="什么是生成模型和判别模型？"></a>什么是生成模型和判别模型？</h2><p><strong>从本质上讲，生成模型和判别模型是解决分类问题的两类基本思路 。</strong><br><em>分类问题，就是给定一个数据 x，要判断它对应的所属标签 y</em></p>
<ul>
<li>生成模型就是要学习 x 和 y 的联合概率分布 <em>P(x,y)</em>，然后根据贝叶斯公式来求得条件概率 <em>P(y|x)</em>，预测条件概率最大的 y。</li>
<li>判别模型就是直接学习条件概率分布 <em>P(y|x)</em>。</li>
</ul>
<h2 id="两种模型案例-举个栗子？"><a href="#两种模型案例-举个栗子？" class="headerlink" title="两种模型案例 举个栗子？"></a>两种模型案例 举个栗子？</h2><blockquote>
<p>栗子1：<br>假设你从来没有见过大象和猫，连听都没有听过，这时，给你看了一张大象的照片和一张猫的照片。<br><strong>Q : 你看过之后，有人牵了一头真的大象过来，问你只是大象还是猫？</strong></p>
<ul>
<li>用<strong>判别模型</strong>的思路回答：你回想刚才看过的照片，大象比猫很明显有个长鼻子，所以眼前这个有着长鼻子的动物就是大象。</li>
<li><p>用<strong>生成模型</strong>的思路回答：你回想刚才看过的照片，然后用笔把它们画在了纸上，拿着纸和我家的大象做比较，你发现，眼前的动物更像是大象。</p>
<p>第一个解决问题的思路就是判别模型，<strong>因为你只记住了大象和猫之间的不同之处</strong>。第二个解决问题的思路就是生成模型，因为你<strong>实际上学习了什么是大象，什么是猫</strong>。</p>
</li>
</ul>
<p>栗子2：<br>有四个形式为(x,y)的样本。(1,0), (1,0), (2,0), (2,1）。假设，我们想从这四个样本中，<strong>学习到如何通过x判断y的模型</strong>。</p>
<ul>
<li>用生成模型，我们要学习 <em>P(x,y)</em>。如下所示：<img src="https://img-blog.csdnimg.cn/b435c974485141b1a36542a5c933ac01.png#pic_center" alt="在这里插入图片描述">我们学习到了四个概率值，它们的总和是1，这就是联合分布律P(x,y)。（因为这是离散的，连续的话叫联合概率密度）<ul>
<li>用判别模型，我们要学习 <em>P(y|x)</em>，如下所示：<img src="https://img-blog.csdnimg.cn/4bde84a64231412d951a1c7c31d180f1.png#pic_center" alt="在这里插入图片描述">因为这是条件分布律，每一行概率值相加都为1。</li>
</ul>
</li>
</ul>
<p><strong>Q : 当 <em>x=1</em> 时，请问 <em>y</em> 是 <em>0</em> 还是 <em>1</em> 呢？</strong></p>
<ul>
<li>用<strong>生成模型</strong>，我们会比较<br>P(x=1,y=0) = 1/2<br>P(x=1,y=1) = 0<br>我们发现 <em>P(x=1,y=0)</em>的概率要比 <em>P(x=1,y=1)</em>的概率大，所以，我们判断：<em>x=1时，y=0</em>。</li>
<li><p>用<strong>判别模型</strong>，我们会比较：<br>P(y=0|x=1) = 1<br>P(y=1|x=1) = 0<br>同样，<em>P(y=0|x=1)</em> 要比 <em>P(y=1|x=1)</em>大，所以，我们判断：<em>x=1时，y=0</em>。</p>
<p>我们看到，虽然最后预测的结果一样，但是得出结果的逻辑却是完全不同的。</p>
</li>
</ul>
</blockquote>
<h2 id="生成模型为啥叫生成模型？"><a href="#生成模型为啥叫生成模型？" class="headerlink" title="生成模型为啥叫生成模型？"></a>生成模型为啥叫生成模型？</h2><p>生成模型之所以叫生成模型，是因为：<br>它背后的思想是，x是特征，y是标签，什么样的标签就会生成什么样的特征。好比说，标签是大象，那么可能生成的特征就有大耳朵，长鼻子等等。<br>当我们来根据x来判断y时，我们实际上是在比较，<strong>什么样的y标签更可能生成特征x，我们预测的结果就是更可能生成x特征的y标签</strong>。</p>
<h2 id="为什么一般来说，判别模型表现得会比生成模型好？"><a href="#为什么一般来说，判别模型表现得会比生成模型好？" class="headerlink" title="为什么一般来说，判别模型表现得会比生成模型好？"></a>为什么一般来说，判别模型表现得会比生成模型好？</h2><p>我们举一个栗子，现在有Class1 和 Class2 两类数据。现在训练集数据如图所示：<img src="https://img-blog.csdnimg.cn/bd00dca74d524c1a83b9b90bb3745fcf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Q : 问请问如下的测试集，他是应该属于Class1 还是 Class2 呢？</strong><img src="https://img-blog.csdnimg.cn/a1ee9138baba426883e87dcd9b3f2358.png#pic_center" alt="在这里插入图片描述"><br>我们这边用判别模型来计算，算出如下图所示的数据：<img src="https://img-blog.csdnimg.cn/3f0b16520085492da2e7639d2646130c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>然后用贝叶斯公式算出 <em>P(C1 | x)</em> ，就是当x1和x2全为1 的情况下的概率是多少。<img src="https://img-blog.csdnimg.cn/a6f8b3138add4e2bbb548322591e0584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>算出的结果是 <em>＜ 0.5</em> 的，但从我们人的角度看，其实应该是属于Class1的，因为Class2里面压根就没有x1，x2同时为1的存在。<strong>这是为什么呢？因为我们的样本太少了，用判别模型是可以帮助我们在有限的数据样本中假象数据。</strong></p>
<blockquote>
<p><strong>那用生成模型怎么做呢？</strong></p>
</blockquote>
<p>所以判别模型的优势在于</p>
<ol>
<li>样本量少的时候表现比判别模型好，因为它能自己脑补出一个假想模型</li>
<li>噪声对它影响较小，因为它没有过分依赖数据，它是按照自己假想模型走的</li>
</ol>
<h2 id="常见的生成模型和判别模型有哪些呢？"><a href="#常见的生成模型和判别模型有哪些呢？" class="headerlink" title="常见的生成模型和判别模型有哪些呢？"></a>常见的生成模型和判别模型有哪些呢？</h2><p>生成模型</p>
<ul>
<li>HMM（隐马尔可夫模型）</li>
<li>朴素贝叶斯</li>
</ul>
<p>判别模型</p>
<ul>
<li>逻辑回归</li>
<li>SVM（支持向量机）</li>
<li>CRF（条件随机场）</li>
<li>最近邻</li>
<li>一般的神经网络</li>
</ul>
<h1 id="逻辑回归与深度学习"><a href="#逻辑回归与深度学习" class="headerlink" title="逻辑回归与深度学习"></a>逻辑回归与深度学习</h1><h2 id="逻辑回归解决多分类问题"><a href="#逻辑回归解决多分类问题" class="headerlink" title="逻辑回归解决多分类问题"></a>逻辑回归解决多分类问题</h2><p>逻辑回归是解决分类问题的，实际中的问题大多是多分类的问题，多分类问题会用到softmax。 <em>逻辑回归其实就是线性回归在外面加了个sigmoid激活函数（二分类）或者softmax激活函数（多分类）。</em></p>
<blockquote>
<p><strong>sigmoid激活函数 和 softmax函数的区别：</strong><br>通常在<strong>二分类</strong>中使用<strong>sigmoid作为最后的激活层</strong>。在<strong>多分类</strong>单标签中使用<strong>softmax作为激活层</strong>，取概率最高即可。多标签问题中使用sigmoid作为激活层，相当于把每一个类别都当成了二分类来处理。<img src="https://img-blog.csdnimg.cn/52837028507c423c97e4ba53a831270d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>多分类问题解决<br><img src="https://img-blog.csdnimg.cn/f92fa56ec4154bf687f88bc0192dcb08.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b674d12040f14c7dacc30b4a19f3af0b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="逻辑回归的局限性"><a href="#逻辑回归的局限性" class="headerlink" title="逻辑回归的局限性"></a>逻辑回归的局限性</h2><p><img src="https://img-blog.csdnimg.cn/d1fd15ed70b44e689619a1dfecaed0f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="用深度学习去解决这个问题"><a href="#用深度学习去解决这个问题" class="headerlink" title="用深度学习去解决这个问题"></a>用深度学习去解决这个问题</h2><p><img src="https://img-blog.csdnimg.cn/23f73c28c3f54fa19624a03839a18958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这个怎么变换过来的啊？</strong><br>是需要用特征工程的方法的，而特征工程是需要我们人为地去建立一个特征函数去把这些点转化，<strong>实际上是比较难的</strong>，或者说比较费工夫的<br>这个时候我们需要引入 <strong>深度学习</strong><br><img src="https://img-blog.csdnimg.cn/39cb9b68112d48e384f6958820a041c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>分类问题</tag>
        <tag>逻辑回归</tag>
        <tag>机器学习</tag>
        <tag>李宏毅</tag>
      </tags>
  </entry>
  <entry>
    <title>半监督学习 Semi-Supervised</title>
    <url>/2021/08/17/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%20Semi-Supervised/</url>
    <content><![CDATA[<p>@<a href="半监督学习 Semi-Supervised">TOC</a></p>
<blockquote>
<p>总结 半监督学习 的要点：<br>Q1：什么是Semi-Supervised？<br>Q2：Semi-Surpervised在生成模型中如何实现的（EM算法）？<br>Q3：Semi-Surpervised基于Low-density Separation（低密度分离）假设是如何实现的？<br>Q4：Semi-Surpervised基于Smoothness Assumption（平滑）假设是如何实现的？</p>
</blockquote>
<h1 id="什么是Semi-Supervised？"><a href="#什么是Semi-Supervised？" class="headerlink" title="什么是Semi-Supervised？"></a>什么是Semi-Supervised？</h1><p><img src="https://img-blog.csdnimg.cn/a671d2d30c944294a8b44fad632f7435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>大家知道在监督学习里，有一大堆的训练数据（由input和output对组成）。例如上图所示 $x^{j}$是一张图片，$y^{r}$ 是类别的 <em>label</em>。<br><strong>半监督学习是说，在label数据上面，有另外一组unlabeled的数据</strong>，写成$x^{u}$ (只有 input 没有 output )，有U笔 unlabeled 的数据。<br>通常做半监督学习的时候，我们常见的情景是 <strong>unlabeled 的数量远大于labeled 的数量</strong>（U&gt;&gt;R)。</p>
<blockquote>
<p><strong>举个栗子：现在我们要做一个猫狗分类</strong></p>
<ul>
<li>如果只考虑 labeled data，我们分类的分界线会画在中间；    </li>
<li>如果把 unlabeled data 也考虑进去，我们可能会根据 unlabeled data 的分布，分界线画成图中的斜线； 　<br>semi-supervised earning使用 unlabel 的方式往往伴随着<strong>一些假设</strong>，学习有没有用，取决于你这个<font color="red"><strong>假设合不合理</strong></font>。（比如灰色的点也可能是个狗不过背景跟猫照片比较像）<img src="https://img-blog.csdnimg.cn/994e98b4ab274acc8f394810b34dc7bf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
</blockquote>
<p>半监督学习可以分成两种：</p>
<ul>
<li>一种叫做<strong>转换学习</strong>，unlabeled 数据就是 testing set ，使用的是testing set的特征。</li>
<li>另一种是<strong>归纳学习</strong>，不考虑testing set，学习model的时候不使用testing set。</li>
</ul>
<blockquote>
<p><strong>Q：用 testing set 作为 unlabeled 数据，不是相当于用到了未来数据吗？</strong><br><strong>答</strong>：用了 label 数据才算是用了未来数据，用 testing set 的特征不算是使用未来数据。<br><strong>Q：什么时候使用转换学习或者归纳学习？</strong><br><strong>答</strong>：看 testing set是不是给你了。在一些比赛里，testing set 它是给你的，那么就可以使用转换学习。但在真正的应用中，一般是没有 testing set 的，这时候就只能做归纳学习。<br><strong>Q：为什么使用半监督学习？</strong><br><strong>答</strong>：缺少 lable 的数据，比如图片，收集图片很容易，但是标注label很困难。半监督学习利用未标注数据做一些事。<br><strong>Q：用沙雕的简单日常语言，讲一讲什么是 半监督学习</strong><br><strong>答</strong>：对人类来说，可能也是一直在做半监督学习，比如小孩子会从父母那边做一些监督学习，看到一条狗，问父亲是什么，父亲说是狗。之后小孩子会看到其他东西，有狗有猫，没有人会告诉他这些动物是什么，需要自己学出来。</p>
</blockquote>
<h1 id="Semi-Surpervised在生成模型中如何实现的（EM算法）"><a href="#Semi-Surpervised在生成模型中如何实现的（EM算法）" class="headerlink" title="Semi-Surpervised在生成模型中如何实现的（EM算法）"></a>Semi-Surpervised在生成模型中如何实现的（EM算法）</h1><p><img src="https://img-blog.csdnimg.cn/33bc117e72974fe68bb8635b54369078.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Q：在生成模型中为什么使用半监督学习？</strong><br><strong>答</strong>：在监督学习中，有一堆用来训练的样本（就是label），你知道它们分别属于类别1，还是类别2。会去估算类别1和类别2的先验概率<em>P(C1),P(C2)</em> ，然后计算类条件概率 <em>P(x|C1),P(x|C2)</em>  。<br>假设 <em>P(x|Ci)</em> 服从一个高斯分布。 假设类别1的数据是从均值为 <em>μ1</em>，协方差为 <em>Σ</em> 的分布中取出来的，而类别2的数据是从均值为 <em>μ2</em> ，协方差也为 <em>Σ</em> 的分布中取出来的（之前讲过共享协方差，效果会好一点）。<br>然后可以计算后验概率 <em>P(C1|x)</em> ，决定一个决策边界在哪里。<img src="https://img-blog.csdnimg.cn/81307014a68d4ae2a427e46e9212d4eb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果今天有一些未标注数据，如上图绿点，那仍然假设均值和方差是μ1,μ2,Σ显然不合理。<br>如上图左下所示，Σ应该比较接近圆圈（蓝色圆圈），也许在类1采样的时候有问题，所以采样到奇怪的分布（蓝色椭圆）。如上图右下，类2的μ2不应该在橙色椭圆内，而应该在更下面。<br>这样会使先验概率受到影响，本来两个分布，正例数据是一样多，但是加入未标注数据之后，你可能会觉得类2的正例数据更多（先验概率就更大）。总之加入未标注数据后，会影响对均值和协方差的估测，继而影响类条件概率，最后影响了你的决策边界。</p>
</blockquote>
<p>通俗的讲，回顾有监督学习中的生成模型，由于data都是有label的，<em>P(Ci)</em> 是已知的，<em>P(x|Ci)</em> 是通过我们基于高斯分布的假设用最大似然估计出来的；现在半监督学习中的生成模型，data的一部分是unlabel的，<em>P(Ci)</em> 是不确定的（隐变量），<em>P(x|Ci)</em>的假设模型也不能套用原来的 <em>u</em> 等参数，这时候需要用<font color="red"><strong>EM算法</strong>(Expectation-Maximization algorithm，又译为期望最大化算法)</font></p>
<h2 id="EM算法-具体怎么做"><a href="#EM算法-具体怎么做" class="headerlink" title="EM算法 具体怎么做"></a>EM算法 具体怎么做</h2><p>EM算法适用于带有无法观测的隐变量的概率模型估计<br>初始化一组参数，如果是二分类任务，就是初始化类1和类2的先验概率、均值和协方差，可以随机初始化，用已经有标注的数据估测，统称为 <em>θ</em></p>
<ul>
<li><strong>第一步（E步）</strong>，用labeled data算出来的高斯模型参数 <em>θ</em> 代入公式去求出每一笔未标注数据（unlabeled data）的后验概率（属于类1 的概率）的 <em>P(C1|Xu)</em>；</li>
<li><strong>第二步（M步）</strong>，用<strong>极大似然估计</strong>更新 <em>P(Ci)</em> 以及高斯模型参数 <em>θ</em> ，求出 <em>P(x|Ci)</em>，进一步求出新的后验概率 <em>P(Ci|Xu)</em> ，重复这两步直到收敛（似然概率最大）</li>
<li>至于为什么更新参数是要加入<em>P(Ci|Xu)</em> 这一项，是因为EM算法的思想是把不确定的data用一个概率来表示label，而每一笔不确定的data都有可能来自 类C1 和 类C2，看右下图：<img src="https://img-blog.csdnimg.cn/7035355bb99c4d298af9344cdfb7614c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="**加粗样式**在这里插入图片描述"></li>
</ul>
<blockquote>
<p>Q：EM 算法背后的理论是什么？<br>答：<strong>原来只有标注数据的时候</strong>，目标是最大化一个似然函数，那么给定θ，每一笔训练数据的似然函数值是可以计算的，然后把所有的似然函数值相加，就是总的似然函数值，然后找 <em>θ</em> 最大化。<em>θ</em> 有显式解，求最大值点（导数为0）。<br><strong>现在加入未标注数据后</strong>，我们不知道未标注数据来自哪一个类别，那么未标注数据出现的概率就是和  C1的联合概率+和C2的联合概率（相当于是$\sum<em>{C}P(x^{u},C^{i})$ 。接下来目标就是最大化 $P</em>{\theta }(x^{u})$ ，但是 $P_{\theta }(x^{u})$  的式子是非凸的，所以使用<strong>EM算法求解</strong>。<img src="https://img-blog.csdnimg.cn/5872e4d039e4413295b66b457cec8e23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<h1 id="Semi-Surpervised基于Low-density-Separation（低密度分离）"><a href="#Semi-Surpervised基于Low-density-Separation（低密度分离）" class="headerlink" title="Semi-Surpervised基于Low-density Separation（低密度分离）"></a>Semi-Surpervised基于Low-density Separation（低密度分离）</h1><p><img src="https://img-blog.csdnimg.cn/ea72d9a8bb3448088c224becd5be516f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>低密度分离的假设是，不确定的data的label要不是1，要不是0（“非黑即白”）。低密度的意思是，两个Class的分界处是低密度的（分得比较开的）</strong></p>
<blockquote>
<p><strong>Q：这个世界是非黑即白的，什么是非黑即白？</strong><br><strong>答</strong>：假设现在有一大堆的data，有标注数据，有非标注数据，在两个类别之间会有一个明显的鸿沟。给一些标注数据，可以把边界分在上图右边的线，也可以把边界分在上图左边的线。但是考虑非标注数据，那么左边的边界会好一点，在边界处，两个类别的密度是低的（不会出现data）</p>
</blockquote>
<h2 id="Self-training-Entropy-based-Regularization-基于熵的正则化"><a href="#Self-training-Entropy-based-Regularization-基于熵的正则化" class="headerlink" title="Self-training + Entropy-based Regularization(基于熵的正则化)"></a>Self-training + Entropy-based Regularization(基于熵的正则化)</h2><h3 id="self-training"><a href="#self-training" class="headerlink" title="self-training"></a>self-training</h3><p><img src="https://img-blog.csdnimg.cn/007143d015a34ef9b00537c7dfc0c066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>低密度分离最代表性、最简单的方法是self-training，非常直觉。</p>
<p>我们有一些标注数据，和一些未标注数据。接下来：</p>
<ul>
<li>从标注数据训练一个model   f* (用DNN，deep、shallow还是其他机器学习的方法都可以)</li>
<li>根据f*  标注未标注数据，丢入$x^{u}$ ，得到$y^{u}$  ，${(x^{u} ,y^{u} )}^{R+U}_{u=l}$ 叫做伪标签数据（称为Pseudo-label伪标签）</li>
<li>接下来，从伪标签数据集移除一些数据加到标注数据集（移除哪些数据需要自己决定，设计一些启发式的规则，或者给权重，有些数据的标签比较确定，那就给大的权重）</li>
<li>有了更多的标注数据之后，回头再去训练model f*</li>
</ul>
<blockquote>
<p><strong>Q：self-training在回归上有用吗？</strong><br><strong>回归问题用self-training不影响f∗，所以回归问题不能用self-training方法。</strong><img src="https://img-blog.csdnimg.cn/16b0c52a9a89411f80d53e91dc040f16.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>self-training 很像是刚才生成模型里面用的EM算法，唯一的差别是在做 self-training 的时候，用的是<strong>硬标签</strong>，生成模型里用的是<strong>软标签（概率）</strong>。在做 self-training 的时候，会强制分配一个数据属于某一个类别，在生成模型里，使用的是<strong>后验概率</strong>，部分属于类1，部分属于类2。</p>
</blockquote>
<h3 id="Entropy-based-Regularization-基于熵的正则化-—-self-training的进阶版"><a href="#Entropy-based-Regularization-基于熵的正则化-—-self-training的进阶版" class="headerlink" title="Entropy-based Regularization(基于熵的正则化) — self-training的进阶版"></a>Entropy-based Regularization(基于熵的正则化) — self-training的进阶版</h3><p><img src="https://img-blog.csdnimg.cn/26e158dbdc714533a4f0173142f2db23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>熵：一个事件的不确定程度</strong></p>
<p>Entropy-based Regularization（基于熵的正则化）是self-training的进阶版，self-training里用概率划分类别，可能觉得比较武断，那就可以用Entropy-based的这个方法。</p>
<p>Entropy-based是说，如果使用神经网络，output是一个分布，我们不去限制output具体属于哪一个类别，而是假设分布很集中（非黑即白的世界）。如上图，假设做5个类别分类的 model：</p>
<ul>
<li>第一个 类别1的概率为1，其他类别概率为0，是good</li>
<li>第二个 类别5的概率为1，其他类别概率为0，是good</li>
<li>第三个 所有类别的概率很平均，是bad，不符合<strong>低密度分离的假设（非黑即白）</strong></li>
</ul>
<blockquote>
<p><strong>Q：怎么用数值的方法评估分布是集中还是不集中？</strong></p>
<p><font color="red"><strong>使用熵，分布的熵告诉你集中还是不集中。可以用 每个类别的概率 乘以 log（每个类别的概率），再对类别个数求和取负数。 这个式子来评估。</strong> </font><br>这个其实就是理解成损失函数，因为这边讲究的是非黑即白，所以其实是一致的。损失函数 也可以用分布的距离来描述。<br>我们希望model的output在标注集上正确，在未标注集上的<strong>熵越小越好</strong>。</p>
<ul>
<li>第一个分布，熵为0，分布集中 <ul>
<li>第二个分布，熵也为0，分布集中 </li>
<li>第三个分布，熵为 ln(5) ，分布比较散</li>
</ul>
</li>
</ul>
<p>根据这个目标，重新设计损失函数。原来只是希望model在标注集上的output和label距离越近越好，用交叉熵来评估它们之间的距离。</p>
</blockquote>
<ul>
<li><strong>现在在原来的基础上，加上未标注集的output分布的熵。</strong></li>
<li>然后在未标注集部分乘上一个权重，来表明偏向标注部分还是未标注部分。</li>
<li>上图右下的损失函数可以算微分，那就使用<strong>梯度下降最小化这个损失函数</strong>，迭代求解参数。加入未标注部分，作用就类似于正则化（在原来损失函数后加一个L1正则或者L2正则），这里则加入一个未标注集熵来防止过拟合，所以称之为基于熵的正则化。</li>
</ul>
<h2 id="Semi-supervised-SVM（半监督SVM"><a href="#Semi-supervised-SVM（半监督SVM" class="headerlink" title="Semi-supervised SVM（半监督SVM)"></a>Semi-supervised SVM（半监督SVM)</h2><p><img src="https://img-blog.csdnimg.cn/ddbfa33ce3a4446581d49d9494a497ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Q：SVM 支持向量机（Support Vector Machine）是什么？</strong><br>SVM是找边界，给你两个类别的数据，SVM找一个边界，这个边界一方面要有最大的间隔（让两个class分的越开越好），一方面要有最小的分类错误。<br>如上图，假设现在有一些未标注数据，半监督SVM会穷举所有可能的label。<br>上图中，有四笔未标注数据，每笔数据既可以属于 class1，也可以属于 class2，可能的情况如上图右边所示（还有很多种其他的可能）。然后对每个可能的结果，都去做一个SVM，边界如上图红色线。然后再去找让间隔最大，错误最小的那一种结果。在例子里可能是黑色框这种结果。</p>
</blockquote>
<h1 id="Semi-Surpervised基于Smoothness-Assumption（平滑性）假设是如何实现的"><a href="#Semi-Surpervised基于Smoothness-Assumption（平滑性）假设是如何实现的" class="headerlink" title="Semi-Surpervised基于Smoothness Assumption（平滑性）假设是如何实现的"></a>Semi-Surpervised基于Smoothness Assumption（平滑性）假设是如何实现的</h1><h2 id="平滑性假设与高密度区域"><a href="#平滑性假设与高密度区域" class="headerlink" title="平滑性假设与高密度区域"></a>平滑性假设与高密度区域</h2><font color="red">假设：x的分布是不平均的，在某些地方很集中，在某些地方又很分散。如果 x1 和 x2 在一个高密度的区域很相似的话，两者的标签也会很像。</font>

<blockquote>
<p><strong>Q：什么叫在高密度区域下呢？</strong><br> 意思是说可以用高密度的路径做连接<img src="https://img-blog.csdnimg.cn/211207011e154abc9dc1609ad946223f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>举个例子，假设数据的分布如上图右边所示，像一个血轮眼。现在有3笔数据：x1,x2,x3，x1和x2中间是一个高密度区域（x1和x2由一个高密度区域连接），有很多数据(中间想成平原地带，地势平坦，人烟很多)，而x2和x3之间数据稀少(中间想成一座山，人烟稀少)，那么走平原会比走山容易，x2走到x1更容易（更相似）。</p>
</blockquote>
<p><strong>Q：举一个现实中，相似图形的栗子？为什么会有高密度区域假设？</strong><br>因为在真实情况下，这个假设成立的可能性很高。<br><img src="https://img-blog.csdnimg.cn/a7767f1d4ea04b788d2f9f17bfcec96f.png#pic_center" alt="在这里插入图片描述"><br>我们考虑手写数字识别的例子，有两个2一个3，如果计算像素点相似度的话，可能上图右边的2和3更像。但是从所有数据中看，<strong>左边的2到右边的2中间会有很多连续的形态</strong>。所以根据平滑度假设，左边的2和右边的2更像，因为右边的2和3之间没有过渡的形态。<br><img src="https://img-blog.csdnimg.cn/dfdb44a5a6af4aad901c4185bd21b74c.png#pic_center" alt="在这里插入图片描述"><br>看人脸识别也是一样的，比如左脸像和右脸像差很多，两个人的左脸像计算像素点相似度的话，可能比同一个人的两张侧脸像更高。但是如果收集到足够多的未标注数据，会找到两个侧脸像的很多过渡形态，根据高密度区域假设，这两张侧脸像就是同一个人。</p>
<p><img src="https://img-blog.csdnimg.cn/12dc2e73270c49b08efeee9c7c8c1d74.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>高密度区域假设，在文件上非常有用，假如现在要区分天文学和旅游的文章。</p>
<p>天文学的文章会出现asteroid、bright，而旅游的文章会出现yellowstone、zion。如果未标注文章和标注文章的词语有重叠，那可以很容易分类。但真实情况情况是，未标注文章和标注文章可能没有任何词语重叠，因为世界上的词语太多了，一篇文章词汇不会很多，每篇文章的词语是非常稀疏的。<br><img src="https://img-blog.csdnimg.cn/87bec6b6bb8c4603aacffd11ce899920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是收集到够多的数据的话，就可以说上图d1、d5像，d5、d6像，传播下去就可以说d1、d3是一类，d2、d4是一类。</p>
<h2 id="方法一：聚类，而后标注（图像上不太行）"><a href="#方法一：聚类，而后标注（图像上不太行）" class="headerlink" title="方法一：聚类，而后标注（图像上不太行）"></a>方法一：聚类，而后标注（图像上不太行）</h2><p><img src="https://img-blog.csdnimg.cn/45202fb11c71422c8437bdd3c23e91a5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Q：如何实践平滑度假设？</strong><br>最简单的方法是聚类、然后标记。<br>假如数据分布如上图，橙色是class 1，绿色是class 2，蓝色是未标注数据。接下来做聚类，可能把所有数据分成3个簇。在簇1里，class 1的label最多，那簇1里所有数据标记为class 1，同样的簇2和簇3都标记为class 2。把标记后的数据拿去learn就结束了。</p>
<p>这个方式不一定有用，因为要求簇正确，这个方法有效的假设是同一个class的东西聚集在一起。但是在图像里要把同一个class的东西聚集在一起没有那么容易。之前深度学习讲过，不同class的图像可能会很像，同一个class可能会不像，只用像素点做聚类，结果八成是不好的。没办法把同一个class的数据聚集在一起，那未标注数据就没有用。</p>
<p>所以要有用，就要有一个好的方法来描述一张图像，比如用 <em>Deep Autoencoder</em> 抽特征，然后再做聚类。</p>
</blockquote>
<h2 id="方法二：基于图的方法"><a href="#方法二：基于图的方法" class="headerlink" title="方法二：基于图的方法"></a>方法二：基于图的方法</h2><p><img src="https://img-blog.csdnimg.cn/95a83cefc106475f915f00fe756c317b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>另一个方法是引入图结构，来表达通过高密度路径进行连接这件事情。</p>
<p>把现在所有的数据点都建成一个图，每个数据点就是图上的一个点，想办法计算它们之间的奇点，想办法把它们之间的边建出来。</p>
<p><strong>所谓的高密度路径的意思是说，如果有两个点，在图上是相连的，那它们就是同一个class，如果没有相连，就算距离很近，也走不到。</strong></p>
<blockquote>
<p><strong>Q：生活中，如何构建图？</strong><br>有些时候，图的表示可以很自然的得到。</p>
<ul>
<li>举例说网页的分类，你有记录网页和网页之间的超链接，那超链接就很自然的告诉你网页是怎么连接的。</li>
<li>又举例论文的分类，论文和论文之间有引用的关系，这种引用的关系也是另外一种图的边，可以很自然地把这种图画出来。</li>
</ul>
</blockquote>
<h3 id="怎么自己想办法构建图？"><a href="#怎么自己想办法构建图？" class="headerlink" title="怎么自己想办法构建图？*"></a>怎么自己想办法构建图？*</h3><p>其实的图的好坏对结果的影响是非常严重的，但是自己用什么方法做还是很启发的，用自己觉得合适的方式做就可以了。 通常的做法是：</p>
<p>先定义两个对象之间的相似度，比如图像可以是基于像素点的相似度（可能效果不好），也可以是基于自动编码器抽取出来的特征计算相似度（效果可能好一点）</p>
<p>定义完相似度后，就可以构建图了（添加边），图有很多种：</p>
<ul>
<li>K近邻的图，现在有一大堆数据，可以计算数据与数据之间的相似度，然后设置k例如3，就是3个最相似的点相连</li>
<li>e-Neighborhood的图，只有相似度超过某个阈值的点才会相连</li>
</ul>
<p><strong>所谓的边也不是只有相连和不相连这两种选择，可以给边一些权重，让边跟两个数据点的相似度成正比。</strong>相似度可以用Gaussian Radial Basis Function来定义<img src="https://img-blog.csdnimg.cn/755264db6fe240d798d40d43d90ea95f.png#pic_center" alt=""></p>
<h3 id="怎么计算这个相似度"><a href="#怎么计算这个相似度" class="headerlink" title="怎么计算这个相似度"></a>怎么计算这个相似度</h3><p>可以先算xi,xj的欧式距离，乘以一个参数取负号，再取e为底的指数函数。取exp很有必要，在经验上最后效果比较好。因为取exp，下降速度很快，只有当xi,xj非常靠近时，奇点才会大，距离远一点奇点就会下降很快变得很小。这样才能制造如上图右下方所示的，两个距离近的橙色点有连接，绿色点和橙色点虽然距离也近，但是使用了exp导致只有很近很近的点才有连接，即使远一点点就不会有连接了，有这样的机制才能避免跨海沟的连接(橙色点和绿色点连接)。</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/f5e991680cf44ff08f79229892cd8926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>基于图的方法是，如果现在在图上面有一些标注数据，比如上图左上方，已经知道了蓝色圈的数据属于class 1，那么跟他们有相连的数据点属于class 1的概率也会上升。每一笔数据会去影响它的邻居。</p>
<ul>
<li>光会影响邻居还不够，因为有连接说明本来就很像，那很像的input<br> ，output本来也就很像。这种方法真正的精髓是，<strong>class是会传递的</strong>，虽然一个点没有与标注数据直接相连，但是有连接路径，那么class<br> 1就会随着边传递。<ul>
<li>例如上图右上方，所有数据点构建成一个图（理想的例子），然后有一个蓝色点属于class 1，一个红色点属于class 2。经过基于图的方法，蓝色点会传递，红色点也会传递，如上图右下方所示。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>要让基于图的这种半监督学习方法有用的话，一个重要的原则是你的数据要多，如果数据不够多，例如下图所示，中间有断开，那信息就传递不过去。</strong><img src="https://img-blog.csdnimg.cn/9ce410bae05d47f4b6a06931ef349d7a.png#pic_center" alt=""></p>
<h2 id="考试一般的考题，定量的计算图"><a href="#考试一般的考题，定量的计算图" class="headerlink" title="考试一般的考题，定量的计算图"></a>考试一般的考题，定量的计算图</h2><p>定量的使用方式是在这个图的结构上面定一个东西，叫做label的平滑度，来表明这个label有多符合平滑度假设。</p>
<h3 id="怎么定平滑度？"><a href="#怎么定平滑度？" class="headerlink" title="怎么定平滑度？"></a>怎么定平滑度？</h3><p><img src="https://img-blog.csdnimg.cn/42dc067087334546bbf3a44bdb7f9d88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>看上图两个例子，这两个例子都有4个数据点，数据点之间连接的数字代表了边的权重。现在给两个例子的数据不同的label，左边例子的label是1,1,1,0，右边例子的label是0,1,1,0，那谁更平滑呢？</p>
<p>直观感觉就是左边例子更平滑，但我们需要定量描述。常见的方法是，考虑两两相连的点（不管有label还是没有label），在所有的配对上，计算label差值的平方，然后乘上权重 ，最后求和。</p>
<p>所以左边这个例子的S就是0.5，右边例子的S是3，S越小越平滑。</p>
<h3 id="用矩阵来表达"><a href="#用矩阵来表达" class="headerlink" title="用矩阵来表达"></a>用矩阵来表达</h3><p><img src="https://img-blog.csdnimg.cn/3993d1ab2b6b4e79baeee94790c115f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>S可以稍微整理下，写成向量形式如上图。</strong></p>
<p>把y串成一个向量，y包括标注数据和未标注数据，所以有 R+U 维。</p>
<p><strong>L是<em>(R+U)×(R+U)</em>的矩阵，叫做图拉普拉斯，L的定义是 D−W ，W是两两数据点之间的权重，D是W每行值之和（放在对角线）。</strong></p>
<h3 id="再加一个正则化项"><a href="#再加一个正则化项" class="headerlink" title="再加一个正则化项"></a>再加一个正则化项</h3><p>现在可以用 y转置Ly 来评估现在得到的label有多平滑，<strong>式子里面的y是label的值，取决于神经网络的参数</strong>。那么如果要把平滑度考虑到神经网络里时，就是在原来的损失函数里加上λS（λ是某一个想要调的参数）。λS像一个正则化项，在调整参数时，不只是让标注数据的output跟真正的label越近越好，同时还要让output的label在标注数据和未标注数据上符合平滑度假设。平滑度假设由S衡量。</p>
<p>不一定要在output上计算平滑度，在深度神经网络里，可以把平滑度计算放在网络的任何地方。你可以假设你的output是平滑度，也可以把某个隐藏层乘上一些别的transform，它也要平滑，也可以要求每个隐藏层的output都是平滑的。</p>
<h3 id="转换的想法-Better-Representation"><a href="#转换的想法-Better-Representation" class="headerlink" title="转换的想法 Better Representation"></a>转换的想法 Better Representation</h3><p>我们观察到的世界其实是比较复杂的，在背后有一些比较简单的向量，比较简单的东西在操控这个复杂的世界。那只要看透假象，直指核心，就可以让学习变得比较容易。</p>
<p>例如上图右方剪胡子，胡子的变化是很复杂的，但是胡子受头操控，头的变化是有限的。所以胡子是观测，而头就是Better Representation。</p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络CNN（Convolutional Neural Network）</title>
    <url>/2021/08/12/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%EF%BC%88Convolutional%20Neural%20Network%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="卷积神经网络CNN（Convolutional Neural Network）">TOC</a></p>
<blockquote>
<p>总结CNN的要点：<br>Q1：什么是CNN？为什么要用CNN？为什么图像处理一般都采用CNN？<br>Q2：实现CNN的步骤？</p>
<p><font color="red">input——&gt;convolution——&gt;max pooling——&gt;…——&gt;flatten——&gt;fully connected network——&gt;output </font><br>Q3：如何用 <em>keras</em> 搭建一个CNN?<br>Q4：CNN的应用?什么时候适用CNN效果最好？<br>满足三个图像三个特性的时候。但要考虑第三点取子样是否合理。</p>
</blockquote>
<h1 id="CNN的概述"><a href="#CNN的概述" class="headerlink" title="CNN的概述"></a>CNN的概述</h1><h2 id="什么是CNN？"><a href="#什么是CNN？" class="headerlink" title="什么是CNN？"></a>什么是CNN？</h2><p>CNN也叫convnet，中文名称为卷积神经网络，是计算机视觉领域常用的一种深度学习模型。</p>
<h2 id="为什么要用CNN？"><a href="#为什么要用CNN？" class="headerlink" title="为什么要用CNN？"></a>为什么要用CNN？</h2><p>其可以简化DNN模型，可以减少不必要的神经元节点。特别是用在图像处理上。</p>
<h3 id="为什么图像处理一般都采用CNN？"><a href="#为什么图像处理一般都采用CNN？" class="headerlink" title="为什么图像处理一般都采用CNN？"></a>为什么图像处理一般都采用CNN？</h3><font color="green">**CNN的参数比全连接神经网络少得多**，为什么CNN只用较少的参数就可以用于处理图像呢？</font>

<p>这是因为图像具有以下三点特征：<br>1、一些模式比整张图片小得多，例如“鸟喙”就比整张图片小得多；<img src="https://img-blog.csdnimg.cn/1e9efb0804a64876a33e2794d96039a0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>2、同样的模式可能出现在图像的不同区域，例如“鸟喙”可能出现在图片的左上方也可能出现在图像的中间；<img src="https://img-blog.csdnimg.cn/c4a2de1adb4d4573865ec9f20b9e4a96.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>3、对图像的降采样不会改变图像中的物体。<img src="https://img-blog.csdnimg.cn/3e746d5fef0140029fe62095452d8389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>CNN的卷积层的设计对应着前两点，池化层的设计对应着第三点。</strong> 如下图所示：<br><img src="https://img-blog.csdnimg.cn/81dc5d9f161c47b4b7054b5964eda897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h1 id="实现CNN的步骤"><a href="#实现CNN的步骤" class="headerlink" title="实现CNN的步骤"></a>实现CNN的步骤</h1><p>input——&gt;convolution——&gt;max pooling——&gt;…——&gt;flatten（压平）——&gt;fully connected network——&gt;output</p>
<h2 id="卷积层（减少训练参数）"><a href="#卷积层（减少训练参数）" class="headerlink" title="卷积层（减少训练参数）"></a>卷积层（减少训练参数）</h2><p><img src="https://img-blog.csdnimg.cn/81dc5d9f161c47b4b7054b5964eda897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="CNN流程图"></p>
<ul>
<li><p>对应Property1：每一个Filter（待训练的参数，即卷积核）代表一个<strong>局部特征探测器</strong>（他是一个可以特点图形的表示器），假设现在两个特征探测器（<em>Filter1</em> 和 <em>Filter2</em>）</p>
<ul>
<li><p>卷积核1的结果 值最大的那个点所在的图片部分，就是我们要找的内容<br><img src="https://img-blog.csdnimg.cn/afe8e2823a47491bba71d054aa0ade85.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>卷积核2的结果。与卷积核1的结构共同组成了 feature map<img src="https://img-blog.csdnimg.cn/c3841af956b24b6d8721af30d207cb4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>对应Property2：用 <em>Filter1</em> 就能探测出在不同位置的同一个flatten，而不需要用不同的Filter</li>
</ul>
<p>如果图片是彩色的，也就是说它是三通道的，还没卷积之前，可以说有3个通道（RGB），意味着每一个像素由3个数值表示。如下图所示：<br>卷积核是立方体3×3×3，图片为9×9×3。图片中同样选择卷积核大小，与卷积核累和，但要注意我们并不是把RGB三层，分开算，应该算合为一体的。<img src="https://img-blog.csdnimg.cn/991470ca8069474fabd2088db993f9eb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="RGB卷积"></p>
<h3 id="与全连接方式的对比"><a href="#与全连接方式的对比" class="headerlink" title="与全连接方式的对比"></a>与全连接方式的对比</h3><p>全连接层，图像处理的神经网络图如下所示，每个输入与各神经元都有链接（有固定的权值）<img src="https://img-blog.csdnimg.cn/b34b02cb98274e53a6600a5c685d3674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="全连接层"><br>下面是CNN神经网络图，其主要的目的是减少参数（减少权值数量）。并且可以存在一定的共享权值，下面颜色相同的权值边值应该相同，这样调参可以更快。</p>
<p><img src="https://img-blog.csdnimg.cn/250d06b21d4546dea59a0a6502d3a3c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="CNN"></p>
<h2 id="池化层（Maxpooling）"><a href="#池化层（Maxpooling）" class="headerlink" title="池化层（Maxpooling）"></a>池化层（Maxpooling）</h2><p>目的是减少每一个特征的维度，也就是减少后面flatten的输入特征数量。Maxpooling这边我们取每个框内的最大点。<img src="https://img-blog.csdnimg.cn/f52e46c700fe492ab79a470370e223ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="Maxpooling的规程"><br>在整理一下，变成一个新的feature map</p>
<p>合计上两步得到：<br><img src="https://img-blog.csdnimg.cn/8065213d0fff4e30b41d596b0cde4d65.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>做一次卷积+池化后，把原来的 <em>6 × 6</em> 图像变成了 <em>2 × 2</em> 图像，<em>2 × 2</em>图像的深度（每个像素点用多少个值表示）<strong>取决于有多少个过滤器，如果有 <em>50</em> 个过滤器，<em>2 × 2</em> 图像就有 <em>50</em> 维</strong>，上图是只用两个过滤器，那就是 <em>2</em> 维。<br>所以上图右边，就是一个新的比较小的图像，每个过滤器代表了一个channel(通道)。</p>
<h2 id="重复上两步操作"><a href="#重复上两步操作" class="headerlink" title="重复上两步操作"></a>重复上两步操作</h2><p>可多次重复上述两个步骤，将输出的结果变得最小化。</p>
<blockquote>
<p><strong>Q: 假设我们第一次卷积的时候，我们有25个卷积核，那输出的结果 feature map中应该有25个矩阵。那请问，第二次卷积的时候，输出的feature map 应该是 25×25=625 个矩阵么？</strong><br>答：不对，做完第一次卷积得到25个矩阵，做完第二次后还是25个矩阵。例如输入是三个通道 <em>(RGB)</em> 的 <em>6 × 6</em> 矩阵数据（即一个立方体，6 × 6  × 3），有两个过滤器（也是立方体，三个通道，<em>3 × 3 × 3</em>），则输出为<em>4  × 4 × 2</em>。（<em>4 = 6-2 ； 2</em>是过滤器个数  <strong>过滤器决定通道数</strong>）<img src="https://img-blog.csdnimg.cn/a4aeaa3dd23d4ff48bce2e89c97553c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/e634fad522fe498a9b5cb04557fe7a05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="Flatten（压平）"><a href="#Flatten（压平）" class="headerlink" title="Flatten（压平）"></a>Flatten（压平）</h2><p><img src="https://img-blog.csdnimg.cn/699741afda84434985ef450ad1cffeea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="Flatten"><br>flatten(压平)的意思是，把特征图拉直，然后丢到一个全连接神经网络里。</p>
<h1 id="CNN-in-Keras"><a href="#CNN-in-Keras" class="headerlink" title="CNN in Keras"></a>CNN in Keras</h1><ul>
<li>卷积前，一个pixel用多少个数值表示，取决于通道数</li>
<li>卷积后，一个pixel用多少个数值表示，取决于Filter个数，而通道数决定Filter的高</li>
<li>上一个卷积层有多少个Filter，下一层卷积input就有多少个通道<br><img src="https://img-blog.csdnimg.cn/75db9d57e892418d9c68b6d52c714c4b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/686fdcfd5a734bfa998f6d84def07fea.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(<span class="number">25</span>,<span class="number">3</span>,<span class="number">3</span>),input_shape=(<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">model.add(MaxPooling2D((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Conv2D(<span class="number">50</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">model.add(MaxPooling2D((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Dense(output_dim=<span class="number">100</span>))</span><br><span class="line">model.add(Activation(<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(output_dim=<span class="number">10</span>))</span><br><span class="line">model.add(Activation(<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Q：为什么上图第二次 每个卷积核的 参数是 225？</strong><br>答：因为是 3×3×25  那为什么是25而不是50呢？</p>
</blockquote>
<h1 id="CNN在学什么？"><a href="#CNN在学什么？" class="headerlink" title="CNN在学什么？"></a>CNN在学什么？</h1><h2 id="CNN卷积和池化部分在做什么？"><a href="#CNN卷积和池化部分在做什么？" class="headerlink" title="CNN卷积和池化部分在做什么？"></a>CNN卷积和池化部分在做什么？</h2><p><img src="https://img-blog.csdnimg.cn/919125d4f1964cb9b520a639ed94e2e6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>分析第一个层的卷积核是比较容易的，里面每个卷积核就是一个3 <em> 3 的矩阵，对应3 </em> 3 范围内的9个像素点，<strong>只要看到矩阵的值，就知道在检测什么</strong>（有明显的特征）。</li>
<li>第二层的卷积核没法知道在做什么，虽然也是 <em>3 × 3</em> 的矩阵，总共 50 个。<strong>但是这些卷积核的输入不是像素点，而是在上一层做完卷积和池化后的输出</strong>。就算知道第二层卷积核的矩阵值，也不知道在检测什么。<strong>另外第二层卷积核考虑的不是原图 <em>3 × 3</em> 的像素点，而是比原图 <em>3 × 3</em> 像素点更大的范围，因为在第一层的池化后，压缩了原图 <em>3 × 3</em> 的区域，第二层卷积核是在压缩后的图像里再选取 <em>3 × 3</em>  像素点，相当于扩大了原图检测的范围。</strong></li>
</ul>
<blockquote>
<font color="red">Q：那怎么分析第二层卷积核在做什么？</font>

<p>第二层的50个卷积核，每个卷积核的输出是一个 <em>11 × 11</em> 的矩阵。把第k个卷积核输出拿出来如上图左下，矩阵元素表示为  $a_{ij}^{k}$  (第k个卷积核，第i个行，第j个列)。接下来 定义一个“<em>Degree of the activation of the k-th  filter</em>”（第k个卷积核的激活程度），值代表第k个卷积核的被激活程度（<strong>input和第k个卷积核侦测的东西有多匹配</strong>）。</p>
<p>第k个卷积核被激活程度表示为：$a^{k}=\sum<em>{i=1}^{11}\sum</em>{j=1}^{11}a_{ij}^{k}$ ，<em>11 × 11</em> 矩阵所有元素值之和。</p>
<p><strong>Q：找一张图像，可以让第k个卷积核被激活程度最大，如果做到这件事情？</strong><br><strong>称 <em>input</em> 的图像为 <em>x</em>，目标是找一个让 $a^{k}$ 最大的 <em>x</em>，如何找到这个 <em>x</em>？</strong></p>
<p><font color="red">使用梯度上升</font>，因为我们的目标是最大化 $a^{k}$  。现在是把 <em>x</em> 当做我们要找的参数，对 <em>x</em> 用梯度上升。原来CNN的 <em>input</em> 是固定的，<em>model</em> 的参数使用梯度下降求解。现在反过来，<em>model</em> 的参数是固定的，使用个梯度上升更新 <em>x</em>，让被激活程度最大。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/b5522ea6a04d49bfa39a3f94db140610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">上图左下，是随便取12个卷积核后对 <em>x</em> 做梯度上升后的结果，每个卷积核都找到一张图像，这张图像让这个卷积核的被激活程度最高。如果有50个卷积核，理论上可以找50张图像。</p>
<blockquote>
<p><strong>Q：这12张图像有一个共同的特征：是某种纹路在图上不断反复。为什么会这样？</strong><br>看第三张图像，都是小小的斜条纹，这意味着第三个卷积核是在检测是否有斜的条纹。因为卷积核考虑的范围是很小的，所以原图像上任何地方出现一个小小的斜纹的话，这个卷积核（过滤器）就会被激活，输出值就会很大。如果原图像所有范围都是这种小小的条纹，那这个卷积核的被激活程度就最大。</p>
</blockquote>
<p>你会发现每个过滤器都是在检测某一种图案（某一种线条），例如上图左下第3个过滤器是检测斜条纹，第4个是检测短、直的线条，第6个是检测斜成一定程度的线条等等。</p>
<font color="red">每个卷积核（过滤器）都在检测不同角度的线条。</font>

<h2 id="全连接的隐藏层都在干什么？"><a href="#全连接的隐藏层都在干什么？" class="headerlink" title="全连接的隐藏层都在干什么？"></a>全连接的隐藏层都在干什么？</h2><p><img src="https://img-blog.csdnimg.cn/cc01d0cb741b4bab93047f401e34b40f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>做完卷积和池化后，会做flatten(压平)，把压平后的结果丢到神经网络里去。</p>
<blockquote>
<p><strong>Q：在这个神经网络的隐藏层里，每个神经元都在干什么？</strong><br>答：如法炮制之前的做法，定义第 <em>j</em> 个神经元的输出是 $a<em>{j}$ ，然后找一张图像 <em>x</em>，使 $a</em>{j}$ 最大。<br>找到的图像如上图左下所示，9张图像，是对应神经元的输出最大。你会发现跟刚才卷积核（过滤器）观察的图案很<strong>不一样</strong>，<font color="red"><strong>卷积核观察的是类似纹路的东西，因为卷积核只考虑了原图像的一部分区域</strong></font>。<br><strong>输出通过压平后，现在每个神经元是去看整张图像</strong>，能使神经元激活程度最高的图像不再是纹路这种小图案，而是一个完整的图形，虽然看起来完全不像是数字，但神经元被激活后也的确在侦测一个完整的数字。</p>
</blockquote>
<h2 id="考虑最后的输出？"><a href="#考虑最后的输出？" class="headerlink" title="考虑最后的输出？"></a>考虑最后的输出？</h2><p><img src="https://img-blog.csdnimg.cn/c02bf451565e4f01bacf11dc6922219c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果最后的输出是10维的，每一维对应一个数字。把某一维拿出来，找一张图像使那个维度的输出最大。例如现在要找一张图像，使输出层上对应数字1的神经元的输出最大，理论上这张图像看起来就是数字1<br>但是实际的图像如上图左边所示，每张图像分别代表0,1,2,3,4,5,6,7,8</p>
<blockquote>
<p><strong>Q：那为什么是这种是乱七八糟的雪花状呢，而不是我们能看清的数字呢？</strong><br>答：因为神经网络的视角，他就是和人不一样的。他就认为这些雪花图像是不一样的，对于0-8数字。与我们人的思维不同。<br><img src="https://img-blog.csdnimg.cn/f84a6c6c9e4c468a805407e8bfee004c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Q：能不能让这些图像看起来更像数字？</strong><br>我们知道，一张图像是不是一个数字，有一些基本的假设。比如上图左边，人类看起来显示不是数字。那么我们对x做一些<strong>正则项约束</strong>，告诉机器，虽然有些 <em>x</em>（图像） 可以让  <em>y</em>  很大，但是这些 <em>x</em> 的确不是数字。<br><strong>Q：那加些什么约束呢？</strong><br>比如最简单的想法，图像上的白点是有墨水（笔画）的地方，对一个数字来说，有白点的部分是有限的，数字的笔画只占图的一小部分，所以我们要对 <em>x</em> 做一些限制。<br>假设 $x<em>{ij}$ 是图像像素点的值，每张图像有 <em>28 × 28</em> 个像素点。<strong>把所有像素点的值取绝对值并求和（相当于L1正则）</strong>，我们希望找一个 <em>x</em> ，让 $y</em>{i}$ 越大的同时，也让像素点绝对值之和越小。那我们找出来的图像大部分的地方就不是白色的。<br>最后得到的结果如上图右边所示，和左边的图看起来，已经可以隐约看出来是个数字了。</p>
</blockquote>
<h1 id="CNN的应用"><a href="#CNN的应用" class="headerlink" title="CNN的应用"></a>CNN的应用</h1><h2 id="Deep-Dream"><a href="#Deep-Dream" class="headerlink" title="Deep Dream"></a>Deep Dream</h2><p>你给机器一张图像，<strong>机器会在这张图像里面，加上它学习到的东西</strong>。<br><img src="https://img-blog.csdnimg.cn/b3c9858f5d9849d8995dd1183150f92e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>比如把上图丢到CNN里面去，然后把某个卷积核或者某个全连接隐藏层拿出来（一个向量），假设是 $\begin{bmatrix}<br>3.9\<br>-1.5\<br>2.3\<br>:\<br>\end{bmatrix}$</p>
<p>然后把3.9、2.3调大（本来是正的值调大），-1.5调小（负的值调小），正的更正，负的更负。找一个图像使卷积核或者隐藏层（拿出来的）的输出是调整后的向量。<strong>这么做的意思是让CNN夸大化它看到的东西。</strong><br><img src="https://img-blog.csdnimg.cn/0884c7de1c4e44b2ae5e302590b5ee18.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>找到的图像会变成上图所示，出现很多奇怪的东西。右边看起来是一头熊，原来是一颗石头。对机器来说，本来就觉得石头像一头熊，强化它的认知后，就学习出来更像一头熊的图案。这个就是Deep Dream。</p>
<h2 id="Deep-Style"><a href="#Deep-Style" class="headerlink" title="Deep Style"></a>Deep Style</h2><p><em>input</em> 一张图像，然后让机器去修改这张图像，让它有另一张图的风格，比如让上图看起来是呐喊。<br><img src="https://img-blog.csdnimg.cn/153f1e11b39943d8b64e7f352c289410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/952a46ca31584df885c1722e5f79912d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Q：卷积核和过滤器的区别</strong></p>
<ul>
<li><p>卷积核就是由<strong>长和宽</strong>来指定的，是一个<strong>二维</strong>的概念。</p>
<ul>
<li>过滤器是是由<strong>长、宽和深度</strong>指定的，是一个<strong>三维</strong>的概念。</li>
<li>过滤器可以看做是卷积核的集合。</li>
<li>过滤器比卷积核高一个维度——深度。</li>
</ul>
<p>——————————————————————————————————</p>
</li>
</ul>
<p><strong>Q：怎么做到图像风格转变呢？</strong><br><strong>把原来的图像丢给CNN，得到CNN过滤器的输出，代表一张图像里有什么样的内容</strong>。 然后把呐喊这张图也丢到CNN里，也得到过滤器的输出，但这时候考虑的不是过滤器输出的绝对值，而是考虑<strong>过滤器和过滤器输出之间的关系</strong>，<strong>这个关系代表了一张图像的风格</strong>。接下来用同一个CNN找一张图像，这张图像的内容像原图像的内容（过滤器的输出类似），同时这张图像的风格像呐喊的风格（过滤器输出之间的关系类似）。<br><strong>找一张图片同时<font color="red">最大化</font>内容和风格（使用<font color="red">梯度上升更新参数</font>），得到的结果就像两张图片结合一样。</strong></p>
</blockquote>
<h2 id="CNN应用在围棋上"><a href="#CNN应用在围棋上" class="headerlink" title="CNN应用在围棋上"></a>CNN应用在围棋上</h2><p><img src="https://img-blog.csdnimg.cn/d2233ab8dcdf4ca8ad1e4dc4ebf550b6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>要让机器下围棋，不一定要用CNN，一般的神经网络也可以做这件事情。只要学习一个网络，也就是找一个函数，输入是棋盘，输出是棋盘上的位置，根据棋盘的盘势，判断下一步落子的位置。<br>输入是<em>19 ×19</em> 向量，向量每一维是棋盘上的一个位置（是黑子则值为1，是白子则值为-1，反之则为0），丢到一个全连接的神经网络，输出也是<em>19 ×19</em> 的向量（每一维对应棋盘一个位置），那这样机器就可以学会下围棋了。</p>
<h3 id="为什么CNN可以用在下围棋上？"><a href="#为什么CNN可以用在下围棋上？" class="headerlink" title="为什么CNN可以用在下围棋上？"></a>为什么CNN可以用在下围棋上？</h3><p>但实际采用CNN会得到更好的效果！为什么呢？<br>之前举的例子都是把CNN用在图像上面，<em>input</em> 是一个矩阵。用到下棋上，只要把 <em>19 ×19</em>  的向量表示为 <em>19 ×19</em>  的矩阵。对CNN来说，<strong>就是把棋盘和棋子当成一个图像，然后输出下一步落子的位置</strong>。</p>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/604669df79b5475aa23db1f14d14b3e5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>收集很多棋谱，告诉CNN，看到落子在5之五，输出天元的位置为1，其他位置为0<br>看到5之五和天元都有棋子，输出就是5之五的位置为1，其他位置为0<br>这个是监督的部分，AlphaGo还有强化学习的部分</p>
</blockquote>
<h2 id="总结一下什么时候用CNN-为什么围棋适用？"><a href="#总结一下什么时候用CNN-为什么围棋适用？" class="headerlink" title="总结一下什么时候用CNN?为什么围棋适用？"></a>总结一下什么时候用CNN?为什么围棋适用？</h2><p><strong>图像要有该有的特性，开头讲过的根据<font color="red">三个特性</font>设计出了CNN的网络结构，在处理图像的时候特别有效。</strong></p>
<blockquote>
<p><strong>Q：为什么围棋很适用CNN？</strong><img src="https://img-blog.csdnimg.cn/36ddc9027bbe4537b72ff41a6553c1dd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>答：因为围棋有一些特性和图像处理是很相似的。</p>
<p><font color="red">围棋是有图像的第一个和第二个特性</font></p>
<ul>
<li><p><strong>在一张图像上面，有一些图案是比整张图像小的，比如鸟嘴。在围棋也有同样的现象</strong>，比如看到一些棋子摆放的图案，就要做一些相应的事情（比如上图黑子叫吃的时候，白子要落在下方保证不被吃）。不需要看整个棋盘，只需要看一个小小的范围，就可以侦测白子是不是属于被叫吃的状态。<br>AlphaGo里第一层的过滤器就是用的 5 × 5 过滤器，显然设计这个过滤器的人觉得围棋上最基本的图案在 5 × 5 范围内就可以被侦测出来。</p>
</li>
<li><p>图<strong>像还有个特性是相同的图案会出现在不同的区域，在围棋上也有同样的特征。</strong>例如叫吃的图案，可以出现在棋盘左上角，也可以出现在棋盘右下角，图案代表了同样的意义（叫吃），所以可以用同一个检测器来处理这些在不同位置的图案。</p>
</li>
</ul>
<p>Q：困惑的是图像的第三个特性，对原图像做子采样不会影响人看到的这张图像的样子，基于第三个特性有了池化层，但Alpha<br>并没有采用池化层（就是做子采样）？<br><strong>因为不能做子采样。比如丢弃棋盘的奇数行和偶数列，想想也应该是不可以的。</strong></p>
<p>也许AlphaGo里的CNN架构有特殊的地方。AlphaGo论文附录里描述了它的网络结构，input是一个<em>19 ×19 ×48</em> 的图像，<em>19<br>×19</em> 是棋盘可以理解，<strong>但48是怎么来的？</strong><br>对AlphaGo来说，把每一个位置都用48个值来描述（卷积后有48个通道）。本来我们只要描述一个位置是不是白子、黑子就可以了，而AlphaGo加上了领域知识（看这个位置是不是出于叫吃的状态等等）。</p>
<p>AlphaGo有做zero padding(零填充)，在原来<em>19 ×19</em> 的图像外围补上 <em>0</em> 值变成 <em>23 × 23</em> 的图像，第一层用的是 <em>5 × 5</em> 过滤器，总共 <em>k</em> 个过滤器（paper里用的是192个过滤器），步长<em>stride=1</em>，有用到 <em>ReLu</em> 作为激活函数，有2到12层的过滤器层，最后变成 <em>21 × 21</em> 的图像，接下来再使用 <em>3 × 3</em> 的过滤器，步长 <em>stride=1</em>。最后发现AlphaGo没有使用池化，针对围棋特性设计CNN结构的时候，是不需要池化这个结构的。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
        <tag>卷积核</tag>
        <tag>过滤器</tag>
        <tag>Maxpooling</tag>
      </tags>
  </entry>
  <entry>
    <title>同济子豪兄 之 yolov2 详解</title>
    <url>/2021/10/06/%E5%90%8C%E6%B5%8E%E5%AD%90%E8%B1%AA%E5%85%84%20%E4%B9%8B%20yolov2%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>@<a href="同济子豪兄 之 yolov2 详解">TOC</a></p>
<font color="blue">蓝色： 表示还不明白什么意思</font> 

<p>v1存在 一些性能和原理上的问题：</p>
<ol>
<li>mAP相比 R-CNN 系列比较低</li>
<li>定位性能比较差，定位错误占总错误的比例很大</li>
<li>Recall比较低，就是把全部目标全部检测出来的能力比较差</li>
<li>检测密集和小目标的能力比较差</li>
</ol>
<p>这篇文章其实主要有两个模型，即Yolov2 和 Yolo9000. 9000这个只是一个想法，不太实用。<br>Yolov2 是在此基础上做了很多的 tricks，作者分别归为了三个类，分别是Better（更准确），Faster（更快的），Stronger（类别更多的）。其中Stronger这块 作者说他可以预测9000种，但其实效果不好的，他只是提供一个想法。我们的重点在 前面的Better（更准确）和Faster（更快）（换用了Darknet-19网络）上。</p>
<blockquote>
<p>总结来看，虽然YOLOv2做的改进，基本都是借鉴其它论文的一些tricks，比如Faster R-CNN的anchor box，YOLOv2采用anchor box和卷积做预测，这基本上与SSD模型（单尺度特征图的SSD）非常类似了，而且SSD也是借鉴了Faster R-CNN的RPN网络。<br>从某种意义上来说，YOLOv2和SSD这两个one-stage模型与RPN网络本质上无异，<strong>只不过RPN不做类别的预测，只是简单地区分物体与背景</strong>。在two-stage方法中，RPN起到的作用是给出region proposals，其实就是作出粗糙的检测，所以另外增加了一个stage，即采用R-CNN网络来进一步提升检测的准确度（包括给出类别预测）。<br>而对于one-stage方法，它们想要一步到位，直接采用“RPN”网络作出精确的预测，要因此要在网络设计上做很多的tricks。<br>YOLOv2的一大创新是采用Multi-Scale Training策略，这样同一个模型其实就可以适应多种大小的图片了。</p>
</blockquote>
<h1 id="Better（更准确）"><a href="#Better（更准确）" class="headerlink" title="Better（更准确）"></a>Better（更准确）</h1><p>作者为使yolo的精度更高，使用了很多个tricks。包括<br><strong>Batch Normalization</strong>、High Resolution Classifer、<strong>Anchor</strong>、Dimension Cluster、Direct location prediction、Fine-Graind Features、Muti-Scale Training</p>
<h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><p>Batch Normalization可以提升模型收敛速度，而且可以起到一定正则化效果，降低模型的过拟合。在YOLOv2中，每个卷积层后面都添加了Batch Normalization层，并且不再使用droput。使用Batch Normalization后，YOLOv2的mAP提升了2.4%。</p>
<blockquote>
<p>Batch Normalization 的详细内容请看<br><a href="https://jks88995656.github.io/2021/10/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%20-%20Batch%20Normalization/">一只柴犬 深度学习基础 - Batch Normalization </a></p>
</blockquote>
<h2 id="High-Resolution-Classifier"><a href="#High-Resolution-Classifier" class="headerlink" title="High Resolution Classifier"></a>High Resolution Classifier</h2><p>目前大部分的检测模型都会在先在ImageNet分类数据集上预训练模型的主体部分（CNN特征提取器），由于历史原因，ImageNet分类模型基本采用大小为 224×224 的图片作为输入，分辨率相对较低，不利于检测模型。</p>
<p>  Yolov1中 </p>
<ul>
<li>所以 YOLOv1 在采用 224×224 分类模型预训练后，将分辨率增加至448×448，并使用这个高分辨率在检测数据集上finetune。<strong>但是直接切换分辨率，检测模型可能难以快速适应高分辨率。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/803c6a4d557bf242831be696587816d0.png#pic_center" alt="Yolov1中作者模型训练和测试 输入图片大小情况"></p>
<p> Yolov2中</p>
<ul>
<li><strong>YOLOv2增加了在ImageNet数据集上使用 448×448 输入来finetune分类网络这一中间过程（10 epochs）</strong>（也就是他先是224×224 分辨率训练了一会，再用 448×448<br>分辨率上训练了10个epoch，），这可以使得模型在检测数据集上finetune之前已经适用高分辨率输入。使用高分辨率分类器后，YOLOv2的mAP提升了约4%。</li>
</ul>
<h2 id="Convolutional-With-Anchor-Boxes"><a href="#Convolutional-With-Anchor-Boxes" class="headerlink" title="Convolutional With Anchor Boxes"></a>Convolutional With Anchor Boxes</h2><p>  Yolov1中</p>
<ul>
<li>在YOLOv1中，输入图片最终被划分为 7×7 个 grid cell，每个grid cell预测2个边界框（bounding box）。YOLOv1最后采用的是全连接层直接对边界框进行预测，其中边界框的宽与高是相对整张图片大小的，而由于各个图片中<strong>存在不同尺度和长宽比（scales and ratios）的物体</strong>，YOLOv1在训练过程中学习适应不同物体的形状是比较困难的，这也导致YOLOv1在<strong>精确定位方面表现较差</strong>。In another word, v1中并没有对框和对象的关系做匹配，也就是我的框可能都是长的或者都是宽的没个标准，这样匹配起来就比较麻烦。<br><img src="https://img-blog.csdnimg.cn/img_convert/4059677c62015c45885ecfff1025240b.png" alt="v1中的bounding box 野蛮生长"><br>比如上图所示，长的那个符合人这个物体，但对车就不太符合了。</li>
<li>对于YOLOv1，每个grid cell都预测2个 bounding box，每个box包含5个值： (中心点横坐标，中心店纵坐标，框宽度，框高度，置信度)，最后一个置信度（confidence scores，包含两部分：含有物体的概率以及预测框与ground truth的IOU）。<strong>但是每个cell只预测一套分类概率值（class predictions，其实是置信度下的条件概率值）,供2个boxes共享。</strong></li>
</ul>
<p> Yolov2</p>
<ul>
<li>v2中引入了先验参考框这个概念。（其实可以理解为一个公共的模板bounding box集合，生成的bounding box 都是这个集合里的）所有的预测框其实都是 先验参考框的<strong>偏移</strong>。每个anchor都对应一个预测框，每个预测框只要 预测出 其相对于Anchor的偏移量。例如下图所示，就是5个先验参考框：<br><img src="https://img-blog.csdnimg.cn/img_convert/0152b5d1eba3e64713e8bf34f771fc17.png#pic_center" alt="5个先验参考框（anchor box）"></li>
<li><p>所以<strong>YOLOv2移除了YOLOv1中的全连接层而采用了卷积和anchor boxes来预测边界框(bounding box)</strong>。为了使检测所用的特征图分辨率更高，<strong>移除</strong>其中的一个<strong>pool层</strong>。在检测模型中，YOLOv2不是采用 448×448 图片作为输入，而是采用 <strong>416×416 大小</strong>。因为YOLOv2模型下采样的总步长为 32，对于 416×416 大小的图片，<font color="red">最终得到的特征图大小为 13×13 ，维度是<strong>奇数</strong></font>，这样特征图恰好只有一个中心位置。对于一些大物体，它们中心点往往落入图片中心位置，此时使用特征图的一个中心点去预测这些物体的边界框相对容易些。<strong>所以在YOLOv2设计中要保证最终的特征图有奇数个位置。</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/6b72bf553115ff5febd1abb903f7d010.png#pic_center" alt="使用anchor box 假如为2（因为其实就2类物体）"></p>
</li>
<li><p>YOLOv2使用了anchor box之后，每个位置的各个anchor box都单独预测一套分类概率值，这和SSD比较类似（但SSD没有预测置信度，而是把background作为一个类别来处理）。</p>
</li>
<li>在YOLOv2中，<strong>每个grid cell 预测 5个bounding box</strong> （也就是对应的 5个anchor box）。为什么选5呢后面会说（用的聚类）。所以网络结构输出的特征结果 变为了 <strong>13×13×（5+20）× 5  = 13×13×125</strong> ，不是一个grid cell 的bounding box 共享一套分类概率值（条件概率），现在是每个bounding box 都要有自己单独的一套。如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/a56fa6771fcd8496670697f9005ee125.png" alt="v1与v2特征输出的区别"></li>
</ul>
<h2 id="anchor-box-在v2的效果"><a href="#anchor-box-在v2的效果" class="headerlink" title="anchor box 在v2的效果"></a>anchor box 在v2的效果</h2><p>使用anchor boxes之后，<strong>YOLOv2的mAP有稍微下降</strong>（这里下降的原因，有博主猜想是YOLOv2虽然使用了anchor boxes，但是依然采用YOLOv1的训练方法）。YOLOv1只能预测98个边界框（ 7×7×2 ），而YOLOv2使用anchor box之后可以预测更多个边界框（ 13×13×5 ）。所以使用anchor box之后，<strong>YOLOv2的召回率recall大大提升，由原来的81%升至88%</strong>。也就是说yolo检测出物体的能力更强了，但准确性下降了一些。</p>
<h2 id="Dimension-Clusters"><a href="#Dimension-Clusters" class="headerlink" title="Dimension Clusters"></a>Dimension Clusters</h2><p> 在Faster R-CNN和SSD中，先验框的维度（长和宽）都是<strong>手动设定</strong>的，带有一定的主观性。如果选取的先验框维度比较合适，那么模型更容易学习，从而做出更好的预测。</p>
<font color="red">这里的这个功能就是 为了选取 对于所训练的数据集，我选择anchor box 为几个？ 才能最好的效果。</font>

<blockquote>
<p>那这里 总结一下 v2为什么选择 anchor box =5 呢？<br>答：<strong>所谓的anchor box 的数量 说白了 就是 你的数据集到底有多少个类</strong>，把物体对象框大小差不多的归为一类。<br>v2 采用 的是k-means聚类方法对训练集中的边界框标签做了聚类分析。因为设置先验框的主要目的是为了使得预测框与ground truth的IOU更好，所以聚类分析时选用box与聚类中心box之间的IOU值作为距离指标：</p>
<script type="math/tex; mode=display">d(box,centroid) = 1 - IoU(box,centroid)</script><p>在<strong>VOC和COCO数据集上的聚类分析结果</strong>，随着聚类中心数目的增加，平均IOU值（各个边界框与聚类中心的IOU的平均值）是增加的，但是综合考虑模型复杂度和召回率，作者最终选取<strong>5个聚类中心作为先验框</strong> (也就是 anchor box = 5)<br>但是这里先验框的大小具体指什么作者并没有说明，但肯定不是像素点，从代码实现上看，应该是相对于预测的特征图大小（ 13×13）。对比两个数据集，也可以看到COCO数据集上的物体相对小点。这个策略作者并没有单独做实验，但是作者对比了采用聚类分析得到的先验框与手动设置的先验框在平均IOU上的差异，发现前者的平均IOU值更高，因此模型更容易训练学习。<br><img src="https://img-blog.csdnimg.cn/img_convert/5f91f5d74220601c5e3f6d7cb34b81c1.png#pic_center" alt="数据集VOC和COCO上的边界框聚类分析结果  右侧中 黑框是voc2007 的 长宽比聚类  蓝色的是 coco 的长宽比聚类"></p>
<font color="blue">聚类中心怎么看的呢？这边的先验框大小到底是什么意思呢？</font>

</blockquote>
<h2 id="特征提取器-New-Network-Darknet-19"><a href="#特征提取器-New-Network-Darknet-19" class="headerlink" title="特征提取器 New Network: Darknet-19"></a>特征提取器 New Network: Darknet-19</h2><p>YOLOv2采用了一个新的基础模型（特征提取器），称为Darknet-19，包括19个卷积层和5个maxpooling层，如下图所示。<br><img src="https://img-blog.csdnimg.cn/img_convert/10c9041bf90f9c2d7a3de23f4b571706.png" alt="Darknet-19 的分类模型 预训练输入的为 224×224"><br>Darknet-19与VGG16模型设计原则是一致的，主要采用 3×3 卷积，采用 2×2 的maxpooling层之后，特征图维度降低2倍，而同时将特征图的channles增加两倍。与NIN(Network in Network)类似，Darknet-19最终采用<strong>global avgpooling做预测</strong>，并且在 3×3 卷积之间使用 1×1 卷积来压缩特征图channles以降低模型计算量和参数。Darkxnet-19每个卷积层后面同样使用了Batch Normalization层以加快收敛速度，降低模型过拟合。在ImageNet分类数据集上，Darknet-19的top-1准确度为72.9%，top-5准确度为91.2%，但是模型参数相对小一些。使用Darknet-19之后，YOLOv2的mAP值没有显著提升，但是计算量却可以减少约33%。</p>
<h2 id="Direct-location-prediction-直接位置预测"><a href="#Direct-location-prediction-直接位置预测" class="headerlink" title="Direct location prediction 直接位置预测"></a>Direct location prediction 直接位置预测</h2><p><font color="red"><strong>已知 YOLOv2借鉴RPN网络使用anchor box来预测边界框bounding box相对先验框anchor box的偏移量offsets。</strong></font><br>预测边界框 bounding box 的中心位置 $(x,y)$ ，需要根据预测的坐标偏移值 $(t<em>{x},t</em>{y})$，<font color="blue">先验框 anchor box 的尺度 $(w<em>{a},h</em>{a})$</font> 以及中心坐标 $(x<em>{a},y</em>{a})$ （特征图（边长是奇数）每个位置的中心点）来计算：</p>
<p><font color="blue">（不知道他这边怎么理解的 我是改了一下）</font></p>
<pre><code>$$x = x_&#123;a&#125;-(t_&#123;x&#125; × w_&#123;a&#125;)$$ $$y=y_&#123;a&#125;-(t_&#123;y&#125;×h_&#123;a&#125;)$$
</code></pre><p>这个公式是<strong>无约束的，预测的边界框很容易向任何方向偏移</strong>，如当 $t<em>{x}=1$ 时边界框将向左偏移先验框的一个宽度大小，而当 $t</em>{x}=-1$ 时边界框将向右偏移先验框的一个宽度大小，因此每个位置<strong>预测的边界框可以落在图片任何位置</strong>，可能移动幅度过大，这导致模型的<strong>不稳定性</strong>，在训练时需要很长时间来预测出正确的offsets。<br>所以，YOLOv2弃用了这种预测w方式，而是沿用YOLOv1的方法，就是<strong>预测边界框中心点相对于对应cell左上角位置$(c<em>{x},c</em>{y})$的相对偏移值</strong>，<font color="blue">为了将边界框 bounding box 中心点约束在当前cell中 </font>，使用sigmoid函数处理偏移值，这样预测的偏移值在(0,1)范围内（每个cell的尺度看做1）。总结来看，根据边界框预测的4个offsets $t<em>{x},t</em>{y},t<em>{w},t</em>{h}$ ，可以按如下公式计算出边界框实际位置和大小$(b<em>{x},b</em>{y},b<em>{w},b</em>{h})$：<br><img src="https://img-blog.csdnimg.cn/img_convert/920c51b2db6727365725e3fb831d027e.png#pic_center" alt=""><br>其中 $(c<em>{x},c</em>{y})$ 为grid cell的左上角坐标，如下图所示。<br><img src="https://img-blog.csdnimg.cn/img_convert/f3be09eb2cb40eb39ee6ce782070fc22.png#pic_center" alt="边界框位置与大小的计算示例图"><br>在计算时每个grid cell的尺度为1，所以当前grid cell的左上角坐标为$(1,1)$。由于 $sigmoid函数$ 的处理，<strong>边界框的中心位置会约束在当前grid cell内部，防止偏移过多</strong>。而 $p<em>{w}$ 和 $p</em>{h}$ 是先验框 anchor box 的宽度与长度，前面说过它们的值也是相对于特征图大小的，在特征图中每个cell的长和宽均为1。这里记特征图的大小为 $(W,H)$ （v2中为 (13,13) )，这样我们可以将边界框相对于整张图片的位置和大小计算出来  <font color="blue">（4个值均在0和1之间）?? 什么四个值  是下图的4个 这是左上角是（1,1）右下角是（0,0）？？么</font><br><img src="https://img-blog.csdnimg.cn/img_convert/b7643a7e41364c7a09b018e58a010571.png#pic_center" alt="得到的四个 尺度值"><br><strong>如果再将上面的4个值分别乘以图片的宽度和长度（像素点值）就可以得到边界框的最终位置和大小了</strong>。这就是YOLOv2边界框的整个解码过程。约束了边界框的位置预测值使得模型更容易稳定训练，结合聚类分析得到先验框与这种预测方法，YOLOv2的mAP值提升了约5%。</p>
<h2 id="Fine-Grained-Features-细粒度特征图"><a href="#Fine-Grained-Features-细粒度特征图" class="headerlink" title="Fine-Grained Features 细粒度特征图"></a>Fine-Grained Features 细粒度特征图</h2><p>YOLOv2的输入图片大小为 416×416 ，经过5次maxpooling之后得到 13×13大小的特征图，并以此特征图采用卷积做预测。 13×13大小的特征图对检测大物体是足够了，但是<strong>对于小物体还需要更精细的特征图（Fine-Grained Features）</strong>。因此SSD使用了多尺度的特征图来分别检测不同大小的物体，前面更精细的特征图可以用来预测小物体。YOLOv2提出了一种pass through层来利用更精细的特征图。如下图为整体的网络结构：<br><img src="https://img-blog.csdnimg.cn/img_convert/989dde6af769da5bd9ba6012e8bef92e.png#pic_center" alt="Darknet19检测模型+passthrough操作"><br>passthrough层与ResNet网络的shortcut类似，以前面<strong>更高分辨率的特征图为输入</strong>，然后将其<strong>连接到后面的低分辨率特征图</strong>上。<br>前面的特征图维度是后面的特征图的2倍，passthrough层抽取前面层的每个 2×2 的局部区域，然后将其转化为channel维度，对于26×26×512 的特征图，经passthrough层处理之后就变成了 13×13×2048 的新特征图（特征图大小降低4倍，而channles增加4倍。操作如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4051f9f715281e7658ab01fb6557807b.png#pic_center" alt="passthrough 增加通道数的操作栗子"><br>这样也就得到了 13×13×2048 的输出，可以与后面的 13×13×1024 低分辨率特征图连接在一起形成 13×13×3072 大小的特征图，然后在此特征图基础上卷积做预测。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8a808bf40d6b819b196d7d348c755dca.png" alt="就是这样"></p>
<p><font color="blue">在TensorFlow中，可以使用tf.extract_image_patches或者tf.space_to_depth来实现passthrough层：</font><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out = tf.extract_image_patches(<span class="keyword">in</span>, [<span class="number">1</span>, stride, stride, <span class="number">1</span>], [<span class="number">1</span>, stride, stride, <span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">&quot;VALID&quot;</span>)</span><br><span class="line">// <span class="keyword">or</span> use tf.space_to_depth</span><br><span class="line">out = tf.space_to_depth(<span class="keyword">in</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是v2论文中刚开始的想法，作者后期借鉴了ResNet网络，<strong>不是直接对高分辨特征图处理</strong>，而是增加了一个<strong>中间1×1卷积层</strong>，先采用64个1×1 卷积核进行卷积，然后再进行passthrough处理，这样 26×26×512的特征图得到 13×13×256 的特征图。最后再高和低分辨率合并，得到13×13×1280的特征图做预测。这算是实现上的一个trick。使用Fine-Grained Features之后YOLOv2的性能有1%的提升。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cd777947365d746debcde922ad285dfb.png#pic_center" alt="作者改进后的 也就是真实的代码设计"></p>
<h2 id="Multi-Scale-Training-多尺度训练"><a href="#Multi-Scale-Training-多尺度训练" class="headerlink" title="Multi-Scale Training 多尺度训练"></a>Multi-Scale Training 多尺度训练</h2><p>YOLOv2的一大创新是采用Multi-Scale Training策略，<strong>这样同一个模型其实就可以适应多种大小的图片</strong>。</p>
<p><font color="blue">由于YOLOv2模型中采用了global average pooling 全局平均池化层 ，所以YOLOv2的输入可以不限于 416×416 大小的图片。</font>为了增强模型的鲁棒性，YOLOv2采用了多尺度输入训练策略，具体来说就是在训练过程中每间隔10个 iterations 之后改变模型的输入图片大小。由于YOLOv2的下采样总步长为32，输入图片大小选择一系列为32倍数的值：{320,352，…608}。在训练过程，每隔10个iterations随机选择一种输入图片大小，然后只需要修改对最后检测层的处理就可以重新训练。<br><img src="https://img-blog.csdnimg.cn/img_convert/8a03850706857e9f5a4cd666bae33301.png#pic_center" alt="Multi-Scale Training 多尺度输入训练"><br>YOLOv2在 VOC2007和2012的训练集上，可以看到采用较小分辨率时，YOLOv2的mAP值略低，但是速度更快，而采用高分辨输入时，mAP值更高，但是速度略有下降，对于 544×544 ，mAP高达78.6%。<strong>注意，这只是训练时输入图片大小不同，而实际上用的是同一个模型（采用Multi-Scale Training训练）。</strong><br>这里也可以看出，多尺度训练的一个副作用：如果你输入的是一个高分辨率的大图片 yolo会预测的比较慢但是比较准 如果你输入的是低分辨率的小图片，yolo会预测的非常快但是精度没有那么高。因此yolo可以通过输入图片的大小尺度，来做到精度和速度的权衡。</p>
<h1 id="YOLOv2的训练"><a href="#YOLOv2的训练" class="headerlink" title="YOLOv2的训练"></a>YOLOv2的训练</h1><p>YOLOv2的训练主要包括三个阶段。</p>
<ol>
<li>第一阶段就是先在ImageNet分类数据集上预训练Darknet-19，此时模型输入为  ，共训练160个epochs。</li>
<li>第二阶段将网络的输入调整为 448×448 ，继续在ImageNet数据集上finetune分类模型，训练10个epochs，此时分类模型的top-1准确度为76.5%，而top-5准确度为93.3%。</li>
<li><strong>第三个阶段就是修改Darknet-19分类模型为检测模型</strong>，并在检测数据集上继续finetune网络。网络修改包括（网路结构可视化）：<font color="red">移除最后一个卷积层、global average pooling层以及softmax层，并且新增了三个 3×3×1024 卷积层，同时增加了一个passthrough层，最后使用 1×1 卷积层输出预测结果，输出的channels数为： $anchor个数 × (5+类别个数)$（在v2中 为 5×（5+20）） ，和训练采用的数据集有关系。</font>由于anchors数为5，对于VOC数据集输出的channels数就是125，而对于COCO数据集则为425（因为COCO是80个分类）。</li>
</ol>
<p>这里以VOC数据集为例，最终的预测矩阵为 $T$（shape为 （batch_size,13,13,125）），可以先将其reshape为 （batch_size,13,13,5,25），<font color="blue">其中 $T[:,:,:,:,0:4]$ 为边界框的位置和大小 $t_x,t_y,t_w,t_h$， $T[:,:,:,:,4]$ 为边界框的置信度，而 $T[:,:,:,:,5:]$为类别预测值。 </font><br><img src="https://img-blog.csdnimg.cn/img_convert/533f8c8dcc9da79ea03a5ca90bd00f4a.png#pic_center" alt="YOLOv2训练的三个阶段"><br><img src="https://img-blog.csdnimg.cn/img_convert/89c0c117e6648f93753cc6416d0bbadf.png#pic_center" alt="YOLOv2 检测网络结构示意图"></p>
<h2 id="YOLOv2的损失函数"><a href="#YOLOv2的损失函数" class="headerlink" title="YOLOv2的损失函数"></a>YOLOv2的损失函数</h2><p>v2的预测框和类别的想法其实与v1是一致的，对于训练图片中的ground truth，若其中心点落在某个grid cell内，那么该grid cell内的5个先验框 anchor box 所对应的预测框 bounding box 负责预测它，具体是哪个bounding box预测它，需要在训练中确定，即由那个与ground truth的IoU最大的 bounding box 预测它，而剩余的4个 bounding box 不与该ground truth匹配。<br><img src="https://img-blog.csdnimg.cn/img_convert/68b2ccd52bf5d18fd4a234ac07c12057.png#pic_center" alt="YOLOv2的损失函数"></p>
<ol>
<li>首先 $W、H$分别指的是特征图（ 13×13 ）的宽13与高13，而 $A$ 指的是先验框anchor box数目（这里是5），各个 $λ$ 值是各个 loss 部分的权重系数（即超参数）。<br><img src="https://img-blog.csdnimg.cn/img_convert/2b4666868ab3c549bf793cfa3acf9e59.png#pic_center" alt="在这里插入图片描述"></li>
<li><font color="red">第一项loss是计算 该预测框不负责检测物体(background) 的置信度误差(越小越好)</font>，但是哪些预测框不负责检测物体对象而预测背景呢，需要先计算各个预测框和<strong>所有ground truth的IOU值</strong>，并且取<strong>最大值Max_IOU</strong>，如果该值<strong>小于</strong>一定的<strong>阈值</strong>（YOLOv2使用的是0.6），那么这个预测框就标记为background，<font color="blue">需要计算$λ_{noobj}$ 的置信度误差。</font><br><img src="https://img-blog.csdnimg.cn/img_convert/b0b4307ec6cdad8bde6ec679a55b6d8b.png#pic_center" alt="在这里插入图片描述"></li>
<li><p><font color="red">第二项是计算先验框anchor box与预测框bounding box的坐标误差</font>，<font color="blue">但是只在前12800个iterations间计算，该博客博主认为 这项应该是在训练前期使预测框快速学习到先验框的位置和形状。</font><br><img src="https://img-blog.csdnimg.cn/img_convert/fdd54195cbe12c0fc17d3ac02a61a179.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>Q1: 为什么是 前12800个iterations？</p>
</blockquote>
</li>
<li><p><font color="red">第三大项计算与某个ground truth匹配的预测框各部分loss值，包括定位（坐标）误差、置信度误差以及分类误差。</font>先说一下匹配原则，对于某个ground truth，首先要确定其中心点要落在哪个grid cell上，然后计算这个grid cell的5个先验框 anchor box 与ground truth的IoU值<font color="blue">（YOLOv2中bias_match=1）</font>，<strong>计算IoU值时不考虑坐标，只考虑形状</strong>，所以先将先验框与ground truth的中心点都偏移到同一位置（原点），然后计算出对应的IoU值，IoU值最大的那个先验框与ground truth匹配，对应形状的预测框用来预测这个ground truth。 说白了就是 我先看看 anchorbox 模板里面哪个和 ground truth形状比较像，这样我的框比较对嘛。然后选出这个框 找到 这个grid cell 里面 5个bounding box 和这个anchor 形状一样的那个框 去匹配ground truth。 说白了就是 弄了个中间商去选 形状 匹配。<br><font color="blue">在计算obj置信度时，target=1，但与YOLOv1一样而增加了一个控制参数rescore，当其为1时，target取预测框与ground truth的真实IOU值（cfg文件中默认采用这种方式）。 ???什么意思</font><br>对于那些没有与ground truth匹配的先验框（与预测框对应），除去那些Max_IOU低于阈值的，其它的就全部忽略，不计算任何误差。这点在YOLOv3论文中也有相关说明：<strong>YOLO中一个ground truth只会与一个先验框匹配（IOU值最好的）</strong>，对于那些IOU值超过一定阈值的先验框，其预测结果就忽略了。</p>
</li>
</ol>
<p> 尽管YOLOv2和YOLOv1计算loss处理上有不同，但都是采用均方差来计算loss。另外需要注意的一点是，在计算boxes的 $w$ 和 $h$ 误差时，YOLOv1中采用的是平方根以降低boxes的大小对误差的影响，而YOLOv2是直接计算，<font color="blue">但是根据ground truth的大小对权重系数进行修正：l.coord_scale <em> (2 - truth.w</em>truth.h)（这里w和h都归一化到(0,1))</font>，这样对于尺度较小的boxes其权重系数会更大一些，可以放大误差，起到和YOLOv1计算平方根相似的效果（参考<a href="https://www.cnblogs.com/YiXiaoZhou/p/7429481.html">YOLO v2 损失函数源码分析</a>）。 </p>
<p>最终的YOLOv2模型在速度上比YOLOv1还快（采用了计算量更少的Darknet-19模型），而且模型的准确度比YOLOv1有显著提升，详情见paper。</p>
<h1 id="Yolov2的预测"><a href="#Yolov2的预测" class="headerlink" title="Yolov2的预测"></a>Yolov2的预测</h1><p>同Yolov1 的预测 同样是消除多余的框。可以看一下Yolov1 是怎么 在网络提取出特征图 后 如何 消除多余的框的。 <a href="https://jks88995656.github.io/2021/09/26/%E5%90%8C%E6%B5%8E%E5%AD%90%E8%B1%AA%E5%85%84%20%E4%B9%8B%20yolov1%20%E8%AF%A6%E8%A7%A3/">Yololv1的详解</a></p>
<h1 id="Yolo9000"><a href="#Yolo9000" class="headerlink" title="Yolo9000"></a>Yolo9000</h1><p>YOLO9000是在YOLOv2的基础上提出的一种可以检测超过9000个类别的模型，其主要贡献点在于提出了一种分类和检测的联合训练策略。<br>ImageNet分类数据集比VOC等检测数据集高出几个数量级。在YOLO中，边界框的预测其实并不依赖于物体的标签，所以YOLO可以实现在分类和检测数据集上的联合训练。对于检测数据集，可以用来学习预测物体的边界框、置信度以及为物体分类，而对于分类数据集可以仅用来学习分类，但是其可以大大扩充模型所能检测的物体种类。</p>
<p>这个装逼不成的作者 <strong>选择在COCO和ImageNet数据集上进行联合训练</strong>，但是遇到的第一问题是<font color="red">两者的类别并不是完全互斥的，</font>比如”Norfolk terrier”明显属于”dog”，所以作者提出了一种层级分类方法（Hierarchical classification），主要思路是根据各个类别之间的从属关系（根据WordNet）建立一种树结构WordTree，结合COCO和ImageNet建立的WordTree如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/e081b98313870f03c620f2d8fb0ddb7e.png#pic_center" alt="基于COCO和ImageNet数据集建立的WordTree"><br>WordTree中的根节点为”physical object”，每个节点的子节点都属于同一子类，可以对它们进行softmax处理。在给出某个类别的预测概率时，需要找到其所在的位置，遍历这个path，然后计算path上各个节点的概率之积。<br><img src="https://img-blog.csdnimg.cn/img_convert/63cf274736bb7b43970301aa7d192431.png#pic_center" alt="ImageNet与WordTree预测的对比"><br><img src="https://img-blog.csdnimg.cn/img_convert/e6f7edd74a243934d58718fd27e46d23.png#pic_center" alt="Yolo9000"><br>在训练时，如果是检测样本，按照YOLOv2的loss计算误差，而对于分类样本，只计算分类误差。在预测时，YOLOv2给出的置信度就是 $Pr(physical    -object)$ ，同时会给出边界框位置以及一个树状概率图。在这个概率图中找到概率最高的路径，当达到某一个阈值时停止，就用当前节点表示预测的类别。</p>
<p>通过联合训练策略，YOLO9000可以快速检测出超过9000个类别的物体，总体mAP值为19.7%。效果一般般，很多类别检测不出来，特别是物体类。<br><img src="https://img-blog.csdnimg.cn/img_convert/ebf757ed8dcdec3f000ab814355f10b3.png#pic_center" alt="在这里插入图片描述"><br>作者提出的 yolo9000 算是一个开创的想法，但是效果不佳（不然他早就在youtube上装逼了）</p>
<h1 id="参考论文和博客"><a href="#参考论文和博客" class="headerlink" title="参考论文和博客"></a>参考论文和博客</h1><p>参考博客：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35325884">转载来源 目标检测|YOLOv2原理与实现</a></li>
<li><a href="https://www.cnblogs.com/YiXiaoZhou/p/7429481.html">YOLO v2 损失函数源码分析 源码c版的</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/54073204">Batch Normalization的通俗解释</a></li>
</ul>
<p>参考视频：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Q64y1s74K?p=1">同济子豪兄v2算法讲解</a></li>
<li><p><a href="https://www.bilibili.com/video/BV1Q64y1s74K?p=2">同济子豪兄v2论文精讲</a></p>
<p>keras代码 github：YAD2K-master<br>参考论文：YOLO9000 Better, Faster, Stronger</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Yolo</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达deeplearning.ai学习  之 目标检测</title>
    <url>/2021/09/25/%E5%90%B4%E6%81%A9%E8%BE%BEdeeplearning.ai%E5%AD%A6%E4%B9%A0%20%20%E4%B9%8B%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>@<a href="吴恩达deeplearning.ai学习  之 目标检测">TOC</a></p>
<h1 id="目标定位"><a href="#目标定位" class="headerlink" title="目标定位"></a>目标定位</h1><p>我们对图像的学习过程应该由 图像分类 -&gt; 图像单目标定位 -&gt; 图像多目标检测。<br><img src="https://img-blog.csdnimg.cn/img_convert/3ff5dd940674e17134f4a03d0199478d.png#pic_center" alt="目标检测的演化过程"></p>
<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p>在图像分类中，例如，输入一张图片到多层卷积神经网络，它会输出一个特征向量，并反馈给 softmax 单元来预测图片类型。比如你正在构建汽车自动驾驶系统，你面前的对象可能包括以下4类：行人、汽车、摩托车和背景，这时 softmax 单元有四个输出（概率高的为判断的类）。如果图片里没有前三类的话，输出结果会是背景。</p>
<h2 id="图像分类基础上-发展图像内的单目标定位"><a href="#图像分类基础上-发展图像内的单目标定位" class="headerlink" title="图像分类基础上 发展图像内的单目标定位"></a>图像分类基础上 发展图像内的单目标定位</h2><p>在图像分类的基础上，我们可以对图像内的单目标定位<font
   color="red">（注意：这边的基础是图像里只有一个目标可以被检测，例如上图的车）</font>。实现定位，需要让神经网络多输出4个数字，标记为$b<em>{x},b</em>{y},b<em>{h},b</em>{w}$用于表示输出的边界框。前两者表示边界框的中心点，后两者表示的为边界框的高度和宽度。<font color="red">注意：我们定义左上角为坐标原点(0,0)，右下角为终点(1,1)</font> 例如下图所示：<br><img src="https://img-blog.csdnimg.cn/img_convert/043ac4d106c620fb7b7d1a3a300173e2.png#pic_center" alt="边界框描述"><br>还是这个例子，神经网络的输出改变为四个边界框描述数字$b<em>{x},b</em>{y},b<em>{h},b</em>{w}$ ，是否含有对象 $p<em>{c}$ ，含有对象属于哪个类标签。可以定义输出  $y$ 为 $[p</em>{c},b<em>{x},b</em>{y},b<em>{h},b</em>{w},c<em>{1},c</em>{2},c_{3}]^{T}$ </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/82a6083e2c74937f49a25fc083131ea0.png#pic_center" alt="标签的定义与举例 左图为有车这个目标的图像  右图为没有目标对象的背景图像"><br><strong>注意我们此时假设的图片中只含有一个对象，是单目标的分类定位问题。</strong></p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>神经网络的损失函数，其参数为类别$\hat{y}$ 和网络输出 $y$ ，如果采用MSE损失函数，则 </p>
<script type="math/tex; mode=display">L(\hat{y},y)==(\hat{y_{1}} - y_{1})^{2}+(\hat{y_{2}} - y_{2})^{2}+...+(\hat{y_{8}} - y_{8})^{2}</script><p>损失值等于每个元素相应差值的平方和。<br>​</p>
<ul>
<li>如果图片内有对象（即 $p_{c}=1$），损失值就是不同元素的平方和</li>
<li>如果图片内没有对象（即 $p<em>{c}=0$），我们不用考虑其它元素，只需要关注神经网络输出 $p</em>{c}$ 的准确度。</li>
</ul>
<h2 id="图像内的单目标定位基础上-发展多目标定位"><a href="#图像内的单目标定位基础上-发展多目标定位" class="headerlink" title="图像内的单目标定位基础上 发展多目标定位"></a>图像内的单目标定位基础上 发展多目标定位</h2><p>yolo 将图像拆分成多个子图</p>
<h1 id="特征点检测（Landmark-detection）"><a href="#特征点检测（Landmark-detection）" class="headerlink" title="特征点检测（Landmark detection）"></a>特征点检测（Landmark detection）</h1><p>例如我想做人脸的情感识别，可以根据眼睛的特征点，根据嘴部的关键点输出值来确定嘴的形状，从而判断人物是在微笑还是皱眉，也可以提取鼻子周围的关键特征点。为了便于说明，你可以设定特征点的个数，<strong>假设脸部有64个特征点</strong>，有些点甚至可以帮助你定义脸部轮廓或下颌轮廓。选定特征点个数，并生成包含这些特征点的标签训练集，然后利用神经网络输出脸部关键特征点的位置。<br><img src="https://img-blog.csdnimg.cn/img_convert/2e7d94b4be44001ed6f193bc81b0303e.png#pic_center" alt="人脸情感识别的特征点示意图"><br>具体的想法是，准备一个卷积网络和一些特征点集，将人脸图片输入到卷积网络，输出1或0（1表示有人脸，0表示没有人脸），然后输出 64个特征点坐标位置 $(l<em>{1x},l</em>{1y})$ … $(l<em>{64x},l</em>{64y})$。理论上应该有129个输出（64个特征点 64×2+ 1（表示是否有人脸））。另外在人体姿态检测上也可以使用这样的特征点方法。</p>
<blockquote>
<p><strong>Q：注意点 特征点1的特性在所有图片中必须保持一致</strong><br>特征点1始终是右眼的外眼角，特征点2是右眼的内眼角，特征点3是左眼内眼角，特征点4是左眼外眼角等等。所以标签在所有图片中必须保持一致，假如你雇用他人或自己标记了一个足够大的数据集，那么神经网络便可以输出上述所有特征点，你可以利用它们实现其他有趣的效果，比如判断人物的动作姿态，识别图片中的人物表情等等。</p>
</blockquote>
<h1 id="滑动窗口目标检测法-（复杂过时）"><a href="#滑动窗口目标检测法-（复杂过时）" class="headerlink" title="滑动窗口目标检测法 （复杂过时）"></a>滑动窗口目标检测法 （复杂过时）</h1><p>这个方法简单的说就两步</p>
<ul>
<li>先构建一个卷积神经网络，能够识别出这个对象<br><img src="https://img-blog.csdnimg.cn/img_convert/e00067812bddc65aadedb32741cf0368.png#pic_center" alt="训练得到可以识别车的卷积网络"></li>
<li>滑动窗口（每次扩大窗口），选定合适的步长，从左上角开始裁剪，将其输入该卷积网络，输出是否为该对象。这样从左上角开始滑动窗口遍历整个图像。<br><img src="https://img-blog.csdnimg.cn/img_convert/4beea107cf1b1f8c359ef591dc421634.png#pic_center" alt="滑动窗口法"><br>这个方法有很明显的缺点就是。如果步长太大，误差会很大，不够精细。单如果步长太精细的话，因为我每滑动一次窗口即裁剪一次图像就要输入卷积网络输出是否是车。卷积网络时间代价很高，这么多次输入，那这个方法需要的时间成本就非常的高。</li>
</ul>
<blockquote>
<p><strong>Q：那为什么这个办法之前是可用的？</strong><br>因为之前神经网络还没兴起，每个裁剪对象判断都是由SVM来完成的。线性分类器速度比较快一些。</p>
</blockquote>
<p>解决的办法是不要使用滑动窗口，使用卷积来实现滑动窗口的效果。详见下章节。</p>
<h1 id="滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）"><a href="#滑动窗口的卷积实现（Convolutional-implementation-of-sliding-windows）" class="headerlink" title="滑动窗口的卷积实现（Convolutional implementation of sliding windows）"></a>滑动窗口的卷积实现（Convolutional implementation of sliding windows）</h1><p>首先你要了解，如何将全神经网络转化为用卷积网络来实现，如下图：<br><img src="https://img-blog.csdnimg.cn/img_convert/a9f14a0c1c5045527b4838803ea88b64.png#pic_center" alt="全神经网络转化为用卷积网络来实现"><br><strong>那我们现在来看 为什么要可以使用卷积来简化滑动窗口呢？</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/cf87ee71357e6a873d064bf0bea812b6.png#pic_center" alt="用卷积来简化滑动窗口"><br>如上图所示，假如输入给卷积网络的图像大小为14×14×3，测试集图片是16×16×3。<br>现在给这个输入图片加上黄色条块（padding = 2），在最初的滑动窗口算法中，设置窗口大小为14×14，步长为2，可以滑出4个窗口，对应输入到卷积网络中，输出4个标签。 <strong>可以发现，这4次卷积操作中由很多像素点的计算都是重复的。</strong> 所以执行滑动窗口的卷积时使得卷积网络在这4次前向传播过程中共享很多计算。<br>如果我们使用如上的卷积方式的话，最后输出的4个方块，刚好就对应我们的4个窗口。如上面绿色的小框框，假设你剪切出这块区域（编号1），传递给卷积网络，第一层的激活值就是这块区域（编号2），最大池化后的下一层的激活值是这块区域（编号3），这块区域对应着后面几层输出的右上角方块（编号4，5，6）。<br><img src="https://img-blog.csdnimg.cn/img_convert/18e139d467f97830a238b06725a67f68.png#pic_center" alt="更复杂的例子"><br>但是正如在前一页所看到的，我们不能依靠连续的卷积操作来识别图片中的汽车，比如，我们可以对大小为28×28的整张图片进行卷积操作，一次得到所有预测值，如果足够幸运，神经网络便可以识别出汽车的位置。28×28的图像按照 图像14×14的来划定窗口，那么将有 64个窗口（行列均为8 8×8）所以最后输出的也是个 8×8。<br><strong>说白了这个办法，就是用卷积，将最后的输出每个格子表示当初划定的一个窗口。</strong><br>这个算法，效率是提高了，但是仍然存在一个缺点，就是边界框的位置可能不够准确。可以Bounding Box预测解决，详见下一章。<br><img src="https://img-blog.csdnimg.cn/img_convert/b16106fb0d740de6fffa3bd64dec09bc.png#pic_center" alt="识别是正确的，但是框和车的具体位置不符合哎"></p>
<h1 id="Bounding-Box预测（Bounding-box-predictions）"><a href="#Bounding-Box预测（Bounding-box-predictions）" class="headerlink" title="Bounding Box预测（Bounding box predictions）"></a>Bounding Box预测（Bounding box predictions）</h1><p>如何能精准边界框呢。比较出名的一个算法就是 Yolo 算法。Yolo 算法是这样的，简单的说就是 （如下图）比如你输入的图像是100×100的，然后在图像上放一个3×3网格（自己定应该更精细一点）。一共9个网格，每个网格都采取我们之前说的图像分类再定位的算法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/15a1fb69f8ac47568bb742c1dfa7a7af.png#pic_center" alt="100×100 化为3×3网格"><br>对于9个格子中的每一个指定一个标签 $y$ ，$y$ 是8维的。$y=[p<em>{c},b</em>{x},b<em>{y},b</em>{h},b<em>{w},c</em>{1},c<em>{2},c</em>{3}]^{T}$。 看这个九宫格的第一个格子，里面没有检测的目标（也就是只有背景），所以左上格子的标签向量 $y=[0,?,?,?,?,?,?,?]^{T}$，同样右边的两个格子也是一样的。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/237ff5b5bf58e20651f7444ba194c017.png#pic_center" alt="取中点的格子"><br>再看第二层，有两辆车，也就是有2个对象。<strong>YOLO算法</strong>做的就是，取两个对象的中点，然后将这个对象分配给<strong>包含对象中点</strong>的格子。所以左边的汽车就分配到左边这个格子上（编号4），然后这辆长条车中点在这里，分配给右侧这个格子（编号6）。所以即使中心格子（编号5）同时有两辆车的一部分，我们就假装中心格子没有任何我们感兴趣的对象，所以对于中心格子，的输出标签向量 就是$y=[0,?,?,?,?,?,?,?]^{T}$。而左右编号为4和6的格子，输出标签向量均为$y=[1,b<em>{x},b</em>{y},b<em>{h},b</em>{w},0,1,0]^{T}$  由此得到，最后这张图片的目标输出为 3×3×8 （因为这里有3×3格子，然后对于每个格子，你都有一个8维向量，所以目标输出尺寸是3×3×8。） </p>
<h2 id="怎么得到框的精确位置呢？"><a href="#怎么得到框的精确位置呢？" class="headerlink" title="怎么得到框的精确位置呢？"></a>怎么得到框的精确位置呢？</h2><p>因为我们是将每个样本格子都作为考虑对象，所以每个格子的左上角均为（0，0），右下角为（1，1）。如下图所示，右侧长条车为栗子：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7da7c4e5e6d9c2602b659e5db0342407.png#pic_center" alt="精确外框"><br>可以看到橙色为对象的中点处，而后$b<em>{x},b</em>{y},b<em>{h},b</em>{w}$单位是相对于格子尺寸的比例，所以$b<em>{x},b</em>{y}$必须在0和1之间；$b<em>{h},b</em>{w}$ 可能会大于1，特别是如果有一辆汽车的边界框是这样的（左下大红框），那么边界框的宽度和高度有可能大于1。</p>
<h1 id="交并比（Intersection-over-union）"><a href="#交并比（Intersection-over-union）" class="headerlink" title="交并比（Intersection over union）"></a>交并比（Intersection over union）</h1><p>业界都用交并比（IOU）来衡量 框框打的对不对。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e3544013b01c3b80ee75324e9967a629.png#pic_center" alt="IoU"></p>
<script type="math/tex; mode=display">IOU = \frac{∩ size}{∪size}</script><p>一般规定≥0.5即可，这个是人为定的，你也可以严格一点，选0.6及其以上。</p>
<h1 id="非极大值抑制（NMS）减少同一对象的-多个检测结果"><a href="#非极大值抑制（NMS）减少同一对象的-多个检测结果" class="headerlink" title="非极大值抑制（NMS）减少同一对象的 多个检测结果"></a>非极大值抑制（NMS）减少同一对象的 多个检测结果</h1><font color="blue">到目前为止你们学到的对象检测中的一个问题是，你的算法可能对同一个对象做出多次检测，所以算法不是对某个对象检测出一次，而是检测出多次。</font>

<p><img src="https://img-blog.csdnimg.cn/img_convert/5ccaf433e145ea11d38bd12830c2d86d.png#pic_center" alt="多个检测结果"><br>非极大值抑制这个方法可以确保你的算法对每个对象只检测一次，我们讲一个例子。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6f0cc70b5cfd976204bc8e5d2d4c7b7c.png#pic_center" alt="图像分成19×19"></p>
<blockquote>
<p>就比如上面这个图。<br>在上面放个19×19网格，理论上这辆车只有一个中点，所以它应该只被分配到一个格子里，左边的车子也只有一个中点，所以理论上应该只有一个格子做出有车的预测。<br>实<strong>践中当你运行对象分类和定位算法时，对于每个格子都运行一次，所以这个格子（编号1）可能会认为这辆车中点应该在格子内部，这几个格子（编号2、3）也会这么认为。</strong>对于左边的车子也一样，所以不仅仅是这个格子，如果这是你们以前见过的图像，不仅这个格子（编号4）会认为它里面有车，也许这个格子（编号5）和这个格子（编号6）也会，也许其他格子也会这么认为，觉得它们格子内有车。</p>
</blockquote>
<p>我们分步介绍一下非极大抑制是怎么起效的，因为你要在361个格子上都运行一次图像检测和定位算法，那么可能很多格子都会举手说我的 $p_{c}$ ，我这个格子里有车的概率很高，而不是361个格子中仅有两个格子会报告它们检测出一个对象。所以当你运行算法的时候，最后可能会对同一个对象做出多次检测，所以非极大值抑制做的就是清理这些检测结果。这样一辆车只检测一次，而不是每辆车都触发多次检测。</p>
<p>所以具体上，这个算法做的是，首先看看每次报告每个检测结果相关的概率$p<em>{c}$，实际上$p</em>{c}$ 是 $p<em>{c}=1$ 乘以 $c</em>{1}、c<em>{2}$或 $c</em>{3}$得到的。首先看概率最大的那个，这个例子（右边车辆）中是0.9，然后就说这是最可靠的检测，所以我们就用<strong>高亮标记</strong>，就说我这里找到了一辆车。这么做之后，<strong>非极大值抑制就会逐一审视剩下的矩形，所有和这个最大的边框有很高交并比，高度重叠的其他边界框，那么这些输出就会被抑制。</strong><br>因为其他两个矩形 $p_{c}$ 分别是0.6和0.7，这两个矩形和 0.9矩形重叠程度很高，所以会被抑制而变暗。<br>接下来，逐一审视剩下的矩形，找出概率最高，最高的一个，在这种情况下是0.8，我们就认为这里检测出一辆车（左边车辆），然后非极大值抑制算法就会去掉其他 loU 值很高的矩形。所以现在每个矩形都会被高亮显示或者变暗，如果你直接抛弃变暗的矩形，那就剩下高亮显示的那些，这就是最后得到的两个预测结果。</p>
<p>简单的说就是：先消除$p_{c} ≤ 0.6$的框，当多个检测框重叠面积IOU占据最大框面积的比例超过了这个设定的非最大值抑制这个值的时候，那么就只保留置信度（概率）最高的那个框，冗余的框都去掉。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ed191a6c686ba1c76835b774e6435eaa.png#pic_center" alt="NMS的操作"></p>
<h1 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h1><h2 id="为什么要使用-anchor-box"><a href="#为什么要使用-anchor-box" class="headerlink" title="为什么要使用 anchor box"></a>为什么要使用 anchor box</h2><p>到目前为止，对象检测中存在一个问题就是每个格子只能预测一个对象，如果想让一个格子检测出多个对象，你可以这么做，就是使用anchor box这个概念。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/69bf3aff7963180bba13f024ee328d30.png#pic_center" alt="同一个格子对象重叠"><br>假设我们有这样一张图片，对于这个例子，我们使用3x3的网格，可以观察到，行人和汽车的中心几乎在同一个网格，然而我们以前的方法一个格子只能预测一个对象，而且对于 y 输出的向量 $y=[p<em>{c},b</em>{x},b<em>{y},b</em>{h},b<em>{w},c</em>{1},c<em>{2},c</em>{3}]^{T}$ ，你可以检测这三个类别，行人、汽车和摩托车，它将无法输出检测结果，所以我必须从两个检测结果中选一个，这便影响了模型性能，导致一些对象被丢弃无法检测出来。</p>
<h2 id="anchor-box-的引入和使用"><a href="#anchor-box-的引入和使用" class="headerlink" title="anchor box 的引入和使用"></a>anchor box 的引入和使用</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/2efc6386311540659396db7cb148d63f.png#pic_center" alt="Anchor box"><br>我们按以下图片的方式，重新定义输出即可：（右边的话是因为 anchor box2 的IoU更高）<br><img src="https://img-blog.csdnimg.cn/img_convert/05633034404323320e005d2c553d8b99.png#pic_center" alt="anchor box 的使用"><br>所以，总的来说，anchor box是这么来做的，现在每个对象和以前一样根据中心点分配到一个格子中，然后看和每个anchor box的IoU（交并比），选择IoU最高的那个，用这个anchor box来进行预测。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1355bdea1f0916386ef754d2ae81a28b.png#pic_center" alt=""></p>
<h2 id="如何选择-anchor-box？"><a href="#如何选择-anchor-box？" class="headerlink" title="如何选择 anchor box？"></a>如何选择 anchor box？</h2><ol>
<li>一般手工指定anchor box形状，根据要检测的对象，指定有针对性地anchor box，可选择5-10个anchor box，使其尽可能覆盖到不同形状。</li>
<li>使用K-means聚类算法获得anchor box。</li>
</ol>
<h1 id="anchor-box-NMS-的总过程"><a href="#anchor-box-NMS-的总过程" class="headerlink" title="anchor box + NMS 的总过程"></a>anchor box + NMS 的总过程</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/00001fa607902111940cd50a61e2c0a6.png#pic_center" alt="步骤"></p>
]]></content>
      <categories>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>无监督学习（Unsupervised Learning）之 聚类与降维</title>
    <url>/2021/08/19/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%EF%BC%88Unsupervised%20Learning%EF%BC%89%E4%B9%8B%20%E8%81%9A%E7%B1%BB%E4%B8%8E%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<p>@<a href="无监督学习 Unsupervised  Learning">TOC</a></p>
<p><img src="https://img-blog.csdnimg.cn/9d69260c8d1442429d24ca7190dd4e5f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>总结 无监督学习 的要点：<br>1、无监督学习的概念</p>
<pre><code> - 什么叫无监督学习（输入都是无label的数据，没有训练集之说，也就是**只能从一些无label的数据中自己寻找规律**）
 - 无监督学习的两大任务：“化繁为简”（聚类、降维）、“无中生有”
</code></pre><p>2、聚类Clustering（K-means、HAC）<br>3、降维Dimension Reduction（PCA）</p>
</blockquote>
<h1 id="无监督学习的具体分类？"><a href="#无监督学习的具体分类？" class="headerlink" title="无监督学习的具体分类？"></a>无监督学习的具体分类？</h1><p><img src="https://img-blog.csdnimg.cn/a3a3f30810614f508add1fd431cb5047.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="无监督学习的分类"></p>
<ul>
<li>化繁为简：找一个函数，将本来复杂的输入，变成比较简单的输出。<strong>比如找一个函数，可以把所有的树都变成抽象的树</strong>。因此我们拥有一大堆各种不同的图像的数据，但不知它的 output 长什么样子。</li>
<li>无中生有：找一个函数，随机给它一个input（比如一个数字1），然后output一棵树，输入数字2，output另外一棵树，输入3，又是另外一棵树。<strong>输入一个随机数，就自动画一张图出来，不同的数画出来的图不一样</strong>。这个任务里面，要找的可以画图的函数，只有output没有input。只有一大堆的图像，但是不知道输入什么数字才可以得到这些图像。</li>
</ul>
<h2 id="化繁为简包括-聚类"><a href="#化繁为简包括-聚类" class="headerlink" title="化繁为简包括 聚类"></a>化繁为简包括 聚类</h2><p><img src="https://img-blog.csdnimg.cn/436d9bf4a5a94f78b4ed65378066bcec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="K-means聚类"></p>
<blockquote>
<p><strong>Q：什么是 聚类？</strong></p>
<p><font color="red"><strong>假设做图像的聚类，现在有一大堆的图像，然后把它们分成各类</strong>。</font>如上图左边的图像都属于 簇1，右边的图像都属于 簇2，上方的图像都属于 簇3。<strong>这就像给图像贴标签，把类似的图像，都用同一个簇表示</strong>，就做到化繁为简这件事情。</p>
<p><strong>Q：聚类的注意点是什么？</strong><br> 是 这些数据到底有多少个簇！ 这和神经网络需要设计几层一样，是需要算法工程师的个人经验的。</p>
<p><font color="red"><strong>这个簇不能太多也不能太少。</strong> </font>比如多到说9张图像9个簇，那聚类就没有意义，直接每个图像一个簇就好了，或者说全部图像都是一个簇，也跟没有做一样。</p>
</blockquote>
<p>聚类方法最常用的就是K-means，有一大堆未标注数据 $x^{1}$ 到 $x^{n}$ ，每一个 $x$ 代表一张图像，做成 K 个簇。</p>
<h3 id="K-means聚类算法怎么做？"><a href="#K-means聚类算法怎么做？" class="headerlink" title="K-means聚类算法怎么做？"></a>K-means聚类算法怎么做？</h3><p>先找簇的中心，假如每一个对象都用一个向量表示，有 K 个簇就需要 $c^{1}$  到 $c^{K}$  个中心。可以从训练数据里<strong>随机找 K个对象出来作为初始化中心。</strong><br>而后对所有数据，决定属于哪一个簇。假设 $x^{n}$  和 $c^{i}$  最接近，那么 $x^{n}$ 就属于 $c^{i}$ ，用 $b_{n}^{i}$ 表示。然后更新簇，所有属于 $c^{i}$ 的数据做平均，就是第 $i$ 个簇新的中心，更新要反复进行。</p>
<blockquote>
<p><strong>Q：为什么 是从数据集中挑选 K 个样本做初始化 簇中心？</strong><br><strong>答</strong>：之所以从数据集挑选K个样本做初始化簇中心，有一个很重要的原因是，如果是纯粹随机的（不从数据集里挑），那很可能在第一次分配这个簇中心的时候，没有任何一个样本跟这个中心很像，也可以说这个簇没有任何样本，再次更新就会出错。</p>
</blockquote>
<p>K-means 用更简单的话来说：<br>其算法思想大致为：先从样本集中随机选取 K 个样本作为簇中心，并计算所有样本与这 K 个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中，对于新的簇计算各个簇的新的“簇中心”。循环反复。</p>
<blockquote>
<p><strong>Q：总结一下 K-means 算法的 主要流程</strong></p>
<ol>
<li>簇个数 K 的选择</li>
<li>初始化簇中心（可以从你的train data里面随机找K个x出来，就是你的k个center）</li>
<li>while（收敛——聚类结果不再变化）<br>　　{<br>　　　　 各个样本点到“簇中心”的距离 ；<br>  　　 根据新划分的簇，更新“簇中心”（求均值）;<br>　　}</li>
</ol>
</blockquote>
<h3 id="层次凝聚聚类算法（HAC）怎么做？"><a href="#层次凝聚聚类算法（HAC）怎么做？" class="headerlink" title="层次凝聚聚类算法（HAC）怎么做？"></a>层次凝聚聚类算法（HAC）怎么做？</h3><p>首先 我们要做一个树结构 （<strong>其过程 非常像 哈夫曼树的构造</strong>）<br><img src="https://img-blog.csdnimg.cn/463ed5f3dfb84f1bb525e37a39dfd42b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="HAC构建树"></p>
<p>假设有5个样本做层次聚类，先要做一个树结构。计算两两样本的相似度，挑出最相似的数据对。</p>
<p>比如第一个和第二个样本最相似，那就合并（比如用平均值代表），5个样本变为4个样本；再计算相似度，配对的是4，5样本，然后把他们合并（平均值），变成3个样本；接着计算相似度，配对的是黄色数据点和剩下的蓝色数据点，再次合并（平均），最后只剩红色和绿色，那么最后平均起来得到root。根据5笔数和之间的相似度，就建立出了一个树结构。</p>
<p><strong>但树结构只是告诉我们说哪些样本比较像，还没有做聚类。</strong></p>
<blockquote>
<p><strong>Q：那怎么做聚类呢？或者说我怎么看我分的那几个聚类？</strong><br><strong>答</strong>： 看你怎么切，如图上面不同颜色的切线。</p>
<ul>
<li>比如在上图蓝线初切一刀，意味着把数据分成3簇，1、2为一簇，3单独为一簇，4、5为一簇。</li>
<li>在红色线切一刀，则1、2、3为一簇，4、5为一簇。</li>
<li>在绿色点切一刀，则1、2为一簇，3、 4、 5单独为一簇。</li>
</ul>
<p><strong>Q：层次聚类 和 K-means的差别？</strong></p>
<ul>
<li>在K-means里要自己决定K的值，也就是你要分多少个簇。<ul>
<li>在层次聚类里要决定的是在哪里切一刀，如果切比较容易考虑的话，那层次聚类可能更好。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="化繁为简包括-降维"><a href="#化繁为简包括-降维" class="headerlink" title="化繁为简包括 降维"></a>化繁为简包括 降维</h2><blockquote>
<p><strong>Q：什么是降维？</strong><br><strong>答</strong>：降维意思是说，原本高维的东西，其实是可以用低维去表示它。就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。换句话说，可以减少数据的维度。就是 </p>
<script type="math/tex; mode=display">z = Wx</script><p><img src="https://img-blog.csdnimg.cn/0f4adf004785425fa8e753ffc1e8c025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>Q：为什么降维有用？</strong><br><strong>答</strong>：假设数据分布如上图左边，在3D空间里分布是螺旋的样子，但是用3D描述数据分布比较浪费的，直觉上也可以感觉可以摊开变成右边2D的样子，只需要2D的空间就可以描述3D的信息。在3D空间里面解比较麻烦，那就在2D里做这个任务。<br>考虑一个实际的简单栗子：<br>每一个input的数字都是28 × 28的矩阵来描述。但是实际上，多数28 × 28矩阵转成一个图像看起来都不像数字，在28 × 28空间里是数字的矩阵是很少的。所以要描述一个数字，或许不需要用到28 × 28维，远比28 × 28维少。<br><img src="https://img-blog.csdnimg.cn/1d2cd0f03fb540a886301947ef7bef60.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以举一个极端的例子，有一堆3，从像素点看要用28 × 28维来描述每张图像。实际上，只要用一个维度就可以表示，中间的是3，其他的3都是中间的3左转右转10、 20度。所以唯一需要记录的就是中间的3，左转和右转了多少度，即只需要角度的变化，就可以知道28维空间中的变化。</p>
<p><strong>Q：怎么做降维？</strong><br><strong>答</strong>：找一个函数，input是一个向量x，output是另外一个向量z（z的维度比x小）。</p>
<ul>
<li><p>在降维里最简单的方法是特征选择，把数据的分布拿出来看一下，    如在二维平面上发现数据集中在 $x$ 维度，所以 $y$ 这个维度没什么用，那么就把他拿掉，等于是降维这件事。<strong>特征选择不一定有用，有可能case里面任何一个维度都不能拿掉。</strong></p>
</li>
<li><p>另一个常见的方法是<strong>PCA</strong>，函数是一个很简单的线性函数，input x和output z之间的关系就是一个线性的transform，即 $x$ 乘上一个矩阵 $W$ 得到 $z$ 。现在不知道  $z$ 长什么样子，要根据一大堆的 $x$ 把 $W$ 找出来。</p>
</li>
</ul>
</blockquote>
<h3 id="分布式表示（Distributed-Representation）"><a href="#分布式表示（Distributed-Representation）" class="headerlink" title="分布式表示（Distributed Representation）"></a>分布式表示（Distributed Representation）</h3><blockquote>
<p><strong>Q：光做聚类的话是非常以偏概全的。为什么呢？</strong><br><strong>答</strong>：因为在聚类思想中，每个样本都必须属于某一个簇。就好像念力分成6大类，每个人都会被分配到6个大类其中一类。但这样分配太过粗糙，比如某个人的能力既有强化系的特性又有放出系的特性，只分为一类就会丢失很多信息。<img src="https://img-blog.csdnimg.cn/1ee8b3f2f1754e63bdc4826eba1aa3dc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<font color="red">**只分为一类就是以偏概全了，应该要用一个向量来表示每个对象，向量的每个维度代表了某一种特质（属性）。这件事情叫做Distributed Representation**。</font> 比如上图所示，这个人每个系都可以有固定的能力占比。

<font color="green">如果对象是一个高维的东西，例如图像，现在用它的特性来表示，就会把它从高维空间变成低维空间，这件事情叫做降维。</font> Distributed Representation和**降维**是一样的东西，不同的称呼。


### 主成分分析（PCA）
函数是一个很简单的线性函数，input x和output z之间的关系就是一个线性的transform，即 $x$ 乘上一个矩阵 $W$ 得到 $z$ 。现在不知道  $z$ 长什么样子，要根据一大堆的 $x$ 把 $W$ 找出来。

PCA的实现一般有两种：
 - 一种是用特征值分解去实现的
 - 一种是用奇异值分解去实现的

#### PCA-用特征值分解实现
![在这里插入图片描述](https://img-blog.csdnimg.cn/3acdbf6ffca44f85b12bb6a0719ae8c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
刚才讲过PCA要做的事是找 $W$ ，假设一个比较简单的case，考虑一个维度的case。假设要把我们的数据投射到一维空间上，即 $z$ 只是一维的向量。 $w^{1}$ 是W的第一行，和 $x$ （列向量）做内积得到一个标量 $z_{1}$ 。

> **Q：$w^{1}$应该长什么样子？**
> 首先假设 $w^{1}$ 的长度是1，即 $||w^{1}||_{2}=1$ 。如果$||w^{1}||_{2}=1$，$w^{1}$ 是高维空间中的一个向量，那么 $z_{1}$ 就是就是 $x$ 在 $w^{1}$ 上的投影长度。现在要求出每一个 $x$ 在 $w^{1}$ 上的投影，那 $w^{1}$ 应该长什么样子？
举个例子，假设上图右上方是 $x$ 的分布，$x$ 都是二维的，每个点代表一只宝可梦，横坐标是攻击力，纵坐标是防御力。<font color="blue">现在要把二维投影到一维，应该要选什么样的 $w^{1}$ ?</font>  可以选 $w^{1}$ 为上图右上方右斜方向，也可以选左斜方向，**选不同的方向，最后得到的投影的结果会不一样**。

那总要给我们一个目标，我们才知道要选什么样的 $w^{1}$ ，现在目标是经过投影后得到的 $z_{1}$ 的分布越大越好。我们不希望投影后所有的点都挤在一起，把本来数据点之间的奇异度消去。我们希望投影后，数据点之间的区别仍然看得出来，那么我们可以找投影后方差越大的那个 $w^{1}$ 。

看上面的例子，如果是右斜方向，那么方差较大，左斜方向方差则较小，所以更可能选择右斜方向作为 $w^{1}$ 。

从上面的例子里看， $w^{1}$ 代表了宝可梦的强度，宝可梦可能有一个隐藏的向量代表它的强度，这个隐藏的向量同时影响了防御力和攻击力，所以防御力和攻击力会同时上升。
![在这里插入图片描述](https://img-blog.csdnimg.cn/dd45a73b7b0640d1bbb675b9132e5044.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
开始计算：
　　　　1、把方差式子展开，转化成协方差（具体转化过程不描述了）
　　　　2、<font color="red">结论：我们要找的 $w^{1}$ 就是协方差矩阵 $S$ 的最大特征值所对应的特征向量， $w^{2}$ 就是协方差矩阵 $S$ 的第二大特征值所对应的特征向量，以此类推 .</font>

<h4 id="PCA-用奇异值分解（SVD）"><a href="#PCA-用奇异值分解（SVD）" class="headerlink" title="PCA - 用奇异值分解（SVD）"></a>PCA - 用奇异值分解（SVD）</h4><p>特征值分解是一个提取矩阵特征很不错的方法，但是<strong>特征值分解只是对方阵而言的</strong>，在现实的世界中，我们看到的<strong>大部分矩阵都不是方阵</strong>。奇异值分解是一个能适用于任意的矩阵的一种分解的方法。<br><img src="https://img-blog.csdnimg.cn/31679a1b2ba54844b2799661d9c1ff6c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>假设现在考虑手写数字识别，我们知道手写数字其实是由一些基本成分组成的，这些基本成分可能是笔画。例如斜的直线，横的直线，比较长的直线，小圈、大圈等等，这些基本成分加起来以后得到一个数字。</p>
<p>基本成分我们写作 $u^{1},u^{2},u^{3}…$，这些基本的成分其实就是一个一个的向量。考虑 MNIST数据集 ，一张图像是28 × 28像素，就是28 × 28维的向量。基本成分其实也是28 × 28维的向量，把这些基本成分向量加起来，得到的向量就代表了一个数字。</p>
<p>如果写成公式的话，就如上图最下方所示的公式。$x$ 代表某一张图像的像素，用向量表示。$x$ 会等于 $u^{1}$ 这个成分乘上 $c<em>{1}$ ，加上 $u^{2}$ 这个成分乘上 $c</em>{2}$，一直加到 $u^{K}$ 这个成分乘上$c_{K}$，再加上 $\bar{x}$（$\bar{x}$ 是所有图像的平均）。所以每一张图像，就是一堆成分的线性组合加上所有图像的平均所组成的。</p>
<p>例如数字7是 $u^{1},u^{3},u^{5}$ 加起来的结果，那么对数字7来说，公式里的 $c<em>{1}=1 ,c</em>{2}=0, c<em>{3}=1…$，所以可以用  $c</em>{1},c<em>{2},c</em>{3}…,c<em>{K}$ 来表示一张图像，如果成分远比像素维度小的话，那么用$\begin{bmatrix}<br>c</em>{1}\<br>c<em>{2}\<br>…\<br>c</em>{K}\<br>\end{bmatrix}$表示一张图片是会比较有效的比如7可以由向量 $\begin{bmatrix}<br>1\<br>0\<br>1\<br>0\<br>1\<br>…\<br>\end{bmatrix}$ 描述。</p>
<p><img src="https://img-blog.csdnimg.cn/dc78fa3c54bc4b2f94be1efcc5bdf034.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们把公式里的 $\bar{x}$ 移到左边，$x$ 减 $\bar{x}$ 等于一堆成分的线性组合，写作 $\hat{x}$  。</p>
<blockquote>
<p><strong>Q：如果我们不知道K个u（成分）是什么，那怎么找出这K个向量？</strong> 找K个u，让$x−\bar{x}$ 和 $\hat{x}$  越接近越好，$||(x-\bar{x})-\hat{x}||<em>{2}$ 称为重构误差，代表没办法用成分描述的部分。接下来，最小化 $||(x-\bar{x})-\hat{x}||</em>{2}$，损失函数如上图 $L$。</p>
<p>回忆下PCA，$w<em>{1},w</em>{2},w<em>{3}…w</em>{K}$ 是 $x$ 协方差矩阵的特征向量，事实上 $L$ 的解就是PCA的 $w<em>{1},w</em>{2},w<em>{3}…w</em>{K}$。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/cf51702d73ef4fa3ac7f2dd6c47ec6d6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="PCA实例"><a href="#PCA实例" class="headerlink" title="PCA实例"></a>PCA实例</h1><h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><p><img src="https://img-blog.csdnimg.cn/9581a527b4a0468f97458d5954e6bb89.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>以把每一张数字图像拆成成分的线性组合，每一个成分也是一张图像（28 × 28 维的向量），所以可以把成分画在图上变成一张图像。</p>
<font color="blue">通过PCA画出前30个成分如上图所示，白色的地方代表有笔画。用这些成分做线性组合，就可以得到0-9的数字，所以这些成分叫做Eigen-digit。</font> 
Eigen（本征）是说，这些成分都是协方差矩阵的特征向量。

## 人脸识别
![在这里插入图片描述](https://img-blog.csdnimg.cn/9e97b877a5114592ac90e2b7f5f3c0f6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
上图右上方有一大堆人脸，找它们前30个主成分。找出来就如上图最下方所示，每张图像都是哀怨的脸，叫做Eigen-face。把这些脸做线性组合，就可以得到所有的脸。


> **Q：但这边有没有觉得有问题，因为主成分找出来的是成分，但是现在找出来的几乎都是完整的脸，也不像是成分啊？像前面的数字识别，成分看起来也像是玛雅文字，而不是笔画，看起来也不是成分啊？**
![在这里插入图片描述](https://img-blog.csdnimg.cn/1215e23adb994fd6b8380a73b1e64527.png#pic_center)> **答**：仔细想想PCA的特性，$α_{1},α_{2}$ 这种权重可以是任何值，可以是正的，也可以是负的。所以当我们用这些主成分组成一张图像的时候，<font color="blue">可以把这些成分相加，也可以把这些成分相减，这就会导致你找出的东西不见得是一个图的基本的结构。</font>> > 比如我画一个9，那可以先画一个8，然后把下面的圆圈减掉，再把一杠加上去。我们不一定是把成分加起来，也可以相减，<font color="blue">所以说就可以先画一个很复杂的图，然后再把多余的东西减掉。这些成分不见得就是类似笔画的这种东西。</font>
> 
> 如果要得到类似笔画的东西，就要用另一个技术*NMF（非负矩阵分解）*。PCA可以看成是对矩阵X做SVD，SVD就是一种矩阵分解的技术。**如果使用NMF，就会强迫所有成分的权重都是正的，正的好处就是一张图像必须由成分叠加得到，不能说先画一个复杂的东西再去掉一部分，再来就是所有成分的每个维度都必须是正的。**


所以在同样的任务上，例如手写数字的测试上，使用NMF时，找出来的主成分会如下图所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ac0fc298e03847819527bc49a3198b45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
你会发现，白色图案类似于笔画，找出来的主成分就成了笔画了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/36c61755d6ce40318f4df22c47721ab5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
看脸的话，会发现如上图所示。比较像脸的一部分，比如人中、眉毛、嘴唇、下巴。

## 宝可梦
![在这里插入图片描述](https://img-blog.csdnimg.cn/c19d6fca60984ad6a435fd0750f485fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
有800种宝可梦，每种宝可梦可以用6个特征来表示。所以每个宝可梦就是6维的数据点，6维向量。

现在用PCA来分析，PCA里常有的问题是到底需要几个成分，即到底要把数据降到几维。这个一般取决于你的目的是什么，比如你想做可视化，分析宝可梦特性之间的关系，6维没办法可视化的，那就投影到二维。要用几个主成分就好像是神经网络需要几层，每层几个神经元一样。

一个常见决定使用几个主成分的方法是，去计算每个主成分（特征向量）对应的特征值，这个特征值代表在该主成分上投影数据的方差。

现在的例子里宝可梦是6维的，那就有6 × 6维的协方差矩阵，所以有6个特征值，如上图计算每个特征值比例，结果是0.45，0.18，0.13，0.12，0.07，0.04。那第5、6个主成分的作用比较小，意味着投影数据的方差很小，宝可梦的特性在这两个主成分上信息很少。那么分析宝可梦特性只需要前4个主成分。
![在这里插入图片描述](https://img-blog.csdnimg.cn/8fcb23f86b76476e9b66585379b04cbb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)

PCA后选择4个主成分，每个主成分是一个6维向量（因为原来每个特征都要投影，那就有6种投影数据）。

每个宝可梦可以想成是4主成分向量做线性组合的结果，且每只宝可梦组合的权重不同。

看第一个主成分PC1，数值都是正的，如果给它的权重大，意味着宝可梦6维都是强的，给它的权重小，意味着宝可梦6维都是弱的，所以第一个主成分，代表了这只宝可梦的强度。

看第二个主成分PC2，Def防御力是正值，速度是负值，那么增加权重的时候，会增加防御力并减小速度。

把第一个和第二个主成分画出来如上图最下方，图上有800个点，每个点代表一只宝可梦。
![在这里插入图片描述](https://img-blog.csdnimg.cn/995d8f5d622b4b3691e432d0e2554a0e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
第三个主成分PC3，特殊防御力是正的，攻击力和HP都是负的，也就是说这是用攻击力和HP来换取特殊防御力的宝可梦。

第四个主成分PC4，HP是正的，攻击力和防御力是负的，这是用攻击力和防御力换取生命值的宝可梦。

把第三、第四主成分画出来如上图最下方，维度是去相关的。


## 矩阵分解-推荐系统
有时候，你会有两种东西，两种对象，它们之间受到某种共通的潜在因素操控。
假设现在做一个调查，调查每个人手上买的公仔的数目，有5个宅男同学A,B,C,D,E，横轴的公仔人物是凉宫春日、御坂美琴、小野寺、小唯，调查结果如下图。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7557d3f48de34c97be70ec2ca4212e74.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
看这个矩阵可以发现，买凉宫春日的人，比较有可能有御坂美琴；买小野寺的人，也比较有可能买小唯。这说明人和公仔有一些共同的特性，有共同的因素在操控这些事情发生。

动漫宅获取可以分成两种，一种是萌傲娇的，一种萌天然呆的。每个人都是萌傲娇和萌天然呆平面上的一个点，可以用一个向量表示，那么看上图，A是偏萌傲娇。每一个公仔角色，可能有傲娇属性或者天然呆属性，所以每一个角色，也是平面上一个点，可以用一个向量描述。

如果某个人的属性和角色的属性匹配的话，他们背后的向量就很像（比如做内积的时候值很大），那么A就会买很多的凉宫春日。他们匹配的程度取决于潜在因素是不是匹配的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d5f8553af83f4034bbcff5b07c95251a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)


所以ABC的属性如上图最左边所示，A、B是萌傲娇的，B稍微没有那么傲娇，C是萌天然呆。每个动漫角色后面也有傲娇、天然呆这两种属性，如果人物属性和角色属性匹配的话，人买角色的可能性就很大。
![在这里插入图片描述](https://img-blog.csdnimg.cn/006698ec686f439ea7e5161e55e7213f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
上图中右下方矩阵公式中，右边两个矩阵的N应该是M，代表M个人。
我们知道的只有人买的角色的数目，然后凭着这种关系去推论每个人和每个动漫人物背后的潜在因素。每个人背后都有一个向量，代表萌傲娇或者萌天然呆的程度。每个角色后面也有一个序列，代表是傲娇或天然呆的属性。

我们可以把购买的公仔数量合起来看做是一个矩阵X ，行数是人的数量，列数是公仔角色的数量。

现在有一个假设，矩阵X里的每个元素都来自于两个向量的内积。为什么A会有5个凉宫春日的公仔，是因为 $r^{A}·r^{1}$ 的内积很大，约等于5。这件事情用数学公式表达的话，可以把 $r^{A}$ 到 $r^{M}$ 按列排起来，把 $r^{1}$ 到 $r^{4}$ 按行排起来，<font color="red">K是潜在因素的个数，一般没办法知道，需要自己测试出来。</font>

<blockquote>
<p><strong>Q：矩阵X的每个维度是什么？</strong><br>我们要做的事情就是找一组rA到rE，找一组r1到r4 ，让两个矩阵相乘后和矩阵X越接近越好，就是最小化重构误差。这个就可以用SVD来解，把Σ并到左边或右边变成两个矩阵就可以了。<br><img src="https://img-blog.csdnimg.cn/b2a2e51b938840b49fad8bcf3521f71b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>有时候有些信息是缺失的，比如上图所示的，你不知道A、B、C手上有没有小野寺，可能在那个地区没有发行，所以不知道发行的话到底会不会买。那用SVD就很怪，也可以把缺失值用0代替，但也很奇怪。</p>
<p>Q：那有缺失值怎么办呢？<br>可以用梯度下降的方法来做，写一个损失函数，让$r^{i}$（每个人背后的潜在因素）和$r^{j}$（角色背后的潜在因素）的内积和角色购买数量越接近越好。现在重点是，在<br>summation over<br>元素的时候，可以避开缺失的数据，如果值是缺失的，就不计算。有了损失函数后，就可以使用梯度下降了。<img src="https://img-blog.csdnimg.cn/7da15f3364a64482b6e8a8ed3d751acb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>根据刚才的方法实际计算一下，假设潜在因素的数量是2。那么A到E都是二维的向量，每个角色也是二维的向量。<br>数值代表了属性的程度，把大的用红色框框圈出来，会发现A、B萌同一组属性，C、D、E萌同一种属性，1,2有同样的属性，3,4有同样的属性。没有办法知道每个属性代表什么，要先找出这些潜在因素，再去分析它的结果。有了这些潜在因素数据，就可以用来预测缺失值。已经知道了$r^{A}$和$r^{3}$，那只要$r^{A}$和$r^{3}$做内积就可以了。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/d1cb16fb971b456ebe4b9e64b666e212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>之前的model可以做得更精致一点，刚才说A背后的潜在因素乘上 春日 背后的潜在因素，得到的结果就是矩阵里的数值。但是事实上，可能还会有其他因素操控这些数值。<br>那么更精确的写法就可以写成。</p>
<script type="math/tex; mode=display">r^{A}⋅r^{1}+b_{A}+b_{1}≈5</script><p>$b<em>{A}$是跟 $A$ 有关的标量，代表了 $A$ 有多喜欢买公仔，有的人就是喜欢买公仔，也不是喜欢某个角色。$b</em>{1}$是跟 春日 有关的标量，代表了角色有多想让人购买，这个事情是跟属性无关的，本来人就会买这个角色。</p>
<p>然后修改损失函数如上图所示，使用梯度下降求解即可。</p>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
        <tag>无监督学习</tag>
        <tag>聚类</tag>
        <tag>降维</tag>
        <tag>PCA</tag>
        <tag>K-means</tag>
        <tag>HAC</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习 Deep Learning 模型优化</title>
    <url>/2021/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20Deep%20Learning%20%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>@<a href="深度学习 Deep Learning 后续优化">TOC</a></p>
<p><strong>深度学习  怎么评价效果与改进？</strong></p>
<ol>
<li>先检查 训练阶段 是否有比较好的结果<br>training优化方法：
　<ol>
<li>换激活函数（Sigmoid、ReLU、Maxout、Tanh、Softmax）</li>
<li>优化器——优化梯度下降和自适应调学习率（SGD、Adagrad、RMSProp、Momentum、Adam）</li>
</ol>
</li>
<li>training没问题了，再检查testing是否有比较好的结果<br>　testing（过拟合）优化：<ol>
<li>参数在过拟合之前就停止更新</li>
<li>正则化Regularization</li>
<li>dropout</li>
</ol>
</li>
</ol>
<h1 id="如何优化模型"><a href="#如何优化模型" class="headerlink" title="如何优化模型"></a>如何优化模型</h1><h2 id="谈什么才是overfitting？"><a href="#谈什么才是overfitting？" class="headerlink" title="谈什么才是overfitting？"></a>谈什么才是overfitting？</h2><p>首先我们在明确一下，深度学习的流程，其与机器学习基本一致。如下图所示：<img src="https://img-blog.csdnimg.cn/0f42918289e14d23a7c8eada3056de07.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>判断  <em>过拟合</em> 需要看两个数据集上的结果（training set → good， testing set → bad）。<br><strong>在试图解决overfitting之后仍要再看一下training set上的结果！</strong></p>
<blockquote>
<p><strong>误区：</strong><br>不能看见所有不好的 <em>performance</em> 都归因到 <em>overfitting</em>。如只看下右图，不能断言56-layer有 <em>overfitting</em>，要看模型在training set上的表现。根据下左图，可以发现原因是训练的时候没有训练好，即这个层次设计可能本身就是有问题的，不然为啥20层的挺好，56层没道理差啊（这不能叫 <em>underfitting</em>，<em>underfitting</em>：参数不够多，模型能力不足）。<img src="https://img-blog.csdnimg.cn/d9f2b9e2e027466286e85d6b3998b713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="对症下药：训练error，测试error分别用什么方法"><a href="#对症下药：训练error，测试error分别用什么方法" class="headerlink" title="对症下药：训练error，测试error分别用什么方法"></a>对症下药：训练error，测试error分别用什么方法</h2><p>在读到深度学习的方法时，要思考该方法是解决什么问题。<br><strong>是解决training set上的performance不好，还是解决testing set上的performance不好。</strong>比如，Dropout是为了解决testing set上结果不好的问题，如果是training set上结果不好而用Dropout，不会有好的结果。<br>下图是 分别解决各问题，可以采用的方法：<img src="https://img-blog.csdnimg.cn/f74d3b5a294e40648e9f9646b7c8e063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="模型Train阶段Error-具体解决"><a href="#模型Train阶段Error-具体解决" class="headerlink" title="模型Train阶段Error 具体解决"></a>模型Train阶段Error 具体解决</h2><p>如下图是，MNIST手写数字识别，激活函数用sigmoid，training data上的accuracy与层数的关系曲线：<img src="https://img-blog.csdnimg.cn/91b2987e4b43432f88b04cd027a9ec56.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>层数&gt;7时，performance下降，<strong>原因不是 <em>overfitting</em>! 因为train的时候就没train好。</strong><br>那模型压根没有训练好，可以采用的方法上面也给出了包括：换激活函数（Sigmoid、ReLU、Maxout、Tanh、Softmax）。激活函数可能会带来什么样的问题？以sigmoid为例说：会出现梯度消失。</p>
<h3 id="方法一：换激活函数的问题-——-梯度消失"><a href="#方法一：换激活函数的问题-——-梯度消失" class="headerlink" title="方法一：换激活函数的问题 —— 梯度消失"></a>方法一：换激活函数的问题 —— 梯度消失</h3><h4 id="什么是梯度消失"><a href="#什么是梯度消失" class="headerlink" title="什么是梯度消失"></a>什么是梯度消失</h4></blockquote>
<p>有梯度时，参数才会往梯度最小的地方改变；没有梯度了，参数就停止更新了。<br>前面层的学习速率明显低于后面层（后向传播），这就是梯度消失。<img src="https://img-blog.csdnimg.cn/f82182495a2f4ec5bd000941331d346a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="为什么会有梯度消失？"><a href="#为什么会有梯度消失？" class="headerlink" title="为什么会有梯度消失？"></a>为什么会有梯度消失？</h4><blockquote>
<p>角度一： 用sigmoid会出现梯度消失的问题（<strong>参数的变化经过sigmoid会逐层衰减，对最后的loss影响很小</strong>）<br><img src="https://img-blog.csdnimg.cn/052d1db3b2ef4b628a984db51778bf5a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如上图所示，我刚开始增加的△w，由于 <em>sigmoid函数</em> ，自变量越大，改变量越小的缘故。数的变化经过sigmoid会逐层衰减，对最后的loss影响很小。也就是对C的偏导会越来越小，导致梯度接近于0，而消失。</p>
<p>角度二：<br>假设现在存在一个网络结构：<br><img src="https://img-blog.csdnimg.cn/2de3a4da8a8c4ad1b0c6ca4fe6f5787d.png#pic_center" alt="在这里插入图片描述"><br>其整个数学模型可以表示为：<img src="https://img-blog.csdnimg.cn/f0e9bab2192e48d5b30ff91f0cb7ac58.png#pic_center" alt="在这里插入图片描述"><br>若要对于 <em>w1</em><br>求梯度，根据链式求导法则，得到的解为：<img src="https://img-blog.csdnimg.cn/f685ef885b0541198b35f65f257e4296.png#pic_center" alt="在这里插入图片描述"><br>这明显数学模型的值，随着隐层的增加，越来越小。不过这个前提是 原先的w（权重）并不是很大，原本相乘就是小于1的。如果w太大的话，第一项相乘就大于1，这就会导致最后的梯度爆炸。</p>
</blockquote>
<h4 id="如何解决梯度消失问题-——-换ReLU激活函数"><a href="#如何解决梯度消失问题-——-换ReLU激活函数" class="headerlink" title="如何解决梯度消失问题 —— 换ReLU激活函数"></a>如何解决梯度消失问题 —— 换ReLU激活函数</h4><h5 id="ReLU-与-MaxOut"><a href="#ReLU-与-MaxOut" class="headerlink" title="ReLU 与 MaxOut"></a>ReLU 与 MaxOut</h5><p>梯度消失是因为 <em>sigmoid</em> 引起的，要解决当然要换一个激活函数。采用的方法是换 <em>ReLU激活函数</em>（原型 input<0时，输出为0，input>0,输出为原值；可变型）<img src="https://img-blog.csdnimg.cn/44d11711c43a4495af5a232ba87f8df6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>ReLU输出0或x，输出0的ReLU神经元相当于不存在，网络变得瘦长，但是整个网络仍然是<strong>非线性的</strong>，只有当input改变十分微小的时候才是线性的，因为input不同，输出为0的ReLU神经元也不同。</p>
<blockquote>
<p><strong>Q : 为什么ReLU是非线性？明明两端都是线性直线啊？</strong><br>因为ReLU在0点没有导数定义，线性讲究的是在整个定义域内。而在0点处，不可微，所以整体是非线性的。</p>
</blockquote>
<p> ReLU是<strong>Maxout</strong>的特例，Maxout可以学出激活函数。<br><img src="https://img-blog.csdnimg.cn/436e424d5bf8460a9eaecb263ffdc73d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="MaxOut-的训练是怎样的？好在哪？"><a href="#MaxOut-的训练是怎样的？好在哪？" class="headerlink" title="MaxOut 的训练是怎样的？好在哪？"></a>MaxOut 的训练是怎样的？好在哪？</h5><p>下面是一个神经网络的栗子，我们将激活函数换成 <em>MaxOut</em>激活函数。<br><img src="https://img-blog.csdnimg.cn/6b39a8e35978476e96d1eb7d9580c49d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面的图 可以删除不需要的边和点，变为如下的神经网络：<br><img src="https://img-blog.csdnimg.cn/92fa0460f9a84b0689ef391fc257ade0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Q ：如果和上图所示，那我去掉的那些边不是啥用没有？也就是这个权值压根和神经网络没关系呢，不是吗？</strong><br>答 ：当然有关系，因为我们的任务是调参，每个权值和偏值得变化，都会导致 <em>MaxOut激活函数</em> 选择的不同。比如说改变一下 <em>w</em>，他可能会选择 <em>z2</em>呢。</p>
</blockquote>
<h3 id="方法二：优化器-——-优化gd和自适应调学习率（SGD、Adagrad、RMSProp、Momentum、Adam）"><a href="#方法二：优化器-——-优化gd和自适应调学习率（SGD、Adagrad、RMSProp、Momentum、Adam）" class="headerlink" title="方法二：优化器 —— 优化gd和自适应调学习率（SGD、Adagrad、RMSProp、Momentum、Adam）"></a>方法二：优化器 —— 优化gd和自适应调学习率（SGD、Adagrad、RMSProp、Momentum、Adam）</h3><p>寻找最佳参数的方法，调节学习率的方法有（<strong>SGD、Adagrad、RMSProp、Momentum、Adam</strong>）<br>SGD、Adagrad 可以看之前关于 梯度算法进阶的部分 <a href="#">Post not found: 梯度下降算法 进阶</a><br>这边主要讲解一下 RMSProp 和 Momentum</p>
<h4 id="关于-RMSProp"><a href="#关于-RMSProp" class="headerlink" title="关于 RMSProp"></a>关于 RMSProp</h4><h5 id="为什么要使用RMSProp"><a href="#为什么要使用RMSProp" class="headerlink" title="为什么要使用RMSProp"></a>为什么要使用RMSProp</h5><p>　在 <em>Adagrad</em> 中，<font color="red">学习率是跟损失函数对 <em>w</em> 的<strong>二次微分</strong>有关。</font>那么对于图中蓝绿相交的一点来说，因为 <em>w1</em> 所在的曲率相对于 <em>w2</em> 要小，所以 <em>w1</em> 的学习率会比 <em>w2</em> 大。现在单考虑 <em>w1</em>（只看横向），那么二次微分是固定的（碗状），也就是说 <em>w1</em>是根据固定的规则去自动调整 <em>η</em> 的。但是现实中同一方向的二次微分是不固定的，因此对于同一方向去 <em>w1</em>，需要不同的规则去调 <em>η</em>。</p>
<font color=" turquoise">对于一个参数来说，*Adagrad* 是用固定的规则去调 *η*，*RMSProp* 是用变化的规则去调 *η*</font>![在这里插入图片描述](https://img-blog.csdnimg.cn/cc6becd55c104daaa6f8eddadc55eb9d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
##### 如何实现RMSProp
在原来分母这一项中，在过去梯度平方和前面加上权值 *a*，现有的梯度平方加上 *1-a*。
<font color=" turquoise">其在参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得**陡峭的方向变得平缓**，从而加快训练速度）</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/1377f4da7b564c9a89ede8f17577f241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
#### 关于 Momentum
##### Momentum（动量）是用来解决什么问题的？
<font color="red">**这个是用来解决局部最优解的问题的**</font>

<p>说白了就是要延续他的惯性<br><img src="https://img-blog.csdnimg.cn/85f0e0d5d9a540eaa4f68d7c2e13c4ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="如何实现Momentum"><a href="#如何实现Momentum" class="headerlink" title="如何实现Momentum"></a>如何实现Momentum</h5><p>考虑他此时的方向，并保留他的惯性。来调整下一步，最大可能的避免局部最优解。<br><img src="https://img-blog.csdnimg.cn/0201be68528b443bb4b5596d5f27b58d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="关于-Adam"><a href="#关于-Adam" class="headerlink" title="关于 Adam"></a>关于 Adam</h4><p>他其实是一种 <em>Momentum + RMSProp</em> 结合的方法。其具体算法可以看如下图所示：<img src="https://img-blog.csdnimg.cn/c3aff899691d4155b8e47e51420c868e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="模型Train阶段OK-Test阶段Error，即过拟合"><a href="#模型Train阶段OK-Test阶段Error，即过拟合" class="headerlink" title="模型Train阶段OK Test阶段Error，即过拟合"></a>模型Train阶段OK Test阶段Error，即过拟合</h2><h3 id="方法一-：参数在过拟合之前就停止更新（Early-Stopping）"><a href="#方法一-：参数在过拟合之前就停止更新（Early-Stopping）" class="headerlink" title="方法一 ：参数在过拟合之前就停止更新（Early Stopping）"></a>方法一 ：参数在过拟合之前就停止更新（Early Stopping）</h3><font color="red">这里的testing set指的是有label的testing set（即validation set ）。</font>
如果learning rate设得对的话，training set的loss会逐渐降低，而testing set与training set可能分布不同，所以testing set的loss可能先降后升，这时就不要一直train下去，而是要在testing loss最小的地方停止train。这里的testing set 实际指的是**validation set**。

### 方法二 ：正则化Regularization

> **Q ： 首先理解什么是范数，L1（范数为1）和L2（范数为2）是什么？**
> 范数：向量在不同空间中“长度”的计算公式
> L1：绝对值之和
> L2：平方和

#### L2正则化（权值衰减）
![在这里插入图片描述](https://img-blog.csdnimg.cn/8a8facf4f6bf42ebb56f4f657102b5ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
> **Q ： 为什么通常 不考虑 bias？**
> L2正则化让function更平滑，而bias与函数平滑程度没有关系。

![在这里插入图片描述](https://img-blog.csdnimg.cn/35cbdf14ab7049bd9967fcabc1223ae2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)

参数更新：
因为η、λ、n都是正的，**所以 *1−ηλ*小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来**。**当然考虑到后面的导数项，w最终的值可能增大也可能减小**。

<font color="red">正则化在NN中虽有用但不明显。</font>
NN参数初始值一般接近0，update参数即是要参数原理0。L2正则化（让参数接近0）的作用可能与early stopping类似。

> **Q : 为什么参数w衰减能防止过拟合?**
> 答 ：模型过于复杂会导致过拟合。那么越小的w（可以想象成0理解），表示网络复杂度低，越简单的网络结构，就越不会过拟合。比如模型  *y=w1×w1 + w2×w2* 的平方  中把 *w2=0* 代入，模型就会简化，就不会引起过拟合。![在这里插入图片描述](https://img-blog.csdnimg.cn/c8fc90454614466ebee4a2d5a549a25e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
> **Q : 对正则化解决过拟合问题的一些本质理解？**
> 正则化防止过拟合的本质：减少“没用参数”的权值（防止过拟合），同时也减少“有用参数”的权值（会增加bias误差）
> **Q : 什么是有用参数，什么是没用参数？如上图中，怎么就把 *x2* 删去，不把 *x1* 删去呢？**
> 我们姑且假设 *w1* 是有用参数， *w2* 是无用参数，由公式知参数更新值跟权值、梯度值两个因素有关，实际上，无论是 *x1* 还是 *x2* ，权值都会衰减，每update一次参数，权值 *w* 就会衰减一次，但如果是下图的情况，*损失函数Loss* 的减少跟 *w2* 没关系的，所以对其偏导为0，那么 *w2* 的参数更新只跟权值有关了，随着更新次数叠加，权值就会逐渐衰减接近0；对于***有用参数 w1*** ，虽然它权值衰减，但是它其作用的是后面的偏导值，所以它还是不会变成0的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/50e060cb7bc24fbe896ef111e287092b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
#### L1正则化
L1是在Loss函数加上绝对值之和，求偏导后比原始的更新规则多出了η ×λ ×sgn(w)这一项。<font color="turquoise">**当w为正时，更新后的w变小。当w为负时，更新后的w变大（一加一减）——因此它的效果就是让w往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合**</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/113c9ac61f5946c783a434a07f8d52e9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)

#### L1和L2相比
L1 update的速度是*|ηλ||ηλ|* （划横线那项每次改变量是一定的）。而 L2 update 的速度与w的t有关（如果wt  很大，那么改变量也很大）。
用L1做training，结果比较sparse(稀疏的)，参数中有很多接近0的值，也有很多很大的值。
L2 learn的结果：参数值平均来讲比较小。

### Dropout 
**Dropout也是为了简化神经网络结构的目的**，但L1、L2正则化是通过修改代价函数来实现的，而Dropout则是通过修改神经网络本身来实现的。
#### dropout是如何实现的
在training的时候，每次update参数之前，对每一个Neuron（包括input_layer）做sampling，决定这个Neuron按一定几率p丢掉，跟它相连的weight也被丢掉，结果得到一个细长的Network。（每一次update一个mini-batch之前，拿来traing的Network structure是不一样的）。

换句话说input layer中每个element也算是一个neuron.
每次更新参数之前都要resample.
**用dropout，在training上的结果会变差，但在testing上的结果会变好。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/196bfc65730b4cb6b5877bcbc0a40729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
<font color="red">在**testing的时候不做dropout，所有neuron都要用**。
如果training时的删除神经元的概率为p%，则在testing时，所有的weight都要乘以（1-p）%</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/2c2491b39cef4452b88c9c465a8a1cbe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
#### Dropout的原理 
![在这里插入图片描述](https://img-blog.csdnimg.cn/27c81c02d95847c2a5776da769696c54.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)

> **Q : 为什么当在做 *testing* 的时候，weights需要都乘以 *(1-p)%*  (p是Dropout的概率)？**
>
> 答：如下图所示，左侧是在 *Traing* 阶段，*w2* 与 *w4* 由于丢失几率和丢掉(几率是这里是0.5)，假设神经元此时都是1，这时输出的应该是 *w1+w3*；右侧是在 *Testing* 阶段，在这个阶段要保证所有的神经元都不做 *Dropout* 。所以变成了w1+w2+w3+w4，约等于变成了左侧的两倍；所有取所有weight都要乘以（1-0.5）。

实际上，dropout是利用ensemble思想，把一个复杂神经网络的训练转化为，训练很多个简单的神经网络，然后再把多个简单神经网络训练出来的参数做平均。
![在这里插入图片描述](https://img-blog.csdnimg.cn/96b24fb760ee4d65b18862bc7bcf4ee0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
一个复杂model, bias准，但variance大，把多个复杂model ensemble起来，variance变小。
每个dropout后的结构由一个batch来train，但是权重是共享的，每个权重是由多个batch 来train的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/32d269be253c4f1790664d3b5c88caca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2prczg4OTk1NjU2,size_16,color_FFFFFF,t_70#pic_center)
<font color="red">**在testing的时候，把多个结构的结果取平均，与把所有参数乘以(1 - p%)，效果是近似的。**
**Dropout用在ReLU、Maxout上效果较好。**</font>

<blockquote>
<p><strong>Q : 为什么 Dropout 在testing的时候，把多个结构的结果取平均，与把所有参数乘以(1 - p%)，效果是近似的？ 而不是相同</strong><br>答：因为神经元之间的层次，使用的激活函数不一定都是线性的，只有线性的情况下才会是相同的。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习基础-李宏毅</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>深度学习</tag>
        <tag>模型优化</tag>
      </tags>
  </entry>
</search>
