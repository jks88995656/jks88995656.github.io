<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue 的前端面试题 | 一只柴犬</title><meta name="keywords" content="Vue"><meta name="author" content="凯凯超人"><meta name="copyright" content="凯凯超人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue 的前端面试题考点1：理解Vue面试题：v-model的作用和实现原理是什么？v-binde 是数据只能从data流向页面的  单向数据绑定 语法：v-bind:href &#x3D;&quot;xxx&quot; 或简写为 :href v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。 语法：v-mode:value&#x3D;&quot;xxx&quot; 或简写">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 的前端面试题">
<meta property="og:url" content="http://example.com/2023/03/20/Vue%20%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/index.html">
<meta property="og:site_name" content="一只柴犬">
<meta property="og:description" content="Vue 的前端面试题考点1：理解Vue面试题：v-model的作用和实现原理是什么？v-binde 是数据只能从data流向页面的  单向数据绑定 语法：v-bind:href &#x3D;&quot;xxx&quot; 或简写为 :href v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。 语法：v-mode:value&#x3D;&quot;xxx&quot; 或简写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg">
<meta property="article:published_time" content="2023-03-20T15:22:01.000Z">
<meta property="article:modified_time" content="2023-03-20T10:54:18.000Z">
<meta property="article:author" content="凯凯超人">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://example.com/2023/03/20/Vue%20%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue 的前端面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-20 18:54:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="一只柴犬" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/admin.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一只柴犬</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue 的前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-20T15:22:01.000Z" title="发表于 2023-03-20 23:22:01">2023-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-20T10:54:18.000Z" title="更新于 2023-03-20 18:54:18">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue 的前端面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Vue-的前端面试题"><a href="#Vue-的前端面试题" class="headerlink" title="Vue 的前端面试题"></a>Vue 的前端面试题</h1><h2 id="考点1：理解Vue"><a href="#考点1：理解Vue" class="headerlink" title="考点1：理解Vue"></a>考点1：理解Vue</h2><h3 id="面试题：v-model的作用和实现原理是什么？"><a href="#面试题：v-model的作用和实现原理是什么？" class="headerlink" title="面试题：v-model的作用和实现原理是什么？"></a>面试题：v-model的作用和实现原理是什么？</h3><p>v-binde 是数据只能从data流向页面的  单向数据绑定</p>
<p>语法：<code>v-bind:href =&quot;xxx&quot;</code> 或简写为 <code>:href</code></p>
<p>v-model本质上不过是语法糖，可以用 v-model 指令在<strong>表单</strong>及<strong>元素</strong>上创建<strong>双向数据绑定</strong>。</p>
<p>语法：<code>v-mode:value=&quot;xxx&quot;</code> 或简写为 <code>v-model=&quot;xxx&quot;</code> </p>
<p>其实现的原理为：</p>
<ol>
<li>v-bind:绑定响应式数据</li>
<li>触发oninput 事件并传递数据</li>
</ol>
<blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;sth&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;sth&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event 指代当前触发的事件对象;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target 指代当前触发的事件对象的dom;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target.value 就是当前dom的value值;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在@input方法中，value =&gt; sth;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在:value中,sth =&gt; value;--&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="面试题：如何理解-Vue的-MVVM-机制"><a href="#面试题：如何理解-Vue的-MVVM-机制" class="headerlink" title="面试题：如何理解 Vue的  MVVM 机制"></a>面试题：如何理解 Vue的  MVVM 机制</h3><p>MVVM 是 Model-View-ViewModel 的缩写， </p>
<ul>
<li>Model 代表数据模型， 定义数据操作的业务逻辑， 对应Vue中 data中的数据</li>
<li>View 代表 UI 组件， 它负责将数据模型转化成 UI 展现出来， 也就是页面的 dom</li>
<li>ViewModel 通过双向绑定把 View 和Model 进行同步交互，不需要手动操作 DOM 的一种设计思想。<strong>Vue实例对象，其中包含数据绑定和Dom监听两部分。</strong></li>
</ul>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ截图20221218001832.png" style="zoom: 80%;" /></p>
<p>在 html 代码中，可以形象的概括为如下图所示：</p>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ截图20221218002608.png" style="zoom:80%;" /></p>
<h3 id="面试题：Vue-2中-双向绑定（响应式）实现的原理"><a href="#面试题：Vue-2中-双向绑定（响应式）实现的原理" class="headerlink" title="面试题：Vue 2中 双向绑定（响应式）实现的原理"></a>面试题：Vue 2中 双向绑定（响应式）实现的原理</h3><p>采用<strong>数据劫持结合发布者- 订阅者模式</strong>的方式， 通过 <code>Object.defineProperty</code>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 data 选项时， Vue 将遍历它的属性， 用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖， 在属性被访问和修改时通知变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 用于响应获取</span></span><br><span class="line">    get () &#123;&#125;,</span><br><span class="line">    <span class="comment">// 用于响应修改</span></span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法（7个）来实现拦截。（对数组的变更方法进行了包裹）。其实质是 通过重写数组的Array.prototype对应的方法，具体来说就是重新指定要操作数组的prototype，并重写该prototype中对应上面的7个数组方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methods = [<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>,<span class="string">&#x27;unshift&#x27;</span>,<span class="string">&#x27;sort&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>,<span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;push&#x27;</span>];</span><br><span class="line"><span class="comment">// 复制Array.prototype，并将其prototype指向Array.prototype</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype);</span><br><span class="line">methods.forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    proto[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 重写proto中的数组方法</span></span><br><span class="line">        <span class="built_in">Array</span>.prototype[method].call(<span class="built_in">this</span>, ...arguments);</span><br><span class="line">        viewRender() <span class="comment">// 视图更新</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123; <span class="comment">// 数组实现响应式</span></span><br><span class="line">                obj.__proto__ = proto; <span class="comment">// 改变传入数组的prototype</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                ... <span class="comment">// 对象的响应式实现</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<font color="red"><Strong>没有用于响应 添加和删除的方法</Strong></font>
</li>
<li><p><strong>存在问题：</strong></p>
<ul>
<li><p>对象新增属性、删除属性, 界面不会更新，因为 Vue2 监测不到。</p>
<font color="blue">**这是因为在 Vue实例创建时，person.sex并未声明，所以就没有Vue转换为响应式的属性，自然就不会触发视图的更新。**</font>

<p><strong>新增属性</strong></p>
<p>例如现在有一个 对象person，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.person.sex = <span class="string">&quot;女&quot;</span>   <span class="comment">// 无效，因为Vue2 监测不到</span></span><br></pre></td></tr></table></figure>
<p>解决办法，使用 <code>$set</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.person,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;女&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>删除属性</strong></p>
<p>例如现在有一个 对象person，里面有一个 name 属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.person.name   <span class="comment">// 无效，因为Vue2 监测不到</span></span><br></pre></td></tr></table></figure>
<p>解决办法，使用 <code>$delete</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$delete(<span class="built_in">this</span>.person, <span class="string">&quot;name&quot;</span>) </span><br></pre></td></tr></table></figure>
<blockquote>
<p>delte会删除数组的值，但是它依然会在内存中占位置<br>而vue.delete会删除数组在内存中的占位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span> arr1[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">this</span>.$delete(arr2,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">//【1, empty, 3】</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">//【1,2】</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>直接通过下标修改数组, 界面不会自动更新。</p>
<p>例如 现在有一个 hobby 数组，我想修改第一个元素的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hobby[<span class="number">0</span>] = <span class="string">&quot;逛街&quot;</span>  <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>
<p>解决办法 两种办法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 $set</span></span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.hobby, <span class="number">0</span>, <span class="string">&quot;逛街&quot;</span>)</span><br><span class="line"><span class="comment">// 使用 数组 API</span></span><br><span class="line"><span class="built_in">this</span>.hobby.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;逛街&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="面试题：Vue-3中-双向绑定（响应式）实现的原理？-并说明为啥Vue-2-的不太好"><a href="#面试题：Vue-3中-双向绑定（响应式）实现的原理？-并说明为啥Vue-2-的不太好" class="headerlink" title="面试题：Vue 3中 双向绑定（响应式）实现的原理？ 并说明为啥Vue 2 的不太好"></a>面试题：Vue 3中 双向绑定（响应式）实现的原理？ 并说明为啥Vue 2 的不太好</h3><p>实现原理: </p>
<ul>
<li>通过<strong>Proxy（代理）</strong>:  Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</li>
<li>通过<strong>Reflect（反射）</strong>:  对源对象的属性进行操作。其用于替换 Object.defineProperty，更加的工程化，因为其可以返回 true or false。</li>
</ul>
<p>Vue 3中 读取和修改对象数据的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;name：<span class="string">&quot;凯凯&quot;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="comment">// p 相当于 数据代理了 person</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person,&#123;</span><br><span class="line">    <span class="comment">//有人读取p的某个属性时调用  target 为源数据也就是 person  propName是操作的属性</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target,propName</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`有人读取了p身上的<span class="subst">$&#123;propName&#125;</span>属性`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,propName)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//有人修改p的某个属性、或给p追加某个属性时调用    value为需要修改的值</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target,propName,value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`有人修改了p身上的<span class="subst">$&#123;propName&#125;</span>属性，我要去更新界面了！`</span>)</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target,propName,value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//有人删除p的某个属性时调用</span></span><br><span class="line">    <span class="function"><span class="title">deleteProperty</span>(<span class="params">target,propName</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`有人删除了p身上的<span class="subst">$&#123;propName&#125;</span>属性，我要去更新界面了！`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target,propName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.name              <span class="comment">// 获取方法，调用 get 方法</span></span><br><span class="line">p.name = <span class="string">&quot;凯凯超人&quot;</span>  <span class="comment">// 修改方法，调用 set 方法  【p 和 person 全改】</span></span><br><span class="line">p.sex = <span class="string">&quot;男&quot;</span>        <span class="comment">// 添加方法，调用 set 方法  【p 和 person 全改】</span></span><br><span class="line"><span class="keyword">delete</span> p.sex        <span class="comment">// 删除方法，调用 deleteProperty  【p 和 person 全改】</span></span><br></pre></td></tr></table></figure>
<p>与 Vue2 比的优势在于：</p>
<ul>
<li><p><strong>对于 对象的响应式：</strong></p>
<p>Vue2 中实现的原理 Object.defineProperty 只能遍历对象属性进行劫持，无法检测到 直接对于对象属性中的添加和删除。想要实现添加和删除，不要分别使用 $set 和 $delete 这两个 vm 的实例方法</p>
<p>Vue 3中的 Proxy 可以劫持整个对象，并返回一个新对象，通过操作新对象来达到响应式的目的。所以我可以直接修改对象里面的内容。</p>
</li>
<li><p><strong>对于 数组的响应式：</strong></p>
<p>Vue 2中 <code>Object.defineProperty</code> 无法监控到数组下标及数组长度的变化，其通过 <font color="orange"><strong>包裹数组</strong></font> 更新元素的方法实现，本质就是做了两件事：</p>
<ul>
<li>调用原生对应的方法对数组进行更新。也就是原生 JS 对数组进行改变的方法 。</li>
<li>重新解析模板，进而更新页面。</li>
</ul>
<p>​    或者使用 <code>Vue.set()</code> 和 <code>vm.$set()</code></p>
<p>Proxy可以直接监控数组的变化（push、shift、splice 等原生数组API即可）,</p>
</li>
<li><font color="blue">Vue 3中 Proxy 有多达13种拦截方法，不限于 apply、ownkeys、deleteProperty、has等等，这是 Vue 2中`Object.defineProperty` 不具备的。</font>
</li>
<li><p>Vue 2中 data 如果数据较多 且深的时候 <code>Object.defineProperty</code> 要深度遍历data中的每个属性，将其设置为响应式（即配置 getter/setter），性能较差。</p>
<p><strong>Vue 3中 Proxy只在 getter 时才对对象的下一层进行劫持（优化了性能），真正访问到的内部对象才会变成响应式。</strong> </p>
<p><strong>数据劫持也就是 给数据绑定上 setter 和 getter 方法。</strong></p>
</li>
</ul>
<h3 id="面试题：Vue-data-中某一个属性比那花，视图会立即同步执行重新渲染么？"><a href="#面试题：Vue-data-中某一个属性比那花，视图会立即同步执行重新渲染么？" class="headerlink" title="面试题：Vue data 中某一个属性比那花，视图会立即同步执行重新渲染么？"></a>面试题：Vue data 中某一个属性比那花，视图会立即同步执行重新渲染么？</h3><p>不会。</p>
<p>Vue实现响应式并不是在监听到数据发生变化后，DOM立即变化。而是按照一定的策略进行DOM的更新。Vue在更新DOM时 是异步执行的，只要监听到数据的变化，Vue就会开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个 watcher 被多次触发，只会被推入到这个队列中一次。然后再缓冲中去除重复数据对于避免不必要的计算和DOM操作时非常重要的。</p>
<p>然后，在下一个的事件循环tick中，Vue刷新队列并执行实际（已经去过重的）工作。</p>
<h3 id="面试题：什么是虚拟-DOM？"><a href="#面试题：什么是虚拟-DOM？" class="headerlink" title="面试题：什么是虚拟 DOM？"></a>面试题：什么是虚拟 DOM？</h3><ul>
<li>虚拟DOM 是描述真实DOM 结构及其属性信息的 JS 对象。</li>
<li>使用 虚拟DOM 能够有效减少直接操作 DOM 的次数，改为查找 JS 对象的属性变化，从而提高程序的性能。 （我的理解是，这里表达的是 diff算法的意思，diff算法会比对前后两份 DOM 的属性变化，如果属性发生变化之后，才会重新创建对应的虚拟DOM结点，否则就用原来的）</li>
<li>使用 虚拟DOM 可以实现跨平台，根据虚拟DOM 可以渲染成不同平台上对应的内容，如原生APP（Android、ios），小程序、浏览器等。</li>
<li>虚拟 DOM 通过 diff 算法，将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，最终在真实 DOM中局部渲染。</li>
</ul>
<h3 id="面试题：Vue的-解释虚拟化DOM-diff-算法？-理解循环中的-key-机制？"><a href="#面试题：Vue的-解释虚拟化DOM-diff-算法？-理解循环中的-key-机制？" class="headerlink" title="面试题：Vue的 解释虚拟化DOM + diff 算法？ 理解循环中的 key 机制？"></a>面试题：Vue的 解释虚拟化DOM + diff 算法？ 理解循环中的 key 机制？</h3><p>为什么 key 最好不要使用 索引值，而最好是数据里的唯一 id 呢？ 因为会造成模板的渲染错误，其原理与 虚拟DOM的形成和 diff算法有关。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ图片20221221181526.png" alt=""></p>
<p>其具体的解释步骤可以概括为如下：</p>
<ol>
<li>Vue会针对data中的persons数组，初始化虚拟DOM结点，其顺序是根据 我们 <strong>v-for指定的 :key 这里也就是索引来排序的</strong></li>
<li>然后会将虚拟DOM转化为真实DOM结点，进行页面渲染</li>
<li>此时，我们填好对应的input数据，再我们点击了 button 在 persons数组 前面添加了一条数据</li>
<li>然后 Vue 对新的数据再次生成虚拟DOM，还是按照 :key 也就是索引来排序，此时他发现之前已经有一份对应的虚拟DOM了，这个时候执行diff对比算法，再进行渲染。<ul>
<li>对比原则为，<strong>首先对比右侧第一行，key = 0， 再去左边找key = 0 的发现</strong> 原先是张山-18  新的是老刘-30，那我不对啊<strong>我要生成一个新的真实DOM结点</strong>，之前的不能用了，而后面的 input 框发现两者是一致的（这里不会考虑用户输入的 value的），那Vue表示，那我不需要再生成一个新的DOM了啊，我拿旧的就可以了（然而旧的里面）。此时生成第一条混乱数据   老刘-30  input(张三-18)  就是这么来的。</li>
</ul>
</li>
<li>那之后两条都是，到最后一条 key =3 ，那左边没有3的奥，那我两个部分真实DOM全部需要生成。</li>
</ol>
<h3 id="面试题：简单聊聊-new-Vue-以后发生的事情"><a href="#面试题：简单聊聊-new-Vue-以后发生的事情" class="headerlink" title="面试题：简单聊聊 new Vue 以后发生的事情"></a>面试题：简单聊聊 new Vue 以后发生的事情</h3><ol>
<li><p>new Vue会调用 Vue 原型链上的_init方法对 Vue 实例进行初始化；</p>
</li>
<li><p>首先是initLifecycle初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化；</p>
</li>
<li><p>initEvents，初始化当前实例上的一些自定义事件（Vue.$on）；</p>
</li>
<li><p>initRender，解析slots绑定在 Vue 实例上，绑定createElement方法在实例上；</p>
</li>
<li><p>完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；</p>
</li>
<li><p>initInjections，在初始化data和props之前完成依赖注入（类似于 React.Context）；</p>
</li>
<li><p>initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）；</p>
</li>
<li><p>initProvide，对依赖注入进行解析；</p>
</li>
<li><p>完成对数据（state 状态）的初始化后，触发生命周期钩子created；</p>
</li>
<li><p>进入挂载阶段，将 vue 模板语法通过vue-loader解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子beforeMount；</p>
</li>
<li><p>将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子mounted；</p>
</li>
</ol>
<h3 id="面试题：Vue模板编译的原理"><a href="#面试题：Vue模板编译的原理" class="headerlink" title="面试题：Vue模板编译的原理"></a>面试题：Vue模板编译的原理</h3><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/QQ截图20230306022826.png" alt=""></p>
<h2 id="考点2：Vue的属性内容考点"><a href="#考点2：Vue的属性内容考点" class="headerlink" title="考点2：Vue的属性内容考点"></a>考点2：Vue的属性内容考点</h2><h3 id="面试题：Vue-中-watch-和-computed-使用差异是什么？"><a href="#面试题：Vue-中-watch-和-computed-使用差异是什么？" class="headerlink" title="面试题：Vue 中 watch 和 computed 使用差异是什么？"></a>面试题：Vue 中 watch 和 computed 使用差异是什么？</h3><p><strong>计算属性：</strong></p>
<ul>
<li>计算属性会自动追踪响应式依赖，当响应式数据改变的时候，会重新计算并缓存计算结果。  （实际表现看起来和 data 很类似）<strong>computed 和 methods 的差异是它具有缓存性，方法调用总是会在重渲染发生时再次执行函数。</strong></li>
<li>计算属性默认时只读的，当需要用到 “可写”的属性，可以通过同时提供 getter 和 setter来创建。</li>
<li><font color="red">计算属性 getter 时无法做异步请求或者更改 DOM的，只能用于计算。</font>



</li>
</ul>
<p><strong>监视属性：</strong></p>
<p><strong>无缓存性</strong></p>
<ul>
<li><p>使用监视属性 在每次响应式状态发生变化时，触发回调函数，可以在回调中执行异步操作等复杂逻辑。</p>
</li>
<li><p>通过设置 <code>immediate:true</code> 可以在监视测创建时立即触发回调函数， 可以设置 <code>deep:true</code>来进行深度监视。</p>
<p>监视属性的回调函数默认发生在DOM更新之前，指明 <code>flush:&quot;post&quot;</code>，可以让监视器 回调中能访问被 Vue 更新之后的DOM（这是目的，说<strong>白了就是 可以异步执行回调函数，相当于我DOM已经更新完成了，我再调用这个方法</strong>） </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监视多级结构中所有属性的变化</span></span><br><span class="line"><span class="attr">numbers</span>:&#123;</span><br><span class="line">    <span class="attr">immediate</span>:<span class="literal">true</span>, <span class="comment">//初始化时让先handler调用一下</span></span><br><span class="line">    <span class="attr">deep</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">newInfo,oldInfo</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;numbers改变了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>总结应用场景：</strong></p>
<ul>
<li><p>当数值需要进行计算，并且依赖于其他数据。应该使用 computed，因为可以利用 computed 的缓存特性。</p>
</li>
<li><p>当需要在数据变化时，执行异步或开销较大的操作时。使用watch。</p>
</li>
</ul>
<h3 id="面试题：v-if-和-v-show-的区别"><a href="#面试题：v-if-和-v-show-的区别" class="headerlink" title="面试题：v-if 和 v-show 的区别"></a>面试题：v-if 和 v-show 的区别</h3><p><strong>v-show</strong></p>
<p>v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。</p>
<p><strong>v-if</strong></p>
<p><strong>在首次</strong>渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。</p>
<p><strong>所以 v-if  适合运营条件不大可能改变的情况， v-show 适合频繁切换</strong></p>
<h2 id="考点3：-Vue的生命周期函数"><a href="#考点3：-Vue的生命周期函数" class="headerlink" title="考点3： Vue的生命周期函数"></a>考点3： Vue的生命周期函数</h2><h3 id="面试题：vue生命周期中异步加载在mouted还是create里实现"><a href="#面试题：vue生命周期中异步加载在mouted还是create里实现" class="headerlink" title="面试题：vue生命周期中异步加载在mouted还是create里实现"></a>面试题：vue生命周期中异步加载在mouted还是create里实现</h3><p>一般来说，可以在，<strong>created，mounted中都可以发送数据请求，但是，大部分时候，会在created发送请求。</strong><br>Created的使用场景：如果页面首次渲染的就来自后端数据。因为，此时data已经挂载到vue实例了。<br>在 created（如果希望首次选的数据来自于后端，就在此处发请求）（只发了异步请求，渲染是在后端响应之后才进行的）、beforeMount、mounted（在mounted中发请求会进行二次渲染） 这三个钩子函数中进行调用。<br>因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是<strong>最常用的是在 created 钩子函数中调用异步请求</strong>，因为在 created 钩子函数中调用异步请求有两个优点：</p>
<ul>
<li>第一点：能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。</li>
</ul>
<blockquote>
<p>在 Vue.js 中，SSR 是指将 Vue 应用程序渲染为 HTML 字符串，并在服务器上进行初始渲染，然后将其发送到客户端进行交互。</p>
<p>SSR（Server-Side Rendering）在服务器端渲染 Vue.js 应用程序时，使用的是 Node.js 环境而不是浏览器环境。由于 Node.js 没有浏览器中提供的 DOM 和浏览器 API，因此在 SSR 期间无法执行与 DOM 相关的操作，例如在 beforeMount 和 mounted 钩子函数中更新 DOM。</p>
<p>在 SSR 期间，Vue.js 会在服务器上渲染组件并返回 HTML 字符串，然后在浏览器端重新挂载和激活组件。因此，beforeMount 和 mounted 钩子函数只会在浏览器中执行，而不会在服务器上执行。</p>
<p>为了在 SSR 和客户端应用程序中保持一致性，Vue.js 提供了其他生命周期钩子函数，例如 created 和 mounted 钩子函数，可以在服务器和客户端上都执行。在这些钩子函数中，您可以执行与 DOM 无关的操作，例如在 created 钩子函数中进行数据预取，以便在组件挂载时使用。</p>
</blockquote>
<h3 id="面试题：讲一讲Vue的生命钩子有哪几个，每个阶段在干什么？"><a href="#面试题：讲一讲Vue的生命钩子有哪几个，每个阶段在干什么？" class="headerlink" title="面试题：讲一讲Vue的生命钩子有哪几个，每个阶段在干什么？"></a>面试题：讲一讲Vue的生命钩子有哪几个，每个阶段在干什么？</h3><p><strong>红圈mounted 之前属于挂载流程， 红圈mounted 属于更新流程，红圈mounted 之后属于 销毁流程</strong> </p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/生命周期.png" alt=""></p>
<p>详细的说，分为 开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程</p>
<p><strong>关于销毁Vue实例</strong> （destroyed）</p>
<ol>
<li>.销毁后借助Vue开发者工具看不到任何信息。</li>
<li><strong>销毁后自定义事件会失效，但原生DOM事件依然有效（<font color="red">现在高版本的Vue2.0，也无效</font>）。</strong></li>
<li>一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了。(因为更新流程已经被杀死了，没有办法再调准到之前的步骤)</li>
</ol>
<h3 id="面试题：如何理解-nextTick？"><a href="#面试题：如何理解-nextTick？" class="headerlink" title="面试题：如何理解 $nextTick？"></a>面试题：如何理解 $nextTick？</h3><ul>
<li><code>this.$nextTick(回调函数)</code> <strong>在下一次 DOM 更新结束后执行其指定的回调。可以传递一个回调函数作为参数，或者await 返回的 Promise。</strong></li>
<li>Vue中如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，<strong>等同一事件循环中发生的所有数据变更完成后，再统一对视图进行更新</strong>。此时如果想要获取更新后的DOM状态，就可以使用 <code>$nextTick</code></li>
<li>使用场景：在 created 或 setup 中想要获取 DOM 时，在响应式数据变化后获取 DOM更新后的状态时。</li>
</ul>
<h3 id="面试题：既然函数是引用类型，为什么-vue-的-data-还是可以用函数"><a href="#面试题：既然函数是引用类型，为什么-vue-的-data-还是可以用函数" class="headerlink" title="面试题：既然函数是引用类型，为什么 vue 的 data 还是可以用函数"></a>面试题：既然函数是引用类型，为什么 vue 的 data 还是可以用函数</h3><p>JavaScript只有函数构成作用域(注意理解作用域，<strong>只有函数{}构成作用域</strong>,对象的{}以及if(){}都不构成作用域),data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</p>
<p>换句话说就是，Vue组件可能会存在多个实例，如果使用对象形式定义data的话，会导致她们共用一个data对象的情况，那么状态变更将会影响所有组件实例。</p>
<p>这非常的不合理，但是如果采用函数形式的话，在initData的时候其将会作为工厂函数返回全新的data对象，有效避免了多实例之间状态污染的问题。</p>
<h2 id="考点4：-Vue-的组件通信"><a href="#考点4：-Vue-的组件通信" class="headerlink" title="考点4： Vue 的组件通信"></a>考点4： Vue 的组件通信</h2><p><img src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128629803/500809B9BD071EA8067678D9EC046261" alt="img"></p>
<p>有props和$emit、<img src="https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&amp;preview=true" alt="img">listeners、v-model、provide和inject、全局事件总线、parent和children、boradcast和dispatch（这种是 vue1.0使用的 ，现在不常用) 和 vuex处理组件之间的数据交互</p>
<h3 id="面试题：父子组件之间时如何通信的？"><a href="#面试题：父子组件之间时如何通信的？" class="headerlink" title="面试题：父子组件之间时如何通信的？"></a>面试题：父子组件之间时如何通信的？</h3><p><strong>父组件将数据传递给子组件</strong></p>
<font color="blue">使用 props 方法， 父组件通过注册标签传递，子组件 props属性进行接受。</font>

<p>所有的 props 都遵循单项绑定原则，即单向数据流，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的属性状态的情况。</p>
<p><strong>子组件将数据传递给父组件</strong></p>
<p>主要有两种主流方法：</p>
<ul>
<li><p>方法一：在父组件标签中绑定一个自定义事件，然后子组件使用 $emit 方法去触发自定义事件，顺便带上自己的数据参数传递过去</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 父组件绑定自定义事件</span><br><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">v-on:sendName</span>=<span class="string">&quot;printStudentName&quot;</span> <span class="attr">:parm</span>=<span class="string">&quot;2&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">// 子组件中 methods函数 去$emit触发自定义事件</span><br><span class="line">sendStudentName2()&#123;</span><br><span class="line">	//触发Student组件实例身上的 sendName 事件</span><br><span class="line">	this.$emit(&#x27;sendName&#x27;, this.studentName,this.parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过父组件的 ref 属性来绑定自定义事件（这个绑定实际需要在 生命函数 mounted中进行绑定），然后子组件同样使用 $emit 方法去触发自定义事件，顺便带上自己的数据参数传递过去。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 ref 声明自定义事件</span><br><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">ref</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">:parm</span>=<span class="string">&quot;3&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">// 父组件 mounted 生命周期函数</span><br><span class="line">mounted() &#123;</span><br><span class="line">	// 两个参数分别为 自定义事件名  和  自定义绑定的接受参数的回调函数</span><br><span class="line">	this.$refs.stu.$on(&quot;sendName&quot;,this.printStudentName) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件中 methods函数 去$emit触发自定义事件</span><br><span class="line">sendStudentName2()&#123;</span><br><span class="line">	//触发Student组件实例身上的 sendName 事件 </span><br><span class="line">	this.$emit(&#x27;sendName&#x27;, this.studentName,this.parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两种方法的 解绑自定义均为：</p>
<ul>
<li>全部解绑  <code>this.$off(事件名)</code></li>
<li>解绑一个  <code>this.$off(&quot;sendName&quot;)</code></li>
<li>解绑多个  <code>this.$off([&quot;sendName&quot;,&quot;test&quot;])</code></li>
</ul>
<h3 id="面试题：父传子-ref-refs"><a href="#面试题：父传子-ref-refs" class="headerlink" title="面试题：父传子   ref/refs"></a>面试题：父传子   ref/refs</h3><p><code>ref</code> 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/ref_refs.png" style="zoom: 80%;" /></p>
<h3 id="面试题：父子之间互传-parent-children"><a href="#面试题：父子之间互传-parent-children" class="headerlink" title="面试题：父子之间互传 $parent/$children"></a>面试题：父子之间互传 $parent/$children</h3><p>使用 <code>$parent</code> 可以让组件访问父组件的实例（<strong>访问的是上一级 父组件的属性和方法</strong>）</p>
<p>使用 <code>$children</code> 可以让组件访问子组件的实例，<strong>但是 $children 并不能保证顺序，并且访问的数据也不是响应的</strong>。</p>
<p> <img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/parent_children.png" alt=""></p>
<h3 id="面试题：隔代-祖传子-传递-attrs-和-listeners"><a href="#面试题：隔代-祖传子-传递-attrs-和-listeners" class="headerlink" title="面试题：隔代  祖传子 传递 $attrs 和 $listeners"></a>面试题：隔代  祖传子 传递 $attrs 和 $listeners</h3><ul>
<li>$attrs: 继承所有的父组件属性（除了 prop 传递的属性 class 和 style），一般用在子组件的子元素上</li>
<li>$listeners:该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承分组件的事情）</li>
</ul>
<h3 id="面试题：Vue3-0-中祖传孙-provide-inject？"><a href="#面试题：Vue3-0-中祖传孙-provide-inject？" class="headerlink" title="面试题：Vue3.0 中祖传孙  provide/inject？"></a>面试题：Vue3.0 中祖传孙  provide/inject？</h3><p>provide 与 inject  <strong>祖先组件 传递数据给 孙子组件</strong></p>
<p>如果祖先和孙子中间隔了好几代，就不适合使用 props，需要中间传好几层</p>
<p>父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
<ul>
<li><ol>
<li><p>祖组件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    provide(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代组件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = inject(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="面试题：任意组件通信-全局事件总线通信-bus-on？"><a href="#面试题：任意组件通信-全局事件总线通信-bus-on？" class="headerlink" title="面试题：任意组件通信 全局事件总线通信  $bus $on？"></a>面试题：任意组件通信 全局事件总线通信  $bus $on？</h3><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
<p><strong>安装全局事件总线：</strong></p>
<p>使用 vm 作为中间商对象，因为其含有需要的属性，并且任意的组件都可以访问到这个实例。（原型的原因）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Vue.prototype.$bus = <span class="built_in">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">   &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
<p><strong>如何使用：</strong></p>
<p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">demo</span>(<span class="params">data</span>)</span>&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="built_in">this</span>.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供数据：提供数据的组件 触发事件传递数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
<p><strong>如何解绑</strong></p>
<p>最好在beforeDestroy钩子中，用$off去解绑 <strong>接受数据端的 自定义事件</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.$off(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong></p>
<p>全局事件总线，可以让任何两个组件之间互相传递数据，但是吧，如果对于同一个数据，所有的组件之间的通信，就要写很多全局事件挂在 vm上，非常的冗余。</p>
<p>所以引入了数据管理器  VueX。</p>
<h2 id="考点5：如何理解-VueX？"><a href="#考点5：如何理解-VueX？" class="headerlink" title="考点5：如何理解 VueX？"></a>考点5：如何理解 VueX？</h2><h3 id="面试题：如何理解VueX？其使用场景是什么？"><a href="#面试题：如何理解VueX？其使用场景是什么？" class="headerlink" title="面试题：如何理解VueX？其使用场景是什么？"></a>面试题：如何理解VueX？其使用场景是什么？</h3><p><strong>是一种特殊的组件通信方式</strong>，<font color="blue">说白了就是 要实现 对共享数据（状态）的 方便读写，因为事件总线对 不同组件之间读写共享数据，是读写分离的，代码写起来比较麻烦，特别是对应一个共享数据（状态），很多组件都要使用的情况。</font></p>
<p>如下两个情况下，适合使用 Vuex</p>
<ul>
<li><p>多个组件依赖于同一状态 </p>
</li>
<li><p>来自不同组件的行为需要变更同一状态</p>
</li>
</ul>
<p>vuex是一种状态管理机制，将全局组件的共享状态抽取出来为一个store，以一个单例模式存在，<strong>应用任何一个组件中都可以使用</strong>，vuex更改state的唯一途径是通过mutation，mutation需要commit触发, action实际触发是mutation，<strong>其中mutation处理同步任务，action处理异步任务。</strong></p>
<h3 id="面试题：VueX-有哪几个部分组成，是干什么的？以及如何使用VueX"><a href="#面试题：VueX-有哪几个部分组成，是干什么的？以及如何使用VueX" class="headerlink" title="面试题：VueX 有哪几个部分组成，是干什么的？以及如何使用VueX"></a>面试题：VueX 有哪几个部分组成，是干什么的？以及如何使用VueX</h3><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/vuex.png" alt=""></p>
<p>Vuex的属性包含以下6个：</p>
<p>1）state</p>
<p>state是存储的单一状态，是存储的基本数据。</p>
<p>2）Getters</p>
<p>其类似于  在组件中的 计算属性 computed，但是计算属性只能作用于自己一个vue。没有共享的效果，因为针对的是共享数据，所以使用 <code>getters</code> 可是实现共享读。</p>
<p>3）Mutations</p>
<p>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）</p>
<p>4）Actions</p>
<p>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）</p>
<p>5）Module</p>
<p>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</p>
<p><strong>如何使用 VueX</strong></p>
<p>在src 内创建文件夹 store 创建文件：<code>src/store/index.js</code>   （官方推荐写法）</p>
<ul>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code> <strong>（如下为 实际需要使用模块化+ 命名空间）</strong></p>
<font color="blue">**一般配置为 actions中的方法为 小写字母， mutations 中的方法为 大写字母 以示区别。**</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间,不设置没法用map读</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> actions = &#123;</span><br><span class="line">        <span class="comment">//响应组件中加的动作 context是个miniStore</span></span><br><span class="line">       <span class="function"><span class="title">jia</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">          context.commit(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">       &#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mutations = &#123;</span><br><span class="line">        <span class="comment">//执行加</span></span><br><span class="line">       <span class="function"><span class="title">JIA</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">          state.sum += value</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">bigSum</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> state.sum * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">   <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">   store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>组件中读取vuex中的数据（state 或者 getters）：例如<code>$store.state.sum</code></p>
<p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code>  或者 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code>。</p>
<p>后一种是跳过了 actions  直接使用 mutations</p>
<p><strong>图中的后两步都是自动执行的 真正数据修改和 模板render</strong></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code>，也就是<code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
</blockquote>
<h3 id="面试题：了解-Vuex-的辅助函数么？讲讲你的理解。"><a href="#面试题：了解-Vuex-的辅助函数么？讲讲你的理解。" class="headerlink" title="面试题：了解 Vuex 的辅助函数么？讲讲你的理解。"></a>面试题：了解 Vuex 的辅助函数么？讲讲你的理解。</h3><p>有4个辅助函数，她们的主要目的是简化我们读取 Vuex state 和 getters 中数据，和简化我们使用 actions 和 mutations 的方法。</p>
<p>因为我每次template需要显示 state里的某个 XXX  都要  $store.state.XXX 非常的麻烦。所以其有对应的 mapState 和 mapGetters 函数来简化我们的写法，将state 和 getters 数据映射到 计算属性中。</p>
<ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）推荐这样</span></span><br><span class="line">    ...mapState([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">    <span class="comment">// 如果使用了模块化 和命名空间 前面的参数指定你是来自哪个vuex 的store模块</span></span><br><span class="line">    ...mapState(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...mapGetters(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）推荐这样</span></span><br><span class="line">    ...mapGetters([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">    <span class="comment">//如果使用了模块化 和命名空间 前面的参数指定你是来自哪个vuex 的store模块</span></span><br><span class="line">    ...mapGetters(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同理如果我们想要修改state中的数据，使用 $store.dispatch(‘action中的方法名’,数据) 或者 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code>，也是非常的麻烦的。</p>
<p>所以 Vuex 提供了 mapActions 和 mapMutations ，可以将 触发actions 和 直接触发 mutations 对应的方法，直接映射到 methods 的某一简写方法中</p>
<ol>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...mapActions(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：jiaOdd、jiaWait（数组形式）</span></span><br><span class="line">    ...mapActions([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">    <span class="comment">//前面的参数指定你是来自哪个vuex 的store模块  当然使用对象形式也可以</span></span><br><span class="line">    ...mapActions(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...mapMutations(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...mapMutations([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">    <span class="comment">//前面的参数指定你是来自哪个vuex 的store模块  当然使用对象形式也可以</span></span><br><span class="line">    ...mapMutations(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：<strong>在模板中绑定事件时传递好参数，否则参数是事件对象。</strong></p>
</blockquote>
<h3 id="面试题：Vuex实现原理"><a href="#面试题：Vuex实现原理" class="headerlink" title="面试题：Vuex实现原理"></a>面试题：Vuex实现原理</h3><p><strong>store是怎么注册的?</strong></p>
<p>我们看到Vuex在vue 的生命周期中的初始化钩子前插入一段 Vuex 初始化代码。给 Vue 的实例注入一个 $store的属性，这也就是为什么我们在 Vue 的组件中可以通过this.$store.xxx, 访问到 Vuex 的各种数据和状态。 说的就是 main.js 中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">   <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">   <span class="comment">// 这里啦</span></span><br><span class="line">   store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>mutations，commit 是怎么实现的</strong></p>
<ol>
<li>说明 “mutations” 的实现原理，即它是一个纯函数，接收当前状态和负载作为参数，并返回一个新的状态对象，而不会直接修改原状态。</li>
<li>说明 “commit” 的实现原理，即它是一个方法，用于触发指定的 mutation 的执行，从而修改状态。在执行 mutation 前，Vuex 会检查该 mutation 是否存在，以确保应用程序的状态不被意外修改。</li>
</ol>
<p>现实可以举的例子：</p>
<blockquote>
<p>假设你正在开发一个电子商务网站，你需要在多个组件中共享用户购物车中的商品列表。如果使用Vuex，你可以将购物车商品列表存储在Vuex的状态树中。通过在组件中使用getter来获取购物车商品列表，使用mutation来修改购物车商品列表，使用action来发起异步请求更新购物车商品列表，使用commit来触发mutation的执行。</p>
<p>例如，当用户在商品详情页中点击“加入购物车”按钮时，你可以触发一个名为“ADD_TO_CART”的mutation来将商品添加到购物车商品列表中。该mutation将接收当前状态和商品负载作为参数，并返回一个新的状态对象。接着，你可以在购物车页面中使用getter来获取购物车商品列表，并显示出来。</p>
<p>这样，当购物车商品列表的状态发生变化时，所有相关的组件都会自动更新。同时，你可以在Vuex的状态树中添加其他属性，如用户登录状态、支付状态等，以实现更复杂的应用程序状态管理需求。</p>
</blockquote>
<p><strong>辅助函数的实现都差不太多，在这里了解一下mapState</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义辅助函数 mapState</span></span><br><span class="line"><span class="keyword">const</span> mapState = <span class="function">(<span class="params">stateKeys</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stateObj = &#123;&#125;</span><br><span class="line">  stateKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    stateObj[key] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> stateObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：mutation和action有什么区别？"><a href="#面试题：mutation和action有什么区别？" class="headerlink" title="面试题：mutation和action有什么区别？"></a>面试题：mutation和action有什么区别？</h3><p>Mutation是更改 Vuex 的 store 中的状态的唯一方法。在action中调用<code>$store.commit</code>来触发Mutation。</p>
<p>Action 类似于 mutation，不同在于：<strong>Action 提交的是 mutation，而不是直接变更状态</strong>。Action 可以包含任意异步操作。通过 <code>$store.dispatch</code>来触发Action。</p>
<h3 id="面试题：为什么-mutation是同步的，而action是异步的？"><a href="#面试题：为什么-mutation是同步的，而action是异步的？" class="headerlink" title="面试题：为什么 mutation是同步的，而action是异步的？"></a>面试题：为什么 mutation是同步的，而action是异步的？</h3><p>在Vuex中，mutation是同步的，而action是异步的。这是因为mutation用于更改state，而state是一个同步的状态。当我们在mutation中更改state时，这种更改必须是同步的，以便我们能够准确地知道state的值是什么，并且能够在我们的应用程序中正确地使用它。</p>
<p>另一方面，action可以用于异步任务，例如发出网络请求或执行定时任务。这些任务可能需要等待一段时间才能完成，因此将它们放在mutation中会阻塞我们的应用程序，导致UI不响应或无响应的情况。因此，我们可以使用action来处理这些异步任务，并在任务完成后调用相应的mutation来更改state。</p>
<p>总之，mutation和action的不同在于它们被设计用于不同的任务。mutation用于同步的状态更改，而action用于异步任务的处理，以便我们的应用程序可以在执行这些任务时保持响应性。</p>
<h3 id="面试题：Vuex-和-localStorage-的区别是什么？"><a href="#面试题：Vuex-和-localStorage-的区别是什么？" class="headerlink" title="面试题：Vuex 和 localStorage 的区别是什么？"></a>面试题：Vuex 和 localStorage 的区别是什么？</h3><ul>
<li>数据持久性：Vuex 存储的数据是在内存中维护的，只在当前会话中有效。而 localStorage 是浏览器提供的本地存储机制，可以将数据永久地存储在用户的浏览器中，即使用户关闭了浏览器或重新打开了一个新的标签页，存储的数据也不会消失。</li>
<li>数据可见性：Vuex 存储的数据只能在当前应用程序中共享和使用，不能被其他应用程序或其他网站访问到。而 localStorage 存储的数据是全局可见的，可以被任何网站或应用程序访问和使用。</li>
<li>存储容量：Vuex 存储的数据量通常较小，因为它主要用于在组件之间共享状态和数据。而 localStorage 可以存储更多的数据，但也有存储容量的限制，通常为 5-10 MB 左右。</li>
<li>数据格式：Vuex 存储的数据通常是 JavaScript 对象或数组，可以轻松地进行读取、更新和删除操作。而 localStorage 存储的数据必须是字符串格式，需要进行序列化和反序列化才能读取、更新和删除。</li>
</ul>
<p>总之，Vuex 和 localStorage 是两个不同的概念，它们在数据的持久性、可见性、存储容量和数据格式等方面存在较大差异。在实际开发中，应根据实际需求选择合适的存储方案。如果需要在应用程序中共享状态和数据，可以使用 Vuex；如果需要将数据永久保存在用户的本地浏览器中，可以使用 localStorage。</p>
<h2 id="考点6：-Vue-router-路由"><a href="#考点6：-Vue-router-路由" class="headerlink" title="考点6： Vue-router 路由"></a>考点6： Vue-router 路由</h2><h3 id="面试题：路由跳转和location-href的区别？"><a href="#面试题：路由跳转和location-href的区别？" class="headerlink" title="面试题：路由跳转和location.href的区别？"></a>面试题：路由跳转和location.href的区别？</h3><p>使用location.href=’/url’来跳转，简单方便，但是刷新了页面；<br>使用路由方式跳转，无刷新页面，静态跳转；</p>
<h3 id="面试题：如何理解-Vue-router-缓存路由组件-keep-alive-生命周期函数？"><a href="#面试题：如何理解-Vue-router-缓存路由组件-keep-alive-生命周期函数？" class="headerlink" title="面试题：如何理解 Vue-router 缓存路由组件   keep-alive 生命周期函数？"></a>面试题：如何理解 Vue-router 缓存路由组件   <code>keep-alive</code> 生命周期函数？</h3><p>有时候客户想要保存之前输入的数据，例如当前input 框的输入，那就不能再切换到其他组件的时候，因为切换到其他组件 当前组件会被销毁，原来dom结点中的值也被销毁了。Vue的 keep-alive标签 就可以解决这个问题。</p>
<p>Vue 的keep-alive 是一个Vue.js的一个内置组件，其实现组件缓存，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p>
<p>keep-alive 的实质原理为，<strong>Vue 的缓存机制</strong>并不是直接存储 DOM 结构，而是将 DOM 节点抽象成了一个个 VNode节点，所以，keep- alive的缓存也是基于VNode节点的而不是直接存储DOM结构。</p>
<p>其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。</p>
<p>其有两个属性 <code>include</code> 和 <code>exclude</code></p>
<p><strong>include属性</strong>：字符串或正则表达式。只有名称匹配的组件会被缓存。</p>
<p><strong>exclude属性</strong>： 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</p>
<font color="red">注意 里面的字符串，对应的是 Vue 组件中的 **name 属性**！！</font>

<ul>
<li>设置<code>keep-alive</code>的可缓存组件最大数, <code>prop</code>属性名为<code>max</code>，通过设置<code>max</code>，可以控制可缓存组件的最大数。这是一个 基于 LRU 算法的缓存，如果缓存的实例对象即将超过指定那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :max=&quot;max&quot;&gt;</span><br><span class="line">	&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>当一个组件在 keep-alive 中被切换时，会触发改组件实例对象的 activated 和 deactivated 生命周期函数，用来替代 mounted 和 unmounted。每次进入这个页面组件，都会触发<code>activated</code>生命周期，而且每次退出的时候会触发<code>deactivated</code>生命周期。</p>
<h3 id="面试题：Vue-router-两个新的生命周期钩子-active-和-deactive-的使用理解？"><a href="#面试题：Vue-router-两个新的生命周期钩子-active-和-deactive-的使用理解？" class="headerlink" title="面试题：Vue-router 两个新的生命周期钩子  active 和 deactive 的使用理解？"></a>面试题：Vue-router 两个新的生命周期钩子  <code>active</code> 和 <code>deactive</code> 的使用理解？</h3><font color="red">路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</font>

<p><strong>其解决的问题在于：</strong></p>
<p>之前使用了 <code>keep-alive</code> 标签来缓存路由组件，使得客户在切换其他组件的时候，不销毁当前组件，以保证原有填写数据的缓存。</p>
<p><strong>但是，由于没有销毁组件，一些定时器等会一直执行（因为 <code>beforeDestoryed</code>生命周期函数根本无法执行），非常占用内存。</strong></p>
<p>在路由中，其专门有两种生命周期函数来解决这个问题。</p>
<ul>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发，也就是切换到别的组件去展示了。</li>
</ul>
<p>举个例子，例如在 activated的时候我们创建了一个 <code>setTimeOut</code>，则需要在 deactivated 的时候清除这个定时器。</p>
<ul>
<li></li>
</ul>
<h3 id="面试题：什么是路由守卫？"><a href="#面试题：什么是路由守卫？" class="headerlink" title="面试题：什么是路由守卫？"></a>面试题：什么是路由守卫？</h3><p>作用：对路由进行权限控制</p>
<p>解决问题：也就是根据用户缓存的信息，判断是否可以显示等操作，其实就是所谓的守卫  就是 <strong>验证权限</strong></p>
<p>分为三种：<font color="blue">全局守卫、独享守卫、组件内守卫</font></p>
<h4 id="前置-后置-全局守卫"><a href="#前置-后置-全局守卫" class="headerlink" title="前置/后置 全局守卫"></a>前置/后置 全局守卫</h4><p>全局守卫分为 前置和后置守卫两种</p>
<ul>
<li>前置守卫一般用于校验用户信息，是否可以执行到下一vue页面。写的时候注意一定要写<code>next()</code> 进行放行。 </li>
<li>后置守卫一般用于改变浏览器标题等，用的比较少。<strong>因为是在每次路由切换完毕再执行</strong>，所以肯定是已经切换完的，因此没有 <code>next</code> 这个参数方法。</li>
</ul>
<p>将 src 目录下的 route 目录中的 index.js 文件，创建路由进行赋值，再进行全局守卫配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局前置路由守卫   初始化的时候被调用、每次路由切换之前被调用</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">/* must call `next` */</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;前置路由&quot;</span>, to, <span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.meta.isAuth)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;school&quot;</span>) === <span class="string">&quot;hangzhou Dianzi University&quot;</span>)&#123;</span><br><span class="line">			next()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			alert(<span class="string">&quot;当前学校名不对,无权限查看&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局后置路由守卫   初始化的时候被调用、每次路由切换之后被调用</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.title = to.meta.title || <span class="string">&quot;案例系统&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="独享守卫"><a href="#独享守卫" class="headerlink" title="独享守卫"></a>独享守卫</h4><p>独享守卫，也就是针对某一个单独的路由组件，设置权限。</p>
<p>使用 <code>beforeEnter</code> 方法，定义在路由内部。<font color="blue">注意：独享守卫没有后置方法。</font></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;newsVue&quot;</span>,</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">            <span class="attr">component</span>:News,</span><br><span class="line">            <span class="attr">meta</span>:&#123;<span class="attr">title</span>:<span class="string">&quot;新闻&quot;</span>&#125;,</span><br><span class="line">            <span class="function"><span class="title">beforeEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">                <span class="comment">/* must call `next` */</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;school&quot;</span>) === <span class="string">&quot;hangzhou Dianzi University&quot;</span>)&#123;</span><br><span class="line">                    next()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    alert(<span class="string">&quot;当前学校名不对&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h4 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h4><p>组件内守卫是 针对于 使用路由规则，进入和离开的  回调函数（类似于生命周期函数）</p>
<p>分为两种，分为：</p>
<ul>
<li><p>beforeRouteEnter：通过路由规则，进入该组件时被调用</p>
<p>其基本和 之前的前置全局守卫 和 独享守卫一模一样</p>
</li>
<li><p>beforeRouteLeave：离开守卫：通过路由规则，离开该组件时被调用</p>
<font color="red">**这个注意不是 后置守卫，其指的是路由离开这个组件后调用，不是指的切换之后。**</font>

</li>
</ul>
<p>其配置在需要守卫的  vue 文件中，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;NewsVue&quot;</span>,</span><br><span class="line">...</span><br><span class="line">      <span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">      <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">          <span class="comment">/* must call `next` */</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;我进入了 news组件&quot;</span>)</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;school&quot;</span>) === <span class="string">&quot;hangzhou Dianzi University&quot;</span>)&#123;</span><br><span class="line">              next()</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              alert(<span class="string">&quot;当前 school 没有权限&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">      <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">          <span class="comment">/* must call `next` */</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;我离开news组件了去了&quot;</span>,to.name)</span><br><span class="line">          next()</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：-Vue-路由模式有哪几种？"><a href="#面试题：-Vue-路由模式有哪几种？" class="headerlink" title="面试题： Vue 路由模式有哪几种？"></a>面试题： Vue 路由模式有哪几种？</h3><p>实际有三种模式，hash模式、history模式 和 memory模式</p>
<ul>
<li>url的hash，就是通常所说的锚点#，javascript通过hashChange事件来监听url的变化，IE7以下需要轮询。比如这个 URL：<a target="_blank" rel="noopener" href="http://www.abc.com/#/hello，hash">http://www.abc.com/#/hello，hash</a> 的值为#/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此<strong>改变 hash 不会重新加载页面</strong>。</li>
<li>HTML5的History模式，它使url看起来像普通网站那样，以“/”分割，没有#，单页面并没有跳转。不过使用这种模式需要服务端支持，服务端在接收到所有请求后，都只想同一个html文件，不然会出现404。因此单页面应用只有一个html，整个网站的内容都在这一个html里，通过js来处理。</li>
<li>在实现上不管时哪种模式，<strong>最终都是通过监听 propstate 事件来触发路由跳转处理</strong>，url显示不同只是在显示效果上的差异。</li>
</ul>
<h3 id="面试题：HashRouter-和-HistoryRouter的区别和原理"><a href="#面试题：HashRouter-和-HistoryRouter的区别和原理" class="headerlink" title="面试题：HashRouter 和 HistoryRouter的区别和原理"></a>面试题：HashRouter 和 HistoryRouter的区别和原理</h3><p><strong>vue-router</strong>是Vue官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。vue-router默认 hash 模式，还有一种是history模式。</p>
<p>原理：</p>
<ol>
<li><p>hash路由：</p>
<p><strong>hash模式的工作原理是hashchange事件</strong>，<strong>可以在window监听hash的变化</strong>。</p>
<p>我们在url后面随便添加一个#xx触发这个事件。vue-router默认的是hash模式—使用URL的hash来模拟一个完整的URL,于是当URL改变的时候,页面不会重新加载,也就是单页应用了,当#后面的hash发生变化,不会导致浏览器向服务器发出请求,浏览器不发出请求就不会刷新页面,并且会触发hasChange这个事件,通过监听hash值的变化来实现更新页面部分内容的操作</p>
<p>对于hash模式会创建hashHistory对象,在访问不同的路由的时候,会发生两件事:<br><strong>HashHistory.push()将新的路由添加到浏览器访问的历史的栈顶,和HasHistory.replace()替换到当前栈顶的路由</strong></p>
<p>两种模式可以用如下图所示：</p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/QQ截图20230125202753.png" style="zoom: 50%;" /></p>
</li>
<li><p>history路由：</p>
<p>主要使用HTML5的pushState()和replaceState()这两个api结合window.popstate事件（监听浏览器前进后退）来实现的pushState() 可以改变url地址且不会发送请求, replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改</p>
</li>
</ol>
<h3 id="面试题：js是如何监听HistoryRouter的变化的"><a href="#面试题：js是如何监听HistoryRouter的变化的" class="headerlink" title="面试题：js是如何监听HistoryRouter的变化的"></a>面试题：js是如何监听HistoryRouter的变化的</h3><p>通过浏览器的地址栏来改变切换页面，前端实现主要有两种方式：</p>
<ul>
<li>通过hash改变，利用window.onhashchange 监听。</li>
<li>在</li>
</ul>
<p>在JavaScript中，可以使用<code>window.addEventListener</code>方法监听浏览器的<code>popstate</code>事件来监听<code>HistoryRouter</code>的变化。当用户点击浏览器的前进或后退按钮时，或者通过JavaScript代码调用<code>history.pushState()</code>或<code>history.replaceState()</code>方法来修改浏览器的历史记录时，<code>popstate</code>事件会被触发。</p>
<p>下面是一个简单的示例代码，展示如何使用<code>window.addEventListener</code>方法监听<code>popstate</code>事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;History state changed&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当用户点击浏览器的前进或后退按钮时，或者通过JavaScript代码调用<code>history.pushState()</code>或<code>history.replaceState()</code>方法来修改浏览器的历史记录时，控制台会输出<code>History state changed</code>这条信息。</p>
<p>在事件处理函数中，可以通过<code>event.state</code>属性来获取当前历史记录的状态对象。这个状态对象可以是任何JavaScript对象，它可以在调用<code>history.pushState()</code>或<code>history.replaceState()</code>方法时传递进去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;History state changed:&#x27;</span>, event.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，控制台会输出<code>History state changed:</code>以及当前历史记录的状态对象。</p>
<h3 id="面试题：vue-router-实现懒加载"><a href="#面试题：vue-router-实现懒加载" class="headerlink" title="面试题：vue-router 实现懒加载"></a>面试题：vue-router 实现懒加载</h3><p><strong>懒加载</strong>：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>要实现 Vue Router 的懒加载，可以使用 Webpack 的代码分割功能和异步组件。在实际开发中也推荐使用异步组件（这个方法来自于 chatGPT）</p>
<ol>
<li><p>安装 <code>@babel/plugin-syntax-dynamic-import</code> 和 <code>@vue/cli-plugin-babel</code> 依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-syntax-dynamic-import @vue/cli-plugin-babel</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 <code>babel.config.js</code> 文件以启用 <code>@babel/plugin-syntax-dynamic-import</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-syntax-dynamic-import&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在路由配置中，将路由组件更改为异步组件。例如，将以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./components/Foo.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Foo</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./components/Foo.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此更改告诉 Webpack 在需要时异步加载 <code>./components/Foo.vue</code> 文件，而不是在应用程序初始化时立即加载它。</p>
<p>通过这种方式，Vue.js 应用程序可以更快地加载，并且只在需要时加载组件代码，而不是一次性加载所有代码。</p>
<h2 id="考点7：修改ElementUI-样式的几种方式"><a href="#考点7：修改ElementUI-样式的几种方式" class="headerlink" title="考点7：修改ElementUI 样式的几种方式"></a>考点7：修改ElementUI 样式的几种方式</h2><ol>
<li><p>新建全局样式表</p>
<p>新建 global.css 文件，并在 main.js 中引入。 </p>
<p>global.css 文件一般都放在 src-&gt;assets 静态资源文件夹下的 style 文件夹下，在 main.js 的引用写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/style/global.css&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 global.css 文件中写的样式，无论在哪一个 vue 单页面都会覆盖 ElementUI 默认的样式。</p>
<font color="blue">第一种全局引入css文件的方式，适合于对elementUI整体的修改，比如整体配色的修改；</font>
</li>
<li><p>在当前-vue-单页面中添加一个新的style标签  </p>
<p>在当前的vue单页面的style标签后，添加一对新的style标签，新的style标签中不要添加scoped属性。在有写scoped的style标签中书写的样式不会覆盖 ElementUI 默认的样式。</p>
<font color="blue">第二种添加一个style标签的形式，也能够实现修改默认样式的效果，但实际上因为是修改了全局的样式，因此 在不同的vue组件中修改同一个样式有可能会有冲突。</font>
</li>
<li><font color="red">**使用/deep/深度修改标签样式**  极力推荐</font>

<p>找到需要修改的 ElementUI 标签的类名，然后在类名前加上<strong>/deep/</strong>，可以强制修改默认样式。这种方式可以直接用到有scoped属性的 style 标签中。</p>
<font color="blue">第三种方式通过 **/deep/** 的方式可以很方便的在vue组件中修改默认样式，也不会于其他页面有冲突。</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改级联选择框的默认宽度</span></span><br><span class="line">/deep/ .el-cascader &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过内联样式 或者 绑定类样式覆盖默认样式 <strong>不推荐</strong></p>
<font color="blue">第四种方式局限性比较大，可以使用，但不推荐使用。</font>









</li>
</ol>
<h2 id="考点8：Vue的优势"><a href="#考点8：Vue的优势" class="headerlink" title="考点8：Vue的优势"></a>考点8：Vue的优势</h2><h3 id="面试题：jquery-和-vue相比"><a href="#面试题：jquery-和-vue相比" class="headerlink" title="面试题：jquery 和 vue相比"></a>面试题：jquery 和 vue相比</h3><p>通俗的来说 jquery 就是对 dom 操作进行了封装，实际还是 dom操作。</p>
<p>而 Vue 其利用了 MVVM的架构，完美了分离了数据和视图，通过声明式渲染和响应式数据绑定的方式来帮助我们完全避免了对 DOM 的操作。</p>
<h3 id="面试题：Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢"><a href="#面试题：Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢" class="headerlink" title="面试题：Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?"></a>面试题：Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</h3><p>现代前端框架有两种方式侦测变化，一种是 <strong>pull</strong> ，一种是 <strong>push</strong></p>
<p><strong>pull:</strong> 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p>
<p><strong>push:</strong> Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher</p>
<p>一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。</p>
<h3 id="面试题：vue单页面和传统的多页面区别？"><a href="#面试题：vue单页面和传统的多页面区别？" class="headerlink" title="面试题：vue单页面和传统的多页面区别？"></a>面试题：vue单页面和传统的多页面区别？</h3><p>单页面应用（SPA）</p>
<p><strong>通俗一点说就是指只有一个主页面的应用</strong>，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA）</p>
<p>指一个应用中有多个页面，页面跳转时是整页刷新</p>
<p><strong>单页面的优点：</strong></p>
<p>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p>
<p><strong>单页面缺点：</strong></p>
<p><strong>不利于seo</strong>；导航不可用，如果一定要导航需要自行实现前进、后退。<strong>（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</strong>；初次加载时耗时多；页面复杂度提高很多。</p>
<h2 id="面试题：-Vue的响应式指的是什么？"><a href="#面试题：-Vue的响应式指的是什么？" class="headerlink" title="面试题： Vue的响应式指的是什么？"></a>面试题： Vue的响应式指的是什么？</h2><p>底层是通过 <code>Object.definePropery</code> 实现，然后再中间去做了一些这些监听的机制，订阅发布者模式等，结合他的一个deep（深拷贝）更新的一个机制去实现响应式的。</p>
<h2 id="面试题：如何理解-Vue-的MVVM机制"><a href="#面试题：如何理解-Vue-的MVVM机制" class="headerlink" title="面试题：如何理解 Vue 的MVVM机制"></a>面试题：如何理解 Vue 的MVVM机制</h2><p>MVVM就是一种框架的设计架构，view-model model view 。</p>
<p>主要的优势在于<strong>Vue和model 之间双向数据绑定的</strong>，视图改变数据会改变，数据改变了视图也会改变。</p>
<h2 id="面试题-响应式数据在哪里定义？"><a href="#面试题-响应式数据在哪里定义？" class="headerlink" title="面试题 : 响应式数据在哪里定义？"></a>面试题 : 响应式数据在哪里定义？</h2><p>肯定是在 data里进行定义的。</p>
<p>不在 data 中定义的数据，是非响应式的。</p>
<p>可以利用 Vue 的语法糖 $set, 将这个数据强制变成响应式。</p>
<p>或者给这个属性数据，自己手写一个 get  set 方法。</p>
<p><strong>面试题：手写get方法怎么实现呢？</strong></p>
<p>利用 js 原生的 Object.defineProper同样，去对这个属性的变量修改以及变量的获取去做监听，监听到了之后去给他绑定现成的事件就可以了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">凯凯超人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/20/Vue%20%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/">http://example.com/2023/03/20/Vue%20%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">一只柴犬</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/20/CSS%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><img class="prev-cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/CSS.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSS 篇面试题</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/axios%20%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><img class="next-cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/axios.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">axios 的二次封装</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/20/纯 Mock.js 操作_凯凯超人版本/" title="纯 Mock.js Vue中的操作"><img class="cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">纯 Mock.js Vue中的操作</div></div></a></div><div><a href="/2023/03/20/VuePurchase易购平台项目笔记/" title="VuePurchase易购平台项目笔记"><img class="cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">VuePurchase易购平台项目笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/admin.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凯凯超人</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/×××" target="_blank" title="Gitee"><i class="iconfont gitee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Vue 的前端面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E7%90%86%E8%A7%A3Vue"><span class="toc-number">1.1.</span> <span class="toc-text">考点1：理解Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Av-model%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">面试题：v-model的作用和实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Vue%E7%9A%84-MVVM-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">面试题：如何理解 Vue的  MVVM 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-2%E4%B8%AD-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">面试题：Vue 2中 双向绑定（响应式）实现的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-3%E4%B8%AD-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F-%E5%B9%B6%E8%AF%B4%E6%98%8E%E4%B8%BA%E5%95%A5Vue-2-%E7%9A%84%E4%B8%8D%E5%A4%AA%E5%A5%BD"><span class="toc-number">1.1.4.</span> <span class="toc-text">面试题：Vue 3中 双向绑定（响应式）实现的原理？ 并说明为啥Vue 2 的不太好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-data-%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%AF%94%E9%82%A3%E8%8A%B1%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">面试题：Vue data 中某一个属性比那花，视图会立即同步执行重新渲染么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-DOM%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">面试题：什么是虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue%E7%9A%84-%E8%A7%A3%E9%87%8A%E8%99%9A%E6%8B%9F%E5%8C%96DOM-diff-%E7%AE%97%E6%B3%95%EF%BC%9F-%E7%90%86%E8%A7%A3%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84-key-%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">面试题：Vue的 解释虚拟化DOM + diff 算法？ 理解循环中的 key 机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A-new-Vue-%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">1.1.8.</span> <span class="toc-text">面试题：简单聊聊 new Vue 以后发生的事情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.9.</span> <span class="toc-text">面试题：Vue模板编译的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9AVue%E7%9A%84%E5%B1%9E%E6%80%A7%E5%86%85%E5%AE%B9%E8%80%83%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">考点2：Vue的属性内容考点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-%E4%B8%AD-watch-%E5%92%8C-computed-%E4%BD%BF%E7%94%A8%E5%B7%AE%E5%BC%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">面试题：Vue 中 watch 和 computed 使用差异是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Av-if-%E5%92%8C-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">面试题：v-if 和 v-show 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B93%EF%BC%9A-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">考点3： Vue的生命周期函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Avue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%A8mouted%E8%BF%98%E6%98%AFcreate%E9%87%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">面试题：vue生命周期中异步加载在mouted还是create里实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AE%B2%E4%B8%80%E8%AE%B2Vue%E7%9A%84%E7%94%9F%E5%91%BD%E9%92%A9%E5%AD%90%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">面试题：讲一讲Vue的生命钩子有哪几个，每个阶段在干什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-nextTick%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">面试题：如何理解 $nextTick？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%97%A2%E7%84%B6%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E7%9A%84-data-%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">面试题：既然函数是引用类型，为什么 vue 的 data 还是可以用函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B94%EF%BC%9A-Vue-%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.</span> <span class="toc-text">考点4： Vue 的组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%97%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">面试题：父子组件之间时如何通信的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%88%B6%E4%BC%A0%E5%AD%90-ref-refs"><span class="toc-number">1.4.2.</span> <span class="toc-text">面试题：父传子   ref&#x2F;refs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%88%B6%E5%AD%90%E4%B9%8B%E9%97%B4%E4%BA%92%E4%BC%A0-parent-children"><span class="toc-number">1.4.3.</span> <span class="toc-text">面试题：父子之间互传 $parent&#x2F;$children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9A%94%E4%BB%A3-%E7%A5%96%E4%BC%A0%E5%AD%90-%E4%BC%A0%E9%80%92-attrs-%E5%92%8C-listeners"><span class="toc-number">1.4.4.</span> <span class="toc-text">面试题：隔代  祖传子 传递 $attrs 和 $listeners</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue3-0-%E4%B8%AD%E7%A5%96%E4%BC%A0%E5%AD%99-provide-inject%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">面试题：Vue3.0 中祖传孙  provide&#x2F;inject？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-bus-on%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">面试题：任意组件通信 全局事件总线通信  $bus $on？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-VueX%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">考点5：如何理解 VueX？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3VueX%EF%BC%9F%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">面试题：如何理解VueX？其使用场景是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVueX-%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%8C%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VueX"><span class="toc-number">1.5.2.</span> <span class="toc-text">面试题：VueX 有哪几个部分组成，是干什么的？以及如何使用VueX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BA%86%E8%A7%A3-Vuex-%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E4%B9%88%EF%BC%9F%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82"><span class="toc-number">1.5.3.</span> <span class="toc-text">面试题：了解 Vuex 的辅助函数么？讲讲你的理解。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVuex%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">面试题：Vuex实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Amutation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">面试题：mutation和action有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-mutation%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%8C%E8%80%8Caction%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">面试题：为什么 mutation是同步的，而action是异步的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVuex-%E5%92%8C-localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.7.</span> <span class="toc-text">面试题：Vuex 和 localStorage 的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B96%EF%BC%9A-Vue-router-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.6.</span> <span class="toc-text">考点6： Vue-router 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%92%8Clocation-href%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">面试题：路由跳转和location.href的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Vue-router-%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6-keep-alive-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">面试题：如何理解 Vue-router 缓存路由组件   keep-alive 生命周期函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-router-%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-active-%E5%92%8C-deactive-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">面试题：Vue-router 两个新的生命周期钩子  active 和 deactive 的使用理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">面试题：什么是路由守卫？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E5%90%8E%E7%BD%AE-%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">前置&#x2F;后置 全局守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">独享守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%88%E5%8D%AB"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">组件内守卫</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-Vue-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">面试题： Vue 路由模式有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AHashRouter-%E5%92%8C-HistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.6.</span> <span class="toc-text">面试题：HashRouter 和 HistoryRouter的区别和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajs%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACHistoryRouter%E7%9A%84%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">1.6.7.</span> <span class="toc-text">面试题：js是如何监听HistoryRouter的变化的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Avue-router-%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.6.8.</span> <span class="toc-text">面试题：vue-router 实现懒加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B97%EF%BC%9A%E4%BF%AE%E6%94%B9ElementUI-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">考点7：修改ElementUI 样式的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B98%EF%BC%9AVue%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.8.</span> <span class="toc-text">考点8：Vue的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajquery-%E5%92%8C-vue%E7%9B%B8%E6%AF%94"><span class="toc-number">1.8.1.</span> <span class="toc-text">面试题：jquery 和 vue相比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AVue-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8F%AF%E4%BB%A5%E7%B2%BE%E5%87%86%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%85%B7%E4%BD%93dom%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM-diff-%E5%91%A2"><span class="toc-number">1.8.2.</span> <span class="toc-text">面试题：Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Avue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">面试题：vue单页面和传统的多页面区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">面试题： Vue的响应式指的是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Vue-%E7%9A%84MVVM%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">面试题：如何理解 Vue 的MVVM机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%93%AA%E9%87%8C%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">面试题 : 响应式数据在哪里定义？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/23/%E5%89%8D%E7%AB%AF%20JS%20%E9%80%89%E6%8B%A9%E9%A2%98%E7%AC%94%E8%AF%95/" title="前端 JS 选择题笔试"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端 JS 选择题笔试"/></a><div class="content"><a class="title" href="/2023/03/23/%E5%89%8D%E7%AB%AF%20JS%20%E9%80%89%E6%8B%A9%E9%A2%98%E7%AC%94%E8%AF%95/" title="前端 JS 选择题笔试">前端 JS 选择题笔试</a><time datetime="2023-03-23T15:52:02.000Z" title="发表于 2023-03-23 23:52:02">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/" title="代码随想录  （题目 与 类型归纳）"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录  （题目 与 类型归纳）"/></a><div class="content"><a class="title" href="/2023/03/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/" title="代码随想录  （题目 与 类型归纳）">代码随想录  （题目 与 类型归纳）</a><time datetime="2023-03-22T15:52:03.000Z" title="发表于 2023-03-22 23:52:03">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="前端性能优化"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端性能优化"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="前端性能优化">前端性能优化</a><time datetime="2023-03-22T15:51:03.000Z" title="发表于 2023-03-22 23:51:03">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="JavaScript 篇（包含ES6）面试题"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript 篇（包含ES6）面试题"/></a><div class="content"><a class="title" href="/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="JavaScript 篇（包含ES6）面试题">JavaScript 篇（包含ES6）面试题</a><time datetime="2023-03-20T15:58:01.000Z" title="发表于 2023-03-20 23:58:01">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/VuePurchase%E6%98%93%E8%B4%AD%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="VuePurchase易购平台项目笔记"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="VuePurchase易购平台项目笔记"/></a><div class="content"><a class="title" href="/2023/03/20/VuePurchase%E6%98%93%E8%B4%AD%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="VuePurchase易购平台项目笔记">VuePurchase易购平台项目笔记</a><time datetime="2023-03-20T15:55:01.000Z" title="发表于 2023-03-20 23:55:01">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 凯凯超人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideMobileSidebar.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>