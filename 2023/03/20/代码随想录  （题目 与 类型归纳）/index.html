<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>一只柴犬 | 一只柴犬</title><meta name="author" content="凯凯超人"><meta name="copyright" content="凯凯超人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="代码随想录  （题目 与 类型归纳）一些值的记忆的JAVA代码点数组与List数组和 List 的相互转换      Arrays.asList1234&#x2F;&#x2F; 数组转 List    List&lt;String&gt; wordList &#x3D; Arrays.asList(String数组);&#x2F;&#x2F; list 转 int[]int[] res &#x3D; result.stream().mapToInt(Int">
<meta property="og:type" content="article">
<meta property="og:title" content="一只柴犬">
<meta property="og:url" content="http://example.com/2023/03/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/index.html">
<meta property="og:site_name" content="一只柴犬">
<meta property="og:description" content="代码随想录  （题目 与 类型归纳）一些值的记忆的JAVA代码点数组与List数组和 List 的相互转换      Arrays.asList1234&#x2F;&#x2F; 数组转 List    List&lt;String&gt; wordList &#x3D; Arrays.asList(String数组);&#x2F;&#x2F; list 转 int[]int[] res &#x3D; result.stream().mapToInt(Int">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg">
<meta property="article:published_time" content="2023-03-20T10:12:35.946Z">
<meta property="article:modified_time" content="2023-03-16T16:19:14.000Z">
<meta property="article:author" content="凯凯超人">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://example.com/2023/03/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '一只柴犬',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-17 00:19:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="一只柴犬" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/admin.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一只柴犬</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-20T10:12:35.946Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-16T16:19:14.000Z" title="更新于 2023-03-17 00:19:14">2023-03-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="代码随想录-（题目-与-类型归纳）"><a href="#代码随想录-（题目-与-类型归纳）" class="headerlink" title="代码随想录  （题目 与 类型归纳）"></a>代码随想录  （题目 与 类型归纳）</h2><h3 id="一些值的记忆的JAVA代码点"><a href="#一些值的记忆的JAVA代码点" class="headerlink" title="一些值的记忆的JAVA代码点"></a>一些值的记忆的JAVA代码点</h3><h4 id="数组与List"><a href="#数组与List" class="headerlink" title="数组与List"></a>数组与List</h4><h5 id="数组和-List-的相互转换-Arrays-asList"><a href="#数组和-List-的相互转换-Arrays-asList" class="headerlink" title="数组和 List 的相互转换      Arrays.asList"></a>数组和 List 的相互转换      <code>Arrays.asList</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组转 List    </span></span><br><span class="line">List&lt;String&gt; wordList = Arrays.asList(String数组);</span><br><span class="line"><span class="comment">// list 转 int[]</span></span><br><span class="line"><span class="keyword">int</span>[] res = result.stream().mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure>
<h5 id="二维数组-按行初始化-Arrays-fill"><a href="#二维数组-按行初始化-Arrays-fill" class="headerlink" title="二维数组 按行初始化  Arrays.fill"></a>二维数组 按行初始化  <code>Arrays.fill</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chessboard = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line"><span class="comment">// 使用 Arrays方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">	<span class="comment">// 填充棋盘</span></span><br><span class="line">	Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二维数组转list"><a href="#二维数组转list" class="headerlink" title="二维数组转list"></a>二维数组转list</h5><p>将一个二维数组，变成一个一维度的 List</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] c : chessboard) &#123;</span><br><span class="line">	<span class="comment">// String.valueOf() 返回char数组参数的字符串表示形式</span></span><br><span class="line">    <span class="comment">// 那对于不同类型肯定不一样啦</span></span><br><span class="line">	list.add(String.valueOf(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="比较字符串两者字母是否数量一致-Arrays-equals"><a href="#比较字符串两者字母是否数量一致-Arrays-equals" class="headerlink" title="比较字符串两者字母是否数量一致   Arrays.equals"></a>比较字符串两者字母是否数量一致   <code>Arrays.equals</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] str2 = t.toCharArray();</span><br><span class="line">Arrays.sort(str1);</span><br><span class="line">Arrays.sort(str2);</span><br><span class="line"><span class="comment">// 使用 equals 方法看看是不是一直 </span></span><br><span class="line"><span class="keyword">return</span> Arrays.equals(str1, str2);</span><br></pre></td></tr></table></figure>
<h5 id="字符串和-char-互相转换-toCharArray-new-String"><a href="#字符串和-char-互相转换-toCharArray-new-String" class="headerlink" title="字符串和 char[ ] 互相转换  toCharArray()  new String( )"></a>字符串和 char[ ] 互相转换  <code>toCharArray()</code>  <code>new String( )</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] sentence = s.toCharArray();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(sentence);</span><br><span class="line"><span class="comment">// 如果创建一个新的</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 截取</span></span><br><span class="line">String.valueOf(s, <span class="number">0</span>, 取不到的索引位置);</span><br></pre></td></tr></table></figure>
<h5 id="字符串（数字）宇整型-Int-互相转换"><a href="#字符串（数字）宇整型-Int-互相转换" class="headerlink" title="字符串（数字）宇整型 Int 互相转换"></a>字符串（数字）宇整型 Int 互相转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(str);  <span class="comment">//比较耗费时间</span></span><br><span class="line"><span class="comment">// 数字转字符串</span></span><br><span class="line">String str = String.valueof(num);</span><br></pre></td></tr></table></figure>
<h5 id="替换字符的方法-replace"><a href="#替换字符的方法-replace" class="headerlink" title="替换字符的方法 replace"></a>替换字符的方法 <code>replace</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="字符串拼接-List内容-String-join"><a href="#字符串拼接-List内容-String-join" class="headerlink" title="字符串拼接 List内容   String.join"></a>字符串拼接 List内容   <code>String.join</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.join(<span class="string">&quot; &quot;</span>, wordList);</span><br></pre></td></tr></table></figure>
<h4 id="Collection-相关方法（针对-List）"><a href="#Collection-相关方法（针对-List）" class="headerlink" title="Collection 相关方法（针对  List）"></a>Collection 相关方法（针对  List）</h4><h5 id="将List-的内容全部逆序-Collections-reverse"><a href="#将List-的内容全部逆序-Collections-reverse" class="headerlink" title="将List 的内容全部逆序   Collections.reverse"></a>将List 的内容全部逆序   <code>Collections.reverse</code></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse(wordList);</span><br></pre></td></tr></table></figure>
<h4 id="Compare-用法"><a href="#Compare-用法" class="headerlink" title="Compare 用法"></a>Compare 用法</h4><p>其实涉及这块，我还是觉得 用 js 写起来简单一些</p>
<p><strong>用于sort</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] person1, <span class="keyword">int</span>[] person2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (person1[<span class="number">0</span>] != person2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> person2[<span class="number">0</span>] - person1[<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> person1[<span class="number">1</span>] - person2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">有时候甚至不需要这个库</span><br><span class="line">    我们后面其实 这个<span class="keyword">return</span> 返回的应该是一个正数或者负数 注意因为简写所以不需要 <span class="keyword">return</span></span><br><span class="line">    最好别用这种，碰到数据超了 或者值超了 = = 就不行了</span><br><span class="line">    Arrays.sort(points, (p1, p2) -&gt; p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>] ? -<span class="number">1</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="优先队列（顶堆）"><a href="#优先队列（顶堆）" class="headerlink" title="优先队列（顶堆）"></a>优先队列（顶堆）</h4><h5 id="实现小（大）顶堆，并按规则排序-PriorityQueue"><a href="#实现小（大）顶堆，并按规则排序-PriorityQueue" class="headerlink" title="实现小（大）顶堆，并按规则排序    PriorityQueue"></a>实现小（大）顶堆，并按规则排序    <code>PriorityQueue</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 小(大)顶堆内存储的节点为 key ，按照存储key对应的value 大小排序为 小顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HashMap.get(a) - HashMap.get(b);</span><br><span class="line">        <span class="comment">//return HashMap.get(a) - HashMap.get(b);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="优先队列的函数-API"><a href="#优先队列的函数-API" class="headerlink" title="优先队列的函数 API"></a>优先队列的函数 API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其插入会自动进行堆排序的（自行调整堆）</span></span><br><span class="line">minHeap.add(key);</span><br><span class="line"><span class="comment">// 弹出堆顶  返回结果 </span></span><br><span class="line">minHeap.poll();</span><br><span class="line"><span class="comment">// 查看堆顶  返回结果</span></span><br><span class="line">minHeap.peek()；</span><br><span class="line"><span class="comment">// 查看堆是否为空  返回 布尔值</span></span><br><span class="line">minHeap.isEmpty()</span><br></pre></td></tr></table></figure>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="求一个二叉树的最大高度（递归）"><a href="#求一个二叉树的最大高度（递归）" class="headerlink" title="求一个二叉树的最大高度（递归）"></a>求一个二叉树的最大高度（递归）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 还是宏观来看 </span></span><br><span class="line">    <span class="comment">// 根节点为空 肯定没深度</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有根节点的话  </span></span><br><span class="line">    <span class="comment">// 我们就去看左右子树的深度</span></span><br><span class="line">    <span class="comment">// 左右 深度大的那个 肯定是根节点的深度 -1</span></span><br><span class="line">    <span class="comment">// 最后加上 根节点就是答案</span></span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    depth = Math.max(left,right);</span><br><span class="line">    <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="求是不是一颗二叉排序树（递归）"><a href="#求是不是一颗二叉排序树（递归）" class="headerlink" title="求是不是一颗二叉排序树（递归）"></a>求是不是一颗二叉排序树（递归）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left = isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="keyword">boolean</span> right = isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h3><ul>
<li>打钩的表示 肯定会做；</li>
<li><font color="green">绿色</font> 表示我能写出来，但是不一定 不熟，有时候就想不到</li>
<li><font color="blue">蓝色</font> 表示有想法做出来但是过不了或者 不是考的想法，时间复杂度太高</li>
<li><font color="orange">橙色</font>的意思是，大概率还是写不出来，但是我看得懂； </li>
<li><font color="red">红色</font>的意思是，我估计写不出来，只能靠默写，原理不是很明白</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>[x] 二分查找                                                                      方法：二分查找</li>
<li>[ ] <font color="blue">移除元素</font>                                                                      方法：双指针（可用覆盖隐式双指针）</li>
<li>[ ] <font color="blue">序数组的平方</font>                                                              方法：双指针</li>
<li>[ ] <font color="orange">长度最小的子数组</font>                                                      方法：滑动窗口（双指针实现）</li>
<li>[ ] <font color="orange">螺旋矩阵Ⅱ</font>                                                                  方法：模拟  找到合适判断条件转方向</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>[x] 移除链表元素                                                                     方法：头结点</li>
<li>[x] 设计链表                                                                             方法：头结点，index超过 需要先判断null</li>
<li>[ ] <font color="orange">反转链表</font>                                                                             方法：递归</li>
<li>[x] 两两交换链表中的节点                                                      方法：<font color="red">递归</font>   或  头结点+双指针</li>
<li>[x] 删除链表的倒数第 N 个结点                                             方法：头结点+栈</li>
<li>[ ] <font color="green">链表相交</font>                                                                             方法：双指针</li>
<li>[ ] 环形链表 II                                                                          方法：<font color="orange">头结点+快慢指针+数学</font>  或  哈希Set</li>
</ul>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul>
<li>[x] 有效的字母异位词                                                              方法：<font color="green">equals函数</font>  或  哈希表</li>
<li>[ ] <font color="orange">查找常用字符</font>                                                                      方法：哈希表  （但逻辑比较复杂）</li>
<li>[x] 两个数组的交集                                                                  方法：哈希Set</li>
<li>[ ] <font color="orange">快乐数                                                                                  </font>                                                                                方法：数学+哈希Set+ 获取一个数所有位数操作</li>
<li>[x] 两数之和                                                                              方法：哈希表</li>
<li>[ ] <font color="orange">四数相加Ⅱ</font>                                                                          方法：分两段暴力 + 哈希表</li>
<li>[ ] 赎金信                                                                                  方法：哈希表（<font color="green">用数组哈希更快一些</font>）</li>
<li>[ ] <font color="orange">三数之和</font>                                                                              方法：循环内双指针（去重考虑难度大）</li>
<li>[ ] <font color="orange">四数之和</font>                                                                              方法：双循环内双指针（去重考虑难度大）</li>
</ul>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>[x] 反转字符串                                                                           方法：双指针</li>
<li>[ ] <font color="blue">反转字符串Ⅱ</font>                                                                       方法：双指针</li>
<li>[ ] <font color="blue">替换空格</font>                                                                                方法：字符串API <code>replace</code> 或 StringBuilder遍历</li>
<li>[x] 反转字符串里的单词       方法：API trim + 正则表达 + 双指针+ StringBuilder   或者 <font color="red">正则+list+collection+join</font></li>
<li>[x] 左旋转字符串                                                                        方法：StringBuilder</li>
<li>[ ] <font color="red">重复的子字符串</font>                                                                     方法：数学</li>
</ul>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><ul>
<li>[x] 用栈实现队列                                                                         方法：Java 类定义写法  注意：什么时候将第一个队列全部放到第二个中</li>
<li>[x] 用队列实现栈                                                                         方法：使用Deque   里面有 removeFirst removeLast方法 更快</li>
<li>[x] 有效的括号                                                                             方法：使用Deque  正着写就行（就是麻烦点），反着写比较难写</li>
<li>[x] 删除字符串中的所有相邻重复项                                          方法：使用Deque  正着写，利用 Deque双端 简单一些</li>
<li>[ ] 逆波兰表达式                                                                         方法：使用Deque栈，使用<strong>正则表达式</strong>判断是否会数字</li>
<li>[ ] <font color="red">滑动窗口最大值</font>                                                                     方法：使用Deque 编写单调栈，要前后两头都考虑</li>
<li>[ ] <font color="orange">前K个高频元素</font>                                                                       方法：哈希表 + 优先队列（小顶堆）</li>
</ul>
<h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="C:\Users\96356\Desktop\上传图片\20210219190809451.png" alt="20210219190809451" style="zoom:50%;" /></p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><ul>
<li>[x] 二叉树的前序遍历                                                                     方法：递归</li>
<li>[x] 二叉树的后序遍历                                                                     方法：递归</li>
<li>[x] 二叉树的中序遍历                                                                     方法：递归</li>
<li>[x] 二叉树的层次遍历                                                                     方法：Queue队列 </li>
</ul>
<h4 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h4><ul>
<li>[ ] <font color="green">对称二叉树</font>                                                                                 方法：递归</li>
<li>[x] 二叉树的最大深度                                                                     方法：<font color="orange">递归  </font>或  层次</li>
<li>[ ] <font color="red">二叉树的最小深度</font>                                                                     方法：<font color="red">递归  </font></li>
<li>[ ] <font color="blue">完全二叉树的节点个数</font>                                                             方法：<font color="red">递归</font> 或  层次</li>
<li>[ ] <font color="green">平衡二叉树</font>                                                                                方法：递归</li>
<li>[ ] <font color="red">二叉树的所有路径</font>                                                                     方法：递归</li>
<li>[ ] <font color="orange">左叶子之和</font>                                                                                方法：递归   <font color="orange">（如何判断是左叶子！）</font></li>
<li>[ ] <font color="blue">找树左下角的值</font>                                              方法：<font color="orange">递归（如何判断是最后一层最左侧） 或 特殊的 BFS 方法</font></li>
<li>[ ] <font color="green">路经总和</font>                                                                                   方法：递归</li>
</ul>
<h4 id="二叉树的修改和改造"><a href="#二叉树的修改和改造" class="headerlink" title="二叉树的修改和改造"></a>二叉树的修改和改造</h4><ul>
<li>[ ] <font color="green">翻转二叉树</font>                                                                                   方法：递归</li>
<li>[ ] <font color="red">从中序与后序遍历序列构造二叉树</font>                                             方法：<font color="red">哈希表 + 递归</font></li>
<li>[ ] <font color="green">最大二叉树 </font>                                                                                  方法：递归 （用左右控制截取nums）</li>
<li>[ ] <font color="orange">合并二叉树</font>                                                                                   方法：递归（都有的创建新节点来做简单）</li>
</ul>
<h4 id="搜索二叉树的属性"><a href="#搜索二叉树的属性" class="headerlink" title="搜索二叉树的属性"></a>搜索二叉树的属性</h4><p>注意搜索二叉树其实就是  排序二叉树，可以利用到 左边小，右边大的性质，这样更快</p>
<font color="red">**其中序排序是 有序序列**</font>

<ul>
<li><p>[x] 700. 二叉搜索树中的搜索                                                            方法：递归，利用性质更快</p>
</li>
<li><p>[ ] <font color="orange">98.验证二叉搜索树</font>                                                                     方法：递归，用改良中序</p>
</li>
<li>[ ] <font color="orange">530.二叉搜索树的最小绝对差</font>                                                   方法：递归，同上改良 </li>
<li>[ ] <font color="orange">501.二叉搜索树中的众数</font>                                                           方法：<font color="orange">中序递归按情况计数，需要记录前节点</font></li>
<li>[ ] <font color="green">538.把二叉搜索树转换为累加树</font>                                               方法：右根左 递归，<font color="green">记录前节点累加，类似于上题</font></li>
</ul>
<h4 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h4><ul>
<li>[ ] <font color="red">236.二叉树的最近公共祖先</font> <strong>（最近经常出 字节啥的）</strong>          方法：递归 </li>
<li>[ ] <font color="orange">235.二叉搜索树的最近公共祖先</font>                                              方法：<font color="orange">循环判断（利用二叉搜索树的性质）</font> 或者 同上题</li>
</ul>
<h4 id="二叉搜索树的修改和改造"><a href="#二叉搜索树的修改和改造" class="headerlink" title="二叉搜索树的修改和改造"></a>二叉搜索树的修改和改造</h4><ul>
<li>[x] 701.二叉搜索树中的插入操作                                                         方法：循环判断 （利用二叉搜素树的性质）                                                                                                           注意：我考虑的插入的一定是 叶子节点               或者 递归</li>
<li>[ ] <font color="red">450.删除二叉搜索树中的节点 </font>                                                         方法：循环判断  或者 递归   <font color="red"><strong>都比较难没咋看懂</strong></font> </li>
<li>[ ] <font color="red">669.修剪二叉搜索树</font>                                                                        方法：递归  <font color="red"><strong>难想</strong></font> </li>
<li>[ ] <font color="orange">108.将有序数组转换为二叉搜索树</font>                                                 方法：递归  <font color="orange">要注意右侧落点（否则- -会<strong>死循环</strong>）</font></li>
</ul>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/20210219192050666.png" alt=""></p>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><ul>
<li><p>[ ] <font color="orange">77.组合</font>                                                                               方法：回溯  剪枝优化 <code>large - (k - path.size()) + 1</code></p>
</li>
<li><p>[ ] <font color="orange">17.电话号码的字母组合</font>                                                    方法：哈希（转换为数组更快）+ 回溯。 树的高度应该是 电话号码的个数</p>
</li>
<li><p>[ ] <font color="blue">39.组合总和</font>                                                                       方法：利用begin的回溯法，<font color="orange">需关于值的 剪枝 break 降低复杂度</font></p>
</li>
<li><p>[ ] 40.组合总和Ⅱ                                                                   方法：利用begin的回溯法，<strong>需要额外的重复剪枝 continue</strong>，不然答案会重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(begin &lt; i &amp;&amp; candidate[i-<span class="number">1</span>] == candidate[i] )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[ ] <font color="green">216.组合总和Ⅲ</font>                                                                 方法：类似于 组合总数，只是要在 return 的时候注意 只有长度为k的才可以</p>
</li>
</ul>
<h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul>
<li>[ ] <font color="orange">131.分割回文串</font>                                                                               方法：回溯  begin ，需要截取字符串 (begin, i+1)</li>
<li>[ ] <font color="orange">93.复原IP地址</font>     <strong>2021.3.24虾皮笔试</strong>                                           方法：回溯 begin 和上题很像 但是要注意细节处理 使用path记录，最后拼接答案（我用的 get() 和 sub  Integer.parseInt 是比较慢 = =的 ）</li>
</ul>
<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><ul>
<li>[ ] <font color="orange">78.子集</font>                                                                               方法：回溯  begin  递归出口直接写就好</li>
<li>[ ] <font color="orange">90.子集Ⅱ</font>                                                                               方法：回溯  begin  同上 只是要剪枝。 要先sort一下，不然剪枝无效的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(begin &lt; i &amp;&amp; candidate[i-<span class="number">1</span>] == candidate[i] )</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><ul>
<li><p>[ ] <font color="orange">46.全排列</font>                                                                               方法：回溯  begin=0  + visited数组</p>
</li>
<li><p>[ ] <font color="orange">47.全排列Ⅱ</font>                                                                           方法：回溯  begin=0  + visited数组 + 剪枝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; numbers[i-<span class="number">1</span>] == numbers[i]  &amp;&amp; visited[i-<span class="number">1</span>] == <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h4><ul>
<li><p>[ ] <font color="red">51.N皇后</font>                                                                               方法：回溯  begin 变成 row 行， 每次找到当前行哪一列位置好使进行递归。 答案用的是一个  二位数组记录并判断是否合适</p>
</li>
<li><p>[ ] <font color="red">37.解数独</font>                                                                              方法：回溯中有 3层for  ，backtrack有返回值 boolean 因为只要获取一个</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/VCirGskFGPln-S2LGFTgKg</span><br></pre></td></tr></table></figure>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul>
<li><p>[ ] <font color="red">491.递增子序列（和子集问题很像）</font>                                                                               方法：回溯  begin  哈希去重（如果用 path判断的 话 有个样例有bug， 不能盲目i的用之前的去重办法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path.size() != <span class="number">0</span> &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; numbers[i] ) </span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[ ] <font color="red">332.重新安排行程</font>                                                                              方法：begin = 0， 类似于全排列的做法。 backtrack有返回值 boolean 因为只要获取一个。 在判断的时候，需要判断</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 刚开始就字典序排序</span><br><span class="line">Collections.sort(tickets,(a,b) -&gt; a.get(1).compareTo(b.get(1))); // 字典序排序</span><br><span class="line">//</span><br></pre></td></tr></table></figure>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/20210917104315.png" alt=""></p>
<p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<h4 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h4><ul>
<li>[x] 455.分发饼干                                                                             方法：贪心 双循环</li>
<li>[ ] <font color="orange">1005.K次取反后最大化的数组和</font>                                             方法：贪心思路比较难想</li>
<li>[ ] <font color="orange">860.柠檬水找零</font>                                                                方法：模拟，但是有两种情况，用方法去考虑规避</li>
</ul>
<h4 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h4><h5 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h5><ul>
<li>[ ] 376. <font color="red">摆动序列</font>                                                                    方法：非常优化的动态规划 其他方法太复杂</li>
<li>[ ] <font color="orange">738.单调递增的数字</font>                                                        方法：从右往左改数字</li>
</ul>
<h5 id="贪心解决股票问题"><a href="#贪心解决股票问题" class="headerlink" title="贪心解决股票问题"></a>贪心解决股票问题</h5><ul>
<li>[ ] <font color="orange">122.买卖股票的最佳时期Ⅱ</font>                                                  方法：动态规划 或 贪心</li>
<li>[ ] <font color="orange">714.买卖股票的最佳时期含手续费 </font>                                      方法：动态规划和上题基本一模一样，这里的贪心策略比较难想</li>
</ul>
<h5 id="两个维度权衡问题"><a href="#两个维度权衡问题" class="headerlink" title="两个维度权衡问题"></a>两个维度权衡问题</h5><ul>
<li>[ ] <font color="orange">135.分发糖果</font>                                                                 方法：贪心算法，从左和从右考虑两次</li>
<li>[ ] <font color="orange">406.根据身高重建队列</font>                                                  方法：贪心算法，分两步</li>
</ul>
<h4 id="有点难度"><a href="#有点难度" class="headerlink" title="有点难度"></a>有点难度</h4><h5 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h5><ul>
<li>[ ] <font color="red">55.跳跃游戏</font>                                                                 方法：贪心算法 和 动态规划 我觉得对我来说都不好想 = =</li>
<li>[ ] <font color="red">45.跳跃游戏Ⅱ</font>                                                             方法：贪心算法，从左和从右考虑两次</li>
</ul>
<p>重叠区域</p>
<ul>
<li>[ ] <font color="orange">452.用最少数量的箭引爆气球</font>                                    方法：贪心算法 这道题用 java sort 的时候需要注意  普通 a[1] -b[1]是不行的  得用三目表达式 return 正负回去</li>
<li>[ ] <font color="orange">435.无重叠区间</font>                                                           方法：贪心算法 和上题一样只是  需要添加判断等于的时候  最后用减法即可， length - 穿过的箭就是答案</li>
<li>[ ] <font color="red">763.划分字母区间</font>   <strong>2022美团测试开发题</strong>                 方法：其规则比较难想，转换为上面两题的做法答案思路是不一样的，所以这里他其实巧妙的保存了最后一个元素的索引，然后特殊遍历去做</li>
<li>[ ] <font color="blue">56.合并区间</font>                                                                 方法：JS使用来回两次 用splice方法增加删除 就是速度慢，java想实现同样的想来太慢了。这个想法是按右侧先排，然后再左右合并。   <strong>代码最简单的想法是，先按左侧排序，然后在将合适的填入（更快）</strong>。</li>
</ul>
<ul>
<li>[ ] <font color="blue">53.最大子序和</font>                                                             方法：用动态规划 最简单</li>
<li>[ ] <font color="orange">134.加油站</font>                                                                  方法： 在用模拟方法的时候，需要 i+count+1 才可以  他的意思是说  例如 x到 k 就不行，那 x到k中，所有的点到Z肯定也是不行的。</li>
<li>[ ] <font color="orange">968.监控二叉树</font>   困难题 <strong>天堂硅谷竞赛题</strong>                方法：后续遍历 ，子节点告诉父节点干嘛 摄像头尽可能的装在父节点上，0，1，2表示3种状态，被监视到，放摄像头，没监视到</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/动态规划上半部分.png" alt=""></p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/动态规划下部分.png" alt=""></p>
<ul>
<li>[x] 509.斐波那契函数                                                方法：基础 一维 动态规划</li>
<li>[x] 70.爬楼梯                                                              方法：和上面一题  动态转移方程一模一样</li>
<li>[x] 746.使用最小花费爬楼梯                                     方法：上一题的 在加上 cost[i]，也很简单</li>
<li>[x] 62.不同路径                                                           方法：简单的二维动态</li>
<li>[x] 63.不同路径 II                                                      方法：上题 加个判断 </li>
<li>[ ] <font color="orange">343.整数拆分</font>                                                       方法：动态规划（比较难想，属于背包问题），用数学方法最佳，根据数学推断 分成3一堆一堆，最大</li>
<li>[ ] <font color="red">96.不同的二叉搜索树</font>                                          方法：动态规划很难想 记不住  建议背下来</li>
</ul>
<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/背包问题的分类.png" alt=""></p>
<h5 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h5><p>也就是每个东西只能拿一次</p>
<font color="red">**滚动数组的内循环，从后往前**</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="comment">// 内循环 从后往前</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = amount; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>[x] <font color="red">416.分割等和子集</font>                                             方法：就是最基本的 0-1背包问题 只是 weight[i] 变成 nums[i] ，二维一维都可写。  这道题的暴力做法，为回溯。  </p>
</li>
<li><p>[x] <font color="red">1049.最后一块石头的重量 II</font>                            方法：转换思想后 完全就是 0-1背包  只是最后 return 你要想清楚返回的是啥</p>
</li>
<li><p>[x] <font color="red">494.目标和</font>                                                        方法：转换思想后 是个 0-1背包的 <strong>组合问题</strong>，其动态转移方程 有变化 为  <code>dp[j] += dp[j - nums[i]];</code>  并且初始化 dp[0] 要考虑清楚。</p>
<p>二维写不出来，= =            回溯看了别人的可以过哎，就是很慢。</p>
</li>
<li><p>[x] <font color="red">474.一零和</font>                                                       方法：0-1背包问题，这里的滚动数组 内层变成了二维双循环，所以 滚动数组为二维    滚动数组定义为 <strong>最多有i个0和j个1的strs的最大子集的大小</strong> 其状态转移方程为</p>
<p><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code>  zeroNum 与 oneNum 表示为当前</p>
</li>
</ul>
<h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><font color="red">**其实就是 滚动数组的内循环，不再从后往前，为从前往后**</font>  **这个适用于组合问题**

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="comment">// 内循环 从前往后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = nums[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

遍历顺序问题：

**组合问题** （求组合个数）

对于组合问题或者背包问题    **都采用 先遍历物品，再遍历背包**

对于组合问题（问排序数）  **都采用 先遍历背包，再遍历物品**

**dp的定义为  dp[i] 为当前 i 下 有几个的组合数**

采用的 动态转移方程为

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]];</span><br></pre></td></tr></table></figure>

  初始化要注意：  `dp[0] = 1`



**求组合问题中的 最佳**

**dp的定义为  dp[i] 为当前 i 下 可以的数字组合中，长度的最小值**

采用的 动态转移方程为

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">Math</span>.min(dp[j], dp[j- coins[i]] + <span class="number">1</span>) </span><br></pre></td></tr></table></figure>

  初始化要注意 一般：  `dp[0] = 0`， 其他都为 `Infinity`  无穷大



对于排序问题，其遍历顺序是有区别的

我应该先遍历容积，再遍历背包

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(j &gt;= nums[i])&#123;</span><br><span class="line">    		dp[j] += dp[j - nums[i]]</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



- [x] <font color="orange">518.零钱兑换 Ⅱ</font>                                             方法：完全背包的**组合问题 ** 其动态转移方程 有变化 为  `dp[j] += dp[j - nums[i]];`  并且初始化 dp[0] 要考虑清楚。应该初始为 1

- [x] <font color="orange">377.组合总数Ⅳ</font>                                              方法：**组合数** 就是目标和 那道题的 完全背包 （数字可以重复用） `dp[j] += dp[j - nums[i]];`  并且初始化 dp[0] 要考虑清楚。应该初始为 1

  **不过这道题求的是排序数  不是 组合数  所以 内外循环 遍历顺序需要变换**。  **昨天刚做个这个 所以我第一次做出来了**

- [x] <font color="blue">70.爬楼梯（完全背包解法)</font>                         方法：同样这道题 也可以理解为 **排序数** 和上题做法一模一样。 就是 nums[] 物品数组 变成步数而已 {1,2}

- [x] <font color="red">322.零钱兑换</font>                                       方法：**求组合问题中的 最佳**

- [x] <font color="blue">279.完全平方数</font>                                   方法：**求组合问题中的 最佳**， 和上题一样，就是这题需要自己先构建处 一个 物品[ ] 出来

  这题用 java 比较麻烦，因为构造这个 物品[ ]  只能用list 还要转 = -= 自讨苦吃，所以我不写。

- [x] <font color="red">139.单词拆分</font>                                      方法：属于**排序问题**   但是这个递推公式比较难想

> 如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
>
> 所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。



#### 打家劫舍

这个类型的题其实不算 0-1背包问题， **因为 背包问题没有限制取包的规则**

- [ ] <font color="orange">198.打家劫舍（线性）</font>                                              方法： `dp[i] = Math.max(dp[i-2] + nums[i] ,dp[i-1])` 没写出来，太蠢了，白写题目了，以前这个题做的出来的啊

- [ ] <font color="blue">213.打家劫舍Ⅱ  （环状）</font>                                        方法：由于是环状，其实最后的落点一定在 倒数第一家或者倒数第二家。所以我们可以把数组拆成  0- n-2  和 1- n-1 来取其中最大值，每一段的取值和上一题线性一致。

- [ ] <font color="red">337.打家劫舍Ⅲ  （树形dp）</font>                                        方法：**必须后续遍历递归做**，**因为通过递归函数的返回值来做下一步计算**。dp为2维度 为 【不偷，偷】的分别最大值。

  递归逻辑为 如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（**注意这里说的是“考虑”**）递归出口为 碰到 null 返回 [0,0]



#### 股票问题

- [ ] <font color="red">121.买卖股票的最佳时机 （只能买卖一次）</font>                方法：这题一定要是1维度的，因为他只买卖一次，不能用下面的二维来做。

- [ ] <font color="red">122.买卖股票的最佳时机Ⅱ （可以买卖多次）</font>            方法： 定义dp 的理解上， `dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票`。 所以首先要合理初始化， 然后遍历讨论 `dp[i][0]` 和 `dp[i][1]` 的可能性，分别各自有两种。

- [ ] <font color="red">123.买卖股票的最佳时机Ⅲ （最多买卖两次）</font> 方法：

  <font color="red">**这道题的 dp定义为  `dp[i][j]`  描绘的是当天整体处于的状态，不是当天的操作**</font>

<pre><code> `dp[i][0]` 第 i 天没有操作， 那前面也不可能操作
</code></pre><p>  ​                    <code>dp[i][0] = dp[i - 1][0];</code></p>
<pre><code> `dp[i][1]` 第 i 天第一次买入，这个意思是 

 之前是的状态是第一次买入，但今天可以不卖 
</code></pre><p>  ​    或者是 前面一直是静默状态，今天买入了</p>
<p>  ​                    <code>dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></p>
<pre><code> `dp[i][2]` 第 i 天第一次卖出，这个意思是 之前的状态已经是卖出第一次了，我今天静默；或者是今天确实是第一次卖出
</code></pre><p>  ​                    <code>dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</code></p>
<pre><code> `dp[i][3]` 第 i 天第二次买入 ，这个意思就是 之前已经卖出过第一次了，此刻已经是买入的状态。有可能为之前已经买入第二次，今天是静默 或者  是今天买的第二次，之前一直是第一次卖出的状态
</code></pre><p>  ​                    <code>dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]</code>        </p>
<pre><code> `dp[i][4]` 第 i 天第二次卖出，这个意思是  此时整体是第二次卖出的状态，有两种可能：第一之前已经卖出了第二次了，我今天是静默；第二我就是今天卖的
</code></pre><p>  ​                <code>dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</code></p>
  <font color="blue">**初始化中** </font> `dp[i][1]  = -prices[0]`

  第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入）

  ​    `dp[i][3]  = -prices[0]`

  <font color="blue">**最后的 return 可定是** `dp[prices.length - 1][4]`</font>，因为我要满足两次都卖出的时候状态并且是最后一天的时候。

- [ ] <font color="red">188.买卖股票的最佳时机Ⅳ （最多买卖k次）</font>  方法：这题就是上一题 2 => k **变成循环就完了**

- [ ] **309.买卖股票多次  但是买入之后需要一天的冷冻期    方法：**

- [ ] <font color="blue">714.买卖多次 但是每次有手续费</font>                    方法：这题就是 122.买卖股票的最佳时机Ⅱ （可以买卖多次） 卖了多个费用而已



#### 子序列问题

##### 子序列（不连续）问题

**全部是正常遍历顺序** 

- [ ] <font color="red">300.最长递增子序列</font>                                方法：`dp[i] = max(dp[i], dp[j] + 1);`  初始化全为1  两层for 循环

- [x] <font color="red">1143.最长公共子序列</font>                               方法：`dp[i][j]` 的含义是 `text1[0:i-1]` 和 `text2[0:j-1]` 的最长公共子序列。

  如果`text1[i - 1] 与 text2[j - 1]`不相同，那就看看`text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。`

  ![](http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ截图20220915200451.png)

- [ ] <font color="blue">1035.不相交的线</font>                                      方法：**和上面一题一模一样，代码都是一样的**，就是换个场景。 语法糖啊。



##### 子序列（连续）问题

**全部是正常遍历顺序** 

- [ ] <font color="blue">674.最长连续递增子序列</font>          方法：这道题 和 <font color="red">300.最长递增子序列</font> 想法是一样的，只是 j 的变化范围的区别，在这里必须是连续的 所以 j 的取值只有 i 的前一个，但是 不连续的情况下， j 的取值是 [0, i-1]。  所以只需要在 300的基础上，需改 j 的初始值wei  i - 1 即可。

- [ ] <font color="red">718.最长公共子数组</font>                  方法：这道题<font color="red">1143.最长公共子序列</font>  一模一样，就是这里是连续，连续和不连续的区别在于，动态转移方程不同

  对于  非连续 

  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>])</span><br><span class="line">    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

  对于 连续  只有   并且最大的并不是 dp最后，所以需要一个 result 去维护

  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(text1[i-<span class="number">1</span>] == text2[j-<span class="number">1</span>])</span><br><span class="line">    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>



- [ ] 53.最大子数和                     方法：正常的一维动态规划



##### 编辑距离

**全部是正常遍历顺序** 

- [ ] <font color="orange">392.判断子序列</font>                    方法：用最大公共子序列，然后判断最后结果必须和 s序列长度一样。这个方法是可行的.

  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这位 t 对比上了 所以去掉这位 继续</span></span><br><span class="line">dp[i][j] = dp[i][j-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

- [ ] <font color="red">115.不同的子序列</font>             方法：这道题其实就是编辑距离，只是仅仅考虑删除，不包括修改和增加。**并且只考虑左侧字符串。** 并且这道题是考虑 匹配的数量，所以动态规划表达式有所区别。

- [ ] <font color="blue">583.两个字符串的删除操作</font>    方法：这道题是上一题的变成了 2个字符串都删除，求删到一样的最小步数。其实最佳的结束点就是最大公共子序列，步数就是 长度- 最大公共子序列啊。。

- [ ] <font color="red">72.编辑距离</font>                     方法：这道题是最经典的编辑距离的问题，也就是上面 <font color="red">115.不同的子序列</font>的完全版，需要同时考虑 删除、修改和增加，这道题dp考虑的是操作数。

  `dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。`

​        其中删除和增加的 动态规划表达式是一样的

​        `if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

​        **操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的                   word2的最近编辑距离 再加上一个操作。**

​        即 `dp[i][j] = dp[i - 1][j] + 1;`

​        **操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的                   word2的最近编辑距离 再加上一个操作。**

​         即 `dp[i][j] = dp[i][j - 1] + 1;`

​        对于修改

​        就是该 word1[i-1] 为 word2[j-1] ，也就是 `dp[i][j] = dp[i-1][j-1] + 1` 

​        // 初始化

​        `dp[i][0] 和 dp[0][j]`   肯定是分别删除它的全部啦

​        

#### 回文

**这里的题 dp 全部不用 + 1**

**遍历顺序全部为 i 从下到上  j 从左（i/i+1 开始自己分析情况）到右**

- [ ] <font color="red">647.回文子串</font>                               方法：动态规划法 （需要注意遍历顺序）， 另外还有中心扩散法，这个方法比较巧妙并且空间复杂度低

- [ ] 5.最长回文子串

- [ ] 516.最长回文子序列          方法：动态规划法

  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === s[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  **另一种新奇的思路试， 将s.reverse()， s 和 s.reverse() 的最大公共子序列就是最长回文子序列**





### 单调栈

什么时候用单调栈呢？

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

**注意点：**

<font color="blue">单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</font>

<p><strong>单调递增递减怎么看？</strong></p>
<font color="red">**指的是栈头到栈底应该保持一种单调的状态**</font>

<ul>
<li>如果求一个元素右边第一个更大元素，单调栈就是递增的</li>
<li>如果求一个元素右边第一个更小元素，单调栈就是递减的。</li>
</ul>
<p><strong>使用单调栈在 遍历一次数组中  一般来说有3种情况</strong></p>
<ul>
<li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ul>
<p>难点主要在对三种情况应该具体怎么分析入栈和出栈的</p>
<ul>
<li><p>[ ] 739.每日温度                                      方法：求右侧第一个最大的，单调栈从栈顶到栈底，单调递增。</p>
</li>
<li><p>[ ] 496.下一个最大的元素Ⅰ（不循环）                   方法： 这道题利用 <code>indexOf</code> 再双循环非常的简单。 使用单调栈的话，其实他非常依赖于 <code>nums2</code> 的长度，因为他把每一个 后面第一个值大于之前某一值的 键值对存入，然后在用数组一的 值作为key去找，其实速度并不快，但是思路也清晰的。（我自己写可能还是不行）</p>
</li>
<li><p>[ ] 503.下一个最大的元素Ⅱ（循环）   方法：和上一题一样，就是 nums 需要扩张一倍，然后  index 需要mode一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextGreaterElements = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numsTemp = [...nums,...nums]</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(-<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numsTemp.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(stack.length &amp;&amp; numsTemp[stack[stack.length - <span class="number">1</span>]] &lt; numsTemp[i])&#123;</span><br><span class="line">            <span class="keyword">let</span> index = stack.pop() % nums.length</span><br><span class="line">            result[index] = numsTemp[i]</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[ ] <font color="red">47.接雨水</font>                       方法：暴力双指针，带数组双指针（推荐），单调栈（一样是 从小到大的顺序）</p>
</li>
</ul>
<h1 id="额外需要注意的题目"><a href="#额外需要注意的题目" class="headerlink" title="额外需要注意的题目"></a>额外需要注意的题目</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">凯凯超人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/">http://example.com/2023/03/20/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">一只柴犬</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/20/%E5%89%8D%E7%AB%AF%20JS%20%E9%80%89%E6%8B%A9%E9%A2%98%E7%AC%94%E8%AF%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/%E7%BA%AF%20Mock.js%20%E6%93%8D%E4%BD%9C_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/admin.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凯凯超人</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/×××" target="_blank" title="Gitee"><i class="iconfont gitee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%EF%BC%88%E9%A2%98%E7%9B%AE-%E4%B8%8E-%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">代码随想录  （题目 与 类型归纳）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%80%BC%E7%9A%84%E8%AE%B0%E5%BF%86%E7%9A%84JAVA%E4%BB%A3%E7%A0%81%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">一些值的记忆的JAVA代码点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8EList"><span class="toc-number">1.1.1.</span> <span class="toc-text">数组与List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C-List-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2-Arrays-asList"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">数组和 List 的相互转换      Arrays.asList</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%8C%89%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-Arrays-fill"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">二维数组 按行初始化  Arrays.fill</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AClist"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">二维数组转list</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E8%80%85%E5%AD%97%E6%AF%8D%E6%98%AF%E5%90%A6%E6%95%B0%E9%87%8F%E4%B8%80%E8%87%B4-Arrays-equals"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">比较字符串两者字母是否数量一致   Arrays.equals</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C-char-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2-toCharArray-new-String"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">字符串和 char[ ] 互相转换  toCharArray()  new String( )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E6%95%B0%E5%AD%97%EF%BC%89%E5%AE%87%E6%95%B4%E5%9E%8B-Int-%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">字符串（数字）宇整型 Int 互相转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E7%9A%84%E6%96%B9%E6%B3%95-replace"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">替换字符的方法 replace</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-List%E5%86%85%E5%AE%B9-String-join"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">字符串拼接 List内容   String.join</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%EF%BC%88%E9%92%88%E5%AF%B9-List%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">Collection 相关方法（针对  List）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86List-%E7%9A%84%E5%86%85%E5%AE%B9%E5%85%A8%E9%83%A8%E9%80%86%E5%BA%8F-Collections-reverse"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">将List 的内容全部逆序   Collections.reverse</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compare-%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">Compare 用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E9%A1%B6%E5%A0%86%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">优先队列（顶堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%B0%8F%EF%BC%88%E5%A4%A7%EF%BC%89%E9%A1%B6%E5%A0%86%EF%BC%8C%E5%B9%B6%E6%8C%89%E8%A7%84%E5%88%99%E6%8E%92%E5%BA%8F-PriorityQueue"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">实现小（大）顶堆，并按规则排序    PriorityQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E5%87%BD%E6%95%B0-API"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">优先队列的函数 API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">求一个二叉树的最大高度（递归）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">求是不是一颗二叉排序树（递归）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">题目分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.5.</span> <span class="toc-text">哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="toc-number">1.6.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">栈与队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">1.8.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">二叉树的遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.2.</span> <span class="toc-text">二叉树的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E9%80%A0"><span class="toc-number">1.8.3.</span> <span class="toc-text">二叉树的修改和改造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.4.</span> <span class="toc-text">搜索二叉树的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.5.</span> <span class="toc-text">二叉树公共祖先问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E6%94%B9%E9%80%A0"><span class="toc-number">1.8.6.</span> <span class="toc-text">二叉搜索树的修改和改造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.1.</span> <span class="toc-text">组合问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2"><span class="toc-number">1.9.2.</span> <span class="toc-text">分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">1.9.3.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97"><span class="toc-number">1.9.4.</span> <span class="toc-text">排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.5.</span> <span class="toc-text">棋盘问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.6.</span> <span class="toc-text">其他问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%A2%98%E7%9B%AE"><span class="toc-number">1.10.1.</span> <span class="toc-text">简单题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%AD%89%E9%A2%98%E7%9B%AE"><span class="toc-number">1.10.2.</span> <span class="toc-text">中等题目</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">排序问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E5%86%B3%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">贪心解决股票问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BB%B4%E5%BA%A6%E6%9D%83%E8%A1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">两个维度权衡问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6"><span class="toc-number">1.10.3.</span> <span class="toc-text">有点难度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">区间问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.11.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.1.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">完全背包问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number"></span> <span class="toc-text">额外需要注意的题目</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/axios%20%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题"><img src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/20/axios%20%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题">无题</a><time datetime="2023-03-20T10:12:35.973Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题"><img src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题">无题</a><time datetime="2023-03-20T10:12:35.969Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题"><img src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题">无题</a><time datetime="2023-03-20T10:12:35.965Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题"><img src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="无题">无题</a><time datetime="2023-03-20T10:12:35.961Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%8D%E7%AB%AF%EF%BC%88JS%EF%BC%89%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E9%A2%98/" title="无题"><img src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/media/image/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%8D%E7%AB%AF%EF%BC%88JS%EF%BC%89%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E9%A2%98/" title="无题">无题</a><time datetime="2023-03-20T10:12:35.954Z" title="发表于 2023-03-20 18:12:35">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 凯凯超人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideMobileSidebar.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>