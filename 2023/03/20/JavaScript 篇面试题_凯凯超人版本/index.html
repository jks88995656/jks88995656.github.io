<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript 篇（包含ES6）面试题 | 一只柴犬</title><meta name="keywords" content="JavaScript"><meta name="author" content="凯凯超人"><meta name="copyright" content="凯凯超人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@TOC JavaScript 篇（包含ES6）面试题考点 1：数据类型面试题：讲讲JS的数据类型？最新的 ECMAScript 标准定义了 8种数据类型: 7种 基础数据类型  Boolean ​    永远只有true和false两个值。  Undefined： ​    一个没有被赋值的变量会有个默认值 undefined，是全局对象的一个属性  Number ​    基于 IEEE 75">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 篇（包含ES6）面试题">
<meta property="og:url" content="http://example.com/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/index.html">
<meta property="og:site_name" content="一只柴犬">
<meta property="og:description" content="@TOC JavaScript 篇（包含ES6）面试题考点 1：数据类型面试题：讲讲JS的数据类型？最新的 ECMAScript 标准定义了 8种数据类型: 7种 基础数据类型  Boolean ​    永远只有true和false两个值。  Undefined： ​    一个没有被赋值的变量会有个默认值 undefined，是全局对象的一个属性  Number ​    基于 IEEE 75">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png">
<meta property="article:published_time" content="2023-03-20T15:58:01.000Z">
<meta property="article:modified_time" content="2023-03-20T10:54:06.000Z">
<meta property="article:author" content="凯凯超人">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png"><link rel="shortcut icon" href="/img/favicon2.png"><link rel="canonical" href="http://example.com/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript 篇（包含ES6）面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-20 18:54:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="一只柴犬" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/admin.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一只柴犬</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1"><i class="fa-fw /movies/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E7%85%A7%E7%89%87"><i class="fa-fw /Gallery/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript 篇（包含ES6）面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-20T15:58:01.000Z" title="发表于 2023-03-20 23:58:01">2023-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-20T10:54:06.000Z" title="更新于 2023-03-20 18:54:06">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript 篇（包含ES6）面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>@<a href="JavaScript">TOC</a></p>
<h1 id="JavaScript-篇（包含ES6）面试题"><a href="#JavaScript-篇（包含ES6）面试题" class="headerlink" title="JavaScript 篇（包含ES6）面试题"></a>JavaScript 篇（包含ES6）面试题</h1><h2 id="考点-1：数据类型"><a href="#考点-1：数据类型" class="headerlink" title="考点 1：数据类型"></a>考点 1：数据类型</h2><h3 id="面试题：讲讲JS的数据类型？"><a href="#面试题：讲讲JS的数据类型？" class="headerlink" title="面试题：讲讲JS的数据类型？"></a>面试题：讲讲JS的数据类型？</h3><p>最新的 ECMAScript 标准定义了 8种数据类型:</p>
<p><strong>7种 基础数据类型</strong></p>
<ul>
<li><p>Boolean</p>
<p>​    永远只有<code>true</code>和<code>false</code>两个值。</p>
</li>
<li><p>Undefined：</p>
<p>​    一个没有被赋值的变量会有个默认值 undefined，<strong>是全局对象的一个属性</strong></p>
</li>
<li><p>Number</p>
<p>​    基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(2^53 -1) 到 2^53 -1）</p>
<p>​    除了能够表示浮点数外，<font color="red"><strong>还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-    Number)。</strong></font></p>
</li>
<li><p>String</p>
<p>​    字符串一旦被创建，就不能被修改。</p>
</li>
<li><p>null   <font color="red">这是一个很奇怪的类型，下面的所有面试题都要注意他</font></p>
<p>​    可以理解为  null 作为尚未创建的对象，<strong>不是全局对象的一个属性</strong></p>
</li>
<li><p>BigInt（ES6 新增）</p>
<p>​    可以安全地存储和操作大整数. 常常通过在整数末尾附加 n 或调用构造函数来创建的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">BigInt</span>(<span class="string">&#x27;43243242424242424242342432&#x27;</span>)</span><br><span class="line"><span class="comment">// 43243242424242424242342432n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">43243242424242424242342432n</span></span><br><span class="line"><span class="comment">// 43243242424242424242342432n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol（ES6 新增）</p>
<p>​    可以通过调用内置函数 Symbol() 创建，这个函数会动态的生成一个匿名、全局唯一的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>();</span><br><span class="line">a == b <span class="comment">// false</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。</p>
<p><strong>Symbol最大的用处就是：<code>避免对象的键被覆盖。</code></strong></p>
</li>
</ul>
<p>注意：基本类型全是<font color="blue">原始值</font>，也就是不可变。例如 js 对字符串的操作返回了一个新字符串，但是原始字符串并没有被改变），我们称这些类型的值为“原始值”。</p>
<p><strong>复杂数据类型</strong></p>
<ul>
<li>Object</li>
<li>Function  (本质也算Object)</li>
<li>Array （本质也算Object）</li>
</ul>
<h3 id="面试题：基本数据类型-和-引用数据类型的区别"><a href="#面试题：基本数据类型-和-引用数据类型的区别" class="headerlink" title="面试题：基本数据类型 和 引用数据类型的区别"></a>面试题：基本数据类型 和 引用数据类型的区别</h3><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul>
<li>按值访问，可操作保存在变量中实际的值</li>
<li>值被保存在 <code>栈内存</code> 中，占据固定大小的空间</li>
</ul>
<h5 id="引用数据类型-复杂数据类型"><a href="#引用数据类型-复杂数据类型" class="headerlink" title="引用数据类型(复杂数据类型)"></a>引用数据类型(复杂数据类型)</h5><ul>
<li>引用类型的值是按引用访问的，<font color="red"><strong>访问的为存储地址</strong>，<strong>存储地址为存在 栈 中</strong></font></li>
<li>保存在<font color="red"><strong>堆内存中的对象</strong></font>，不能直接访问操作对象的内存空间</li>
</ul>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/微信图片_20221024195715.jpg" alt=""></p>
<h3 id="面试题：四种判断数据类型的方法"><a href="#面试题：四种判断数据类型的方法" class="headerlink" title="面试题：四种判断数据类型的方法"></a>面试题：四种判断数据类型的方法</h3><p>可参考链接 ： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6919805736734162952#heading-3">https://juejin.cn/post/6919805736734162952#heading-3</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>typeof 适合基本类型和function类型的检测，无法判断null与object</li>
<li>instanceof 适合自定义对象，也可以用来检测原生对象，在不同的iframe 和 window间检测时失效，还需要注意Object.create(null)对象的问题</li>
<li>constructor 基本能判断所有类型，除了null和undefined，但是constructor容易被修改，也不能跨iframe使用</li>
<li>tostring  （<code>Object.prototype.toString.call</code>）能判断所有类型，可将其封装为全能的DataType()判断所有数据类型</li>
</ul>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p><strong>总结</strong></p>
<ul>
<li><code>适用于判断（除null）基础类型,</code></li>
<li><code>判断引用类型，除了function 全返回object类型</code></li>
</ul>
<p><strong>对于基本数据类型来说，除了null返回的是object，其他都可返回正确的类型。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;5&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">5</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">5n</span> <span class="comment">// bigint</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>原因是因为：<font color="blue">null其实可以理解为一个还未创建的空对象</font>，所以转成了 object 类型。</p>
<blockquote>
<p>至于具体原因是因为，任何对象都会被转化为二进制，null转为二进制则表示全为0，如果前三个均为0，js就会把它当作是对象，这是js早期遗留下来的bug</p>
</blockquote>
<p><strong>对于复杂数据类型，除了function 全返回object类型</strong>   <font color="red">不过为什么呢？</font></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;凯凯&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;kaikai&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b)  <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c)  <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><strong>总结</strong></p>
<ul>
<li>只能用来判断<code>变量的原型链上是否有构造函数的prototype属性（两个对象是否属于原型链的关系）</code>，不一定能获取对象的具体类型</li>
<li><font color="red">**Instanceof 不适用判断原始类型的值，只能用于判断对象是否从属关系**</font>

</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong><code>[] instanceof Array</code>为true 的解析</strong></p>
<ul>
<li>[].<strong>proto</strong> 的原型 是指向Array.prototype 的，说明两个对象是属于同一条原型链的，返回true。</li>
<li>也就是  <code>[].__proto__ === Array.prototype</code>   其实 []本身就是 Array 的对象，所以很好理解</li>
</ul>
<p><strong>从代码中可以得知<code>person instanceof Person</code>也是返回true的，那么为什么<code>person instanceof Object</code>也为true呢？</strong></p>
<p>是因为存在一条原型链，person这个实例对象的 .proto 也就是 Person 的原型prototype，然而 Person 本身也是一个 Object类的实例对象，所以 Person 的 .proto 也就是 Object的原型prototype。也就是存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.__proto__ === Person.prototype</span><br><span class="line">Person.__proto__ === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/原型链.png" alt=""></p>
<p><strong>注意：空对象 {} 的 instanceof  判断对于 null 有歧义</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Object.create(null) 创建的对象不会继承任何属性或方法，也不会有 Object.prototype 对象上的方法，因此该对象的原型为 null。</span></span><br><span class="line"><span class="comment">// obj2.__proto__ === null</span></span><br><span class="line">obj2.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.create(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这里有疑问因为</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.__proto__) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.__proto__ === &#123;&#125;.prototype)  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.__proto__ === <span class="built_in">Object</span>.prototype)  <span class="comment">// false</span></span><br><span class="line"><span class="comment">//因为obj3.__proto__指向的是空对象&#123;&#125;，而不是Object.prototype。空对象的原型指向Object.prototype，所以obj3.__proto__.__proto__ === Object.prototype是成立的。</span></span><br></pre></td></tr></table></figure>
<h5 id="instanceof-的实现原理"><a href="#instanceof-的实现原理" class="headerlink" title="instanceof  的实现原理"></a>instanceof  的实现原理</h5><p>1.获取对象的原型</p>
<p>2.获取构造函数的 prototype 对象</p>
<p>3.判断构造函数的 prototype 对象是否在对象的原型链上</p>
<p>4.如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">instanceObj,constructorFun</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。</span></span><br><span class="line">    <span class="comment">// 1.获取对象的原型</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(instanceObj)</span><br><span class="line">    <span class="comment">// 2.获取构造函数的 prototype 对象</span></span><br><span class="line">    <span class="keyword">let</span> prototype=<span class="title">constructorFun</span>.<span class="title">prototype</span></span><br><span class="line">    // 3.判断构造函数的 <span class="title">prototype</span> 对象是否在对象的原型链上</span><br><span class="line">    <span class="title">while</span>(<span class="params"><span class="literal">true</span></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!proto)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(proto === prototype)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 4.如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="comment">// myInstanceof(实例对象,构造函数)</span></span><br><span class="line">        <span class="keyword">let</span> res = myInstanceof(date,<span class="built_in">Date</span>)</span><br><span class="line">        <span class="keyword">let</span> res1 = myInstanceof(date,<span class="built_in">Object</span>)</span><br><span class="line">        <span class="keyword">let</span> res2 = myInstanceof(date,<span class="built_in">Array</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(res)<span class="comment">//true</span></span><br><span class="line">        <span class="built_in">console</span>.log(res1)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//具体来说，Array.prototype.__proto__指向Object.prototype，Date.prototype.__proto__指向Object.prototype。</span></span><br><span class="line">        <span class="built_in">console</span>.log(res2)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>原理：<code>每一个实例对象都可通过constructor来访问它的构造函数</code>,其实也是根据原型链的原理来的。</p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/原型链.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span>.__proto__.constructor === <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">5</span>].__proto__.constructor === <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于undefined和null是无效的对象，因此是没有constructor属性的,这两个值不能用这种方法判断.</span></span><br><span class="line"><span class="literal">undefined</span>.__proto__.constructor <span class="comment">// Cannot read property &#x27;__proto__&#x27; of undefined</span></span><br><span class="line"><span class="literal">null</span>.__proto__.constructor <span class="comment">// Cannot read property &#x27;__proto__&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><ul>
<li>Object.prototype.toString方法返回对象的类型字符串，因此可用来判断一个值的类型。</li>
<li>因为实例对象有可能会自定义toString方法，会覆盖Object.prototype.toString，所以在使用时，最好加上call</li>
<li><strong>所有的数据类型都可以使用此方法进行检测，且非常精准</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础类型数据</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;5&#x27;</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">5</span>) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">5</span>]) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="comment">// 复杂类型数据</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// [object Error]</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：强制类型转换和隐式类型转换是什么？举几个例子？"><a href="#面试题：强制类型转换和隐式类型转换是什么？举几个例子？" class="headerlink" title="面试题：强制类型转换和隐式类型转换是什么？举几个例子？"></a>面试题：强制类型转换和隐式类型转换是什么？举几个例子？</h3><p><strong>强制类型转换</strong>，也就是基本数据类型之间的强制转换，使用特定对应的 API进行操作。具体要看 JS 手册</p>
<p>这里举几个例子：</p>
<p>转成 Number类型：</p>
<ul>
<li><code>Number(变量)</code>   可以把一个变量强制转换成数值类型</li>
<li><code>parseInt(变量)</code>   例如   <code>parseInt(&quot;20.5&quot;)  =&gt; 20</code></li>
<li><code>parseFloat(变量)</code>  例如   <code>parseInt(&quot;20.5&quot;)  =&gt; 20.5</code></li>
</ul>
<p>转成 String 类型：</p>
<ul>
<li><code>String(变量)</code>   例如：<code>String(10) =&gt; &quot;10&quot;</code></li>
</ul>
<p>转成 Boolean 类型</p>
<ul>
<li><code>Boolean(变量)</code>  例如：<code>Boolean(1) =&gt; true</code></li>
</ul>
<p><strong>隐式类型转换</strong>，一般是 + 法引起的</p>
<p>例如：  <code>10 + &quot;11&quot;  =&gt; &quot;1011&quot;</code></p>
<p>例如：   <code>1 + true  =&gt; 2</code>   </p>
<font color="blue">隐式类型转换的高级考法：</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果原始类型和对象比较，对象会转为原始类型的值在进行比较。</p>
</li>
<li><p>对象转换为原始类型的值，<strong>先调用对象的 valueOf 方法</strong>，如果返回的还是对象，<strong>再接着调用 toString 方法</strong></p>
<p>因此这里重写 valueOf 或者  toString 方法都是可行的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    i:1,</span><br><span class="line">    toString: () =&gt; a.i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题：js-中-和-的区别"><a href="#面试题：js-中-和-的区别" class="headerlink" title="面试题：js 中 == 和 === 的区别"></a>面试题：js 中 == 和 === 的区别</h3><ul>
<li>对于string、number等基础类型来讲，==和===有很大的区别：<ul>
<li><strong>不同类型：==比较是“转化为同一类型后的值”看“值”是否相同，===如果类型不同，它的结果就是不等。</strong></li>
<li>同类型比较：两者直接进行“值”比较，结果一样</li>
</ul>
</li>
<li>对于Array和Object等高级类型来讲，==和===没有区别，同为“指针地址”比较。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([]==[]);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([]== <span class="number">0</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([]===[]);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([]=== <span class="number">0</span>);  <span class="comment">// false  隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>   <span class="comment">// true   隐式转换 </span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>原始值的比较是值的比较：</strong></p>
<ul>
<li>它们的值相等时它们就相等（==）</li>
<li>对象和原始值不同，<strong>对象的比较并非值的比较,而是引用的比较</strong>：</li>
<li>即使两个对象包含同样的属性及相同的值，它们也是不相等的</li>
<li>即使两个数组各个索引元素完全相等，它们也是不相等的,所以[]!=[]</li>
</ul>
<p>[]==0,是数组进行了隐式转换，空数组会转换成数字0，所以相等</p>
<h2 id="考点-2：传值-VS-传址"><a href="#考点-2：传值-VS-传址" class="headerlink" title="考点 2：传值 VS 传址"></a>考点 2：传值 VS 传址</h2><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><strong>传值</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">let</span> b = a; </span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 1 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：a 和 b 都是基础类型数据，所以其在栈中 分别有一个自己的独立空间。<strong>对于基础变量，访问直接访问到值（即内容）。</strong></p>
<p>对于 b 其实只是 b 空间内的值 变成了 a 地址中的值而已。</p>
<p>然后改变 b 地址里的值，这并不会影起 a 地址中 值的变化。</p>
<h3 id="传址"><a href="#传址" class="headerlink" title="传址"></a><strong>传址</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">name</span>:<span class="string">&quot;hello&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> d = c;</span><br><span class="line">c.name = <span class="string">&quot;hi&quot;</span>; </span><br><span class="line"><span class="comment">//&#123;name:&quot;hi&quot;&#125;	&#123;name:&quot;hi&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c, d);</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>： c 和 d 都属于引用类型数据（复杂类型数据），其真实的数据内容是存在 堆中的，其在堆中的存储地址，并存储在栈中，即 c 和 d 在栈中 存储的是数据内容在堆中的存储地址。</p>
<p>所以 d = c 的时候，<strong>实际是一个引用地址的赋值</strong>，所以 d 和 c 此时存储的堆地址是一致的，那数据内容也是共享的啦。 </p>
<h2 id="考点-3：作用域"><a href="#考点-3：作用域" class="headerlink" title="考点 3：作用域"></a>考点 3：作用域</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(foo()); </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"> 	<span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<p><code>console.log(a);</code>没有报错的原因是， js 中 var 变量有<strong>变量提升机制</strong>，会把定义都自动放到最前面。不过仅仅是声明变量，所以  输出的为 未定义的  <code>undefined</code>。</p>
<p>第二个输出 这个 a 其实是个闭包，的确是修改了 a 的值的。</p>
<h3 id="面试题：谈谈你对-作用域链-的理解"><a href="#面试题：谈谈你对-作用域链-的理解" class="headerlink" title="面试题：谈谈你对 作用域链 的理解"></a>面试题：谈谈你对 作用域链 的理解</h3><p>当所需要的变量，在所在的<strong>作用域中查找不到的时候，它会一层一层向上查找，直到找到全局作用域</strong>还没有找到的时候，就会放弃查找。这种一层一层的关系，就是作用域链。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a); </span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> func = check(); </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>作用域链是这么产生的：</p>
<ul>
<li><p>首先在  function 中 我没有定义a 和 b 啊</p>
</li>
<li><p>我回到 check 里找，还是没有定义 a 和 b 啊</p>
</li>
<li><p>我再跳出 check 函数，去最外面的全局变量中找，然后找到了 a 输出，b 还是没找到，所以表示为未定义，进而就报错了  <code>ReferenceError: b is not defined</code></p>
</li>
</ul>
<h2 id="考点-4：闭包"><a href="#考点-4：闭包" class="headerlink" title="考点 4：闭包"></a>考点 4：闭包</h2><h3 id="面试题：什么是闭包？如何理解闭包？"><a href="#面试题：什么是闭包？如何理解闭包？" class="headerlink" title="面试题：什么是闭包？如何理解闭包？"></a>面试题：什么是闭包？如何理解闭包？</h3><p><strong>闭包是：指有权访问另一个函数作用域中的变量的函数；</strong> </p>
<p>对于正常的 JS 函数：在 js 中变量的作用域属于函数作用域, 在函数执行完后，作用域就会被清理，内存也会随之被回收。</p>
<p><strong>但是由于闭包函数是建立在函数内部的子函数, 由于它可以访问上级作用域，即使上级函数执行完, 作用域也不会随之销毁,。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;kaikai&quot;</span>  <span class="comment">// 这个变量后续还要用，所以不会被释放</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">100</span>    <span class="comment">// 后续用不到，会释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="comment">// 被return 并被变量接住，不会被释放</span></span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;1111111111111&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = outer()</span><br><span class="line"><span class="built_in">console</span>.log(func())</span><br></pre></td></tr></table></figure>
<h3 id="面试题：闭包的优缺点"><a href="#面试题：闭包的优缺点" class="headerlink" title="面试题：闭包的优缺点"></a>面试题：闭包的优缺点</h3><p>优点为： 可以让临时变量常驻与内存</p>
<p>缺点为：由于临时变量没有及时的释放，堆在一起，导致内存爆炸而形成 内存泄露  </p>
<p>可以例如：  func = null  来清除</p>
<h3 id="闭包的应用：-函数柯里化-（要回写）"><a href="#闭包的应用：-函数柯里化-（要回写）" class="headerlink" title="闭包的应用： 函数柯里化 （要回写）"></a>闭包的应用： 函数柯里化 （要回写）</h3><p>函数柯里化：<strong>使用多个参数的函数</strong>转换成一系列<strong>使用一个参数的函数多次</strong>的技术。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// curry 就是一个函数柯里化的过程</span></span><br><span class="line"><span class="keyword">let</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>现在就是要实现 curry 这个函数，<font color="red"><strong>使函数从一次调用传入多个参数变成多次调用每次传一个参数。</strong></font></p>
<p>简单的说如果 入参 &gt;= 函数的 入参个数，就直接执行，否则就 返回一个  待接收 后续入参的 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根哥版本的 函数柯里化</span></span><br><span class="line"><span class="comment">// ... args 是剩余参数一起接受的意思</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn这个函数能取 length 表示这个函数参数的个数</span></span><br><span class="line">    <span class="comment">// 是 ES6 的语法</span></span><br><span class="line">    <span class="keyword">let</span> fnLen = fn.length</span><br><span class="line">    <span class="keyword">const</span> argsLen = args.length</span><br><span class="line">    <span class="comment">// argsLen 入参少于要求的 入参个数 就 接着接收 直到 达到 要求入参个数</span></span><br><span class="line">    <span class="keyword">if</span> (fnLen &gt; argsLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curry(fn, ...args, ...args2)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// this 指针指的是全局  然后就是 全局中调用 fn 也就是 add函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>举一个现实的例子</strong></p>
<font color="blue">例如：我们有一个自定义的排序方法，然而我们每次对数组进行操作，都会把 这个自定义的函数方法给带上，这就导致了麻烦。</font>



<p>所以这个时候可以利用到函数柯里化，使得我们只需要传入 需要排序的数组即可，而我们自定义的排序方法其实就像 闭包一样存储在内存，无法释放。</p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/根哥柯里化.png" alt=""></p>
<h2 id="考点-5：原型链和继承"><a href="#考点-5：原型链和继承" class="headerlink" title="考点 5：原型链和继承"></a>考点 5：原型链和继承</h2><h3 id="面试题：-new-操作符的实现原理"><a href="#面试题：-new-操作符的实现原理" class="headerlink" title="面试题： new 操作符的实现原理"></a>面试题： new 操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p>
<ol>
<li>首先创建了一个新的空对象</li>
<li>设置原型，将对象的原型设置为函数的 prototype 对象。</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建新对象</span></span><br><span class="line">   <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">   <span class="keyword">let</span> <span class="title">constructor</span>=[].<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>)   // [ ]相当于 <span class="title">Array</span>.<span class="title">prototype</span></span><br><span class="line">    // 2.将对象的 <span class="title">__proto__</span> 赋值为构造函数的 <span class="title">prototype</span> 属性</span><br><span class="line">   <span class="title">obj</span>.<span class="title">__proto__</span>=<span class="title">constructor</span>.<span class="title">prototype</span></span><br><span class="line">   // 3.将构造函数内部的 <span class="title">this</span> 赋值为新对象，并且为新对象添加属性</span><br><span class="line">   <span class="title">let</span> <span class="title">ret</span> = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">obj,<span class="built_in">arguments</span></span>)</span><br><span class="line">   // 4.返回新对象(<span class="params"><span class="built_in">this</span></span>)</span><br><span class="line">   <span class="title">return</span> <span class="title">typeof</span> <span class="title">ret</span> === &quot;<span class="title">object</span>&quot; &amp;&amp; <span class="title">ret</span> !== <span class="title">null</span>? <span class="title">ret</span> : <span class="title">obj</span></span><br><span class="line">&#125;</span><br><span class="line">// 构造函数</span><br><span class="line"><span class="title">function</span> <span class="title">Person</span>(<span class="params">name, member</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.member = member;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仿造new后的对象</span></span><br><span class="line"><span class="keyword">let</span> p = fNew(Person,<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/D2B5CA33BD970F64A6301FA75AE2EB22.png" alt=""></p>
<h3 id="面试题：构造函数-和-实例的-原型关系"><a href="#面试题：构造函数-和-实例的-原型关系" class="headerlink" title="面试题：构造函数 和 实例的 原型关系"></a>面试题：构造函数 和 实例的 原型关系</h3><p><strong>原型链：</strong>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。<font color="blue"><strong>下图中蓝色的这条就是原型链</strong></font></p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/构造函数与实例.png" alt=""></p>
<p>注意一些细节：</p>
<p><strong>constructor</strong></p>
<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><code>__proto__</code> <strong>表示的原型的意思</strong></p>
<p>其次是 <code>__proto__</code> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，</p>
<p>实际上，它是来自于 Object.prototype ，<strong>与其说是一个属性，不如说是一个 getter/setter</strong>，当使用 <code>obj.__proto__</code> 时，可以理解成返回了 Object.getPrototypeOf(obj) （ES5）。</p>
<p><strong>原型链继承：</strong>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。</p>
<p>根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找他对应的父类，相当于一个对象可以父类的属性和方法了。</p>
<p><strong>原型的定义 prototype</strong></p>
<ul>
<li><p><strong>每一个函数天生自带一个成员，叫做 prototype，是一个对象空间</strong>，所以你打印的时候显示 {}</p>
</li>
<li><p>即然每一个函数都有，构造函数也是函数，构造函数也有这个对象空间</p>
</li>
<li><p>这个 <code>prototype</code> 对象空间可以由函数名来访问，<font color="red"><strong>相当于我们的继承的东西是写在 原型对象空间中的</strong>。</font></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype) <span class="comment">// 是一个对象</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;prototype&#x27;</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function Student()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person()</span><br></pre></td></tr></table></figure>
<h3 id="面试题：ES5的继承有哪几种"><a href="#面试题：ES5的继承有哪几种" class="headerlink" title="面试题：ES5的继承有哪几种"></a>面试题：ES5的继承有哪几种</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/124ed22c4844">https://www.jianshu.com/p/124ed22c4844</a></p>
<p><strong>原型链继承、构造继承、组合继承、寄生组合式继承</strong></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>  <strong>子类构造函数的原型对象指向父类构造函数的实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<p>让子类构造函数的原型对象，成为父类构造函数的实例，子类的实例通过原型链访问父类原型对象上的属性和方法。</p>
<font color="red">存在的问题：1实例上有引用（复杂）类型，所有实例都会共享这个引用类型。对于普通基础类型，各实例之间是独立的  2. .在创建子类型时，无法想父类的构造函数传递参数</font>

<h4 id="构造函数继承（经典继承）"><a href="#构造函数继承（经典继承）" class="headerlink" title="构造函数继承（经典继承）"></a>构造函数继承（经典继承）</h4><p>构造函数继承的本质：在子类构造函数内部调用父类构造函数。也就是 java 的 super</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.color = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 这个相当于改变 原本Person的this指针 现在指向Student</span></span><br><span class="line"><span class="comment">// 用apply也是可以的  </span></span><br><span class="line"><span class="comment">// 注意：构造函数继承只能 继承属性</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;guoguo&#x27;</span>)</span><br><span class="line">stu1.color.push(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stu1) </span><br><span class="line"><span class="comment">// &#123;name:&#x27;guoguoguo&#x27;, color: [&#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> Student(<span class="string">&#x27;yuyuyu&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stu2)  </span><br><span class="line"><span class="comment">// &#123;name:&#x27;guoguoguo&#x27;, color: [&#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>
<p>经典继承可以解决原型链继承不能向父类传参和实例共享引用类型值问题，但是它的<strong>缺点</strong>：</p>
<font color="red">实例无法共享父类原型对象上的方法和属性</font>



<h4 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h4><p>组合式继承的本质：<font color="blue">将原型链继承和构造函数继承组合到一起，借用构造函数来实现对实例属性的继承，借用原型链继承实现对原型对象的属性和方法的继承</font></p>
<font color="red">确定：组合继承调用了父类构造函数两次，造成了不必要的消耗</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.friend = [<span class="string">&#x27;lucky&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getFriend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;找呀找呀找朋友&#x27;</span>, <span class="built_in">this</span>.friend)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Parent(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;lily&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stu1)</span><br></pre></td></tr></table></figure>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承的原理：在create函数内部，先创建一个临时性的构造函数，将传入的对象作为这个构造函数的原型，然后返回这个临时构造函数的新实例。</p>
<p>本质上讲，<strong>Create对其传入的对象执行了一次浅复制</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fun.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Fun()</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> another1 = Create(person)</span><br><span class="line"></span><br><span class="line">another1.name.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> another2 = Create(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(another1.name) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(another2.name) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>缺点：原型式继承,包含引用类型值的属性，<strong>始终都会共享相应的值</strong>，就像使用引用类型一样</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承的核心：<strong>在原型式继承的基础上，增强对象，返回构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fun</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fun.prototype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateAnother</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = Create(obj)</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的主要作用就是为构造函数新增属性和方法，以增强对象</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;guojing&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = CreateAnother(person1)</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// 普通类型  Fun &#123;sayHi: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = &#123;<span class="attr">newArr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125; <span class="comment">//引用类型</span></span><br><span class="line"><span class="keyword">let</span> p2 = CreateAnother(person2)</span><br><span class="line">p2.newArr.push(<span class="number">5</span>)  </span><br><span class="line"><span class="built_in">console</span>.log(person2)  <span class="comment">//&#123;newArr: [1, 2, 3, 4, 5]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2)  <span class="comment">// Fun &#123;sayHi: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>原型式继承多个实例的引用类型属性指向相同，存在篡改的可能</li>
<li>无法传递参数</li>
</ul>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>借用构造函数来继承属性，通过原型链的混合模式来继承方法，其背后的思路是：<br>不必为了执行子类型的原型而调用父类构造函数，使用寄生式继承来继承父类的原型，然后将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在子类构造函数里调用父类的构造函数，继承构造函数属性的继承，并可以给父类构造函数传参</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立子类原型对象和父类原型对象的连接，通过Object.create方法对父类原型进行浅复制，再复制给子类原型</span></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype) </span><br><span class="line"><span class="comment">// 通过以上操作，Student.prototype.constructor指向的是Person,再进行增强原型，将constructor指向Student</span></span><br><span class="line">Student.prototype.constructor = Student </span><br></pre></td></tr></table></figure>
<h3 id="面试题：ES5-和-ES6-是如何是实现-类继承的"><a href="#面试题：ES5-和-ES6-是如何是实现-类继承的" class="headerlink" title="面试题：ES5 和 ES6 是如何是实现 类继承的"></a>面试题：ES5 和 ES6 是如何是实现 类继承的</h3><h4 id="ES5-的继承"><a href="#ES5-的继承" class="headerlink" title="ES5 的继承"></a>ES5 的继承</h4><p>只要记住存在类的原型对象中就可以了。</p>
<p>这里也就是 构造函数继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, grade</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这个相当于改变 原本Person的this指针 现在指向Student</span></span><br><span class="line">    <span class="comment">// 用apply也是可以的  </span></span><br><span class="line">    <span class="comment">// 注意：构造函数继承只能 继承属性</span></span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age)</span><br><span class="line">    <span class="comment">// Person.apply(this, [name, age])</span></span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Student(<span class="string">&quot;kaikai&quot;</span>,<span class="number">24</span>,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">// 不好使因为只能 继承属性，原型上的方法没法继承</span></span><br><span class="line">obj.say()</span><br></pre></td></tr></table></figure>
<h4 id="ES6-的继承与-Java基本一致（要会写）"><a href="#ES6-的继承与-Java基本一致（要会写）" class="headerlink" title="ES6 的继承与 Java基本一致（要会写）"></a>ES6 的继承与 Java基本一致（要会写）</h4><p>使用 <code>constructor</code> 作为构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name,color</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// toString 是原型对象上的属性 并且是重写的哦</span></span><br><span class="line">   <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;,color:&#x27;</span> + <span class="built_in">this</span>.color);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);<span class="comment">//实例化Animal</span></span><br><span class="line">animal.toString();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.</span></span><br><span class="line">   <span class="comment">// 如果没有置顶consructor,默认带super函数的constructor将会被添加、</span></span><br><span class="line">   <span class="built_in">super</span>(<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">   <span class="built_in">this</span>.action = action;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 重载父类原型对象 上的方法</span></span><br><span class="line"> <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">super</span>.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;catch&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cat.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\96356\AppData\Roaming\Typora\typora-user-images\image-20230214175610951.png" alt="image-20230214175610951"></p>
<p>a 是  类A 的实例对象， b是 类B 的实例对象。B类是A类的子类。</p>
<p>所以 a 的 proto 是 A的原型，没问题。 b 的 proto 是B 的原型也没问题。</p>
<p><strong>B类的proto也就是 A 。</strong></p>
<p><strong>B的prototye 也就是 实例对象 b 的proto，</strong>实际是个对象空间但是属于A。</p>
<p>所以其 <strong>proto</strong> 就是 A 对应的 对象空间 { } </p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/原型与继承.png" alt=""></p>
<h2 id="考点6：Map-、-Set、weakSet-和-weakMap"><a href="#考点6：Map-、-Set、weakSet-和-weakMap" class="headerlink" title="考点6：Map 、 Set、weakSet 和 weakMap"></a>考点6：Map 、 Set、weakSet 和 weakMap</h2><h3 id="面试题：如何理解-Map-与-普通对象的区别"><a href="#面试题：如何理解-Map-与-普通对象的区别" class="headerlink" title="面试题：如何理解 Map 与 普通对象的区别"></a>面试题：如何理解 Map 与 普通对象的区别</h3><p>Map的key相比较普通对象来说更为灵活，</p>
<ul>
<li>普通对象的key只能以基础数据类型作为key值，并且所有传入的key值都会被转化成string类型</li>
<li>Map的key可以是各种数据类型格式。</li>
</ul>
<h3 id="面试题：weakMap-和-Map，weakSet-和-Set-的区别？"><a href="#面试题：weakMap-和-Map，weakSet-和-Set-的区别？" class="headerlink" title="面试题：weakMap 和 Map，weakSet 和 Set 的区别？"></a>面试题：weakMap 和 Map，weakSet 和 Set 的区别？</h3><p><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/6">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/6</a></p>
<p><strong>Map</strong>  叫做字典</p>
<ul>
<li><p>本质上是健值对的集合，类似集合</p>
</li>
<li><p>Map 的键 key实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;]是Array 也就是复杂数据类型，地址每次是不一样的</span></span><br><span class="line">map.set([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以遍历</strong>，方法API 很多，可以干跟各种数据格式转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个哈希表</span></span><br><span class="line"><span class="keyword">const</span> symbolValues = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">symbolValues.set(<span class="string">&quot;I&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">const</span> value = symbolValues.get(<span class="string">&quot;I&quot;</span>)</span><br><span class="line"></span><br><span class="line">使用 <span class="keyword">for</span>...of遍历</span><br><span class="line"><span class="built_in">console</span>.log(map.entries())	<span class="comment">// 类似于 MapIterator &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.keys()) <span class="comment">// 类似于 MapIterator &#123;&quot;name&quot;, &quot;des&quot;&#125;</span></span><br><span class="line">size：返回字典中所包含的元素个数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>weakMap</strong></p>
<ul>
<li>键key 必须是<strong>复杂数据类型</strong>（null 空对象是不行的），其他类型数据都不行 <strong>，而值可以是任意</strong></li>
<li>键key 所指向的对象，并且key值是<strong>弱引用</strong>，不计入垃圾回收机制</li>
<li>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。<font color="red"><strong>不能遍历</strong></font>，方法同  <code>get,set,has,delete</code></li>
</ul>
<p><strong>Set </strong> 叫做集合</p>
<ul>
<li><p>成员不能重复，放入任何数据类型都可以</p>
</li>
<li><p>只有健值，没有健名，有点类似数组。</p>
</li>
<li><p><strong>可以遍历</strong>，方法有add, delete,has，clear()</p>
<p>size：返回字典中所包含的元素个数</p>
</li>
</ul>
<p><strong>weakSet</strong></p>
<ul>
<li>WeakSet 只能储存对象引用，不能存放值</li>
<li><strong>成员都是弱引用，随时可以消失。</strong> 可以用来保存DOM节点，不容易造成内存泄漏</li>
<li><font color="red"><strong>不能遍历</strong></font>，方法同有add, delete,has， clear已废弃</li>
</ul>
<h2 id="考点7：JS-中的this"><a href="#考点7：JS-中的this" class="headerlink" title="考点7：JS 中的this"></a>考点7：JS 中的this</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903488304971789">https://juejin.cn/post/6844903488304971789</a></p>
<p>😎首先对this的下个定义：<strong>this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。</strong></p>
<p><strong>JS 中 this 存在 严格模式和非严格模式 两种</strong>  一般使用  <code>&#39;use strict&#39;;</code> 进行声明表示 严格模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fun() &#123;</span><br><span class="line">   &#x27;use strict&#x27;; </span><br><span class="line">    var a = 2;</span><br><span class="line">      return this.a;</span><br><span class="line">&#125;</span><br><span class="line">fun();//😨报错 Cannot read property &#x27;a&#x27; of undefined</span><br><span class="line">// 不使用 &#x27;use strict&#x27;;  1</span><br></pre></td></tr></table></figure>
<ul>
<li>严格模式下，<strong>this指向undefined;</strong></li>
<li>非严格模式下， <strong>this指向window;</strong></li>
</ul>
<ul>
<li>对于对象中的 this 指针，this 指向对象本身</li>
<li><strong>当obj在一个函数中声明的时候，</strong><ul>
<li><strong>严格模式下this会指向undefined，</strong></li>
<li><strong>非严格模式自动转为指向全局对象 window。 </strong></li>
</ul>
</li>
</ul>
<p>看🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="built_in">this</span>.a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">          <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 非严格模式 因为是在函数里 所以 this 指向 window</span></span><br><span class="line">        <span class="attr">c</span>: <span class="built_in">this</span>.a + <span class="number">2</span> <span class="comment">//严格模式下这块报错 Cannot read property &#x27;a&#x27; of undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun());<span class="comment">//1002</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b);<span class="comment">//1001</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：在五种情景下，this指针指向谁？"><a href="#面试题：在五种情景下，this指针指向谁？" class="headerlink" title="面试题：在五种情景下，this指针指向谁？"></a>面试题：在五种情景下，this指针指向谁？</h3><p>这五种情景分别为：</p>
<font color="red"> **this 永远指向最后调用它的那个对象**</font>

<ul>
<li>在全局环境或是普通函数中直接调用</li>
<li>作为对象的方法</li>
<li>使用apply和call</li>
<li>作为构造函数</li>
<li>箭头函数中</li>
</ul>
<h4 id="在全局环境或是普通函数中直接调用"><a href="#在全局环境或是普通函数中直接调用" class="headerlink" title="在全局环境或是普通函数中直接调用"></a><strong>在全局环境或是普通函数中直接调用</strong></h4><p>再写☝️🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj  =  &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 函数内的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 这个 this 在非严格模式下就是 全局对象 window</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in">console</span>.log(fun());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">obj.b();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<font color="red">**当this 在函数内独立调用的时候，**</font>

<ul>
<li><strong>在严格模式下它的this指向undefined，</strong></li>
<li><strong>在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window)</strong></li>
</ul>
<h4 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a><strong>作为对象的方法</strong></h4><p>👆b所引用的匿名函数作为obj的一个方法调用，这时候this指向调用它的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 单纯的匿名函数</span></span><br><span class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 所以 this 指向的是 obj  这里遵循谁调用是谁的原理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b())<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>那么如果b方法不作为对象方法调用呢？啥意思呢，就是这样👇：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用一个变量取</span></span><br><span class="line"><span class="keyword">var</span> t = obj.b;</span><br><span class="line"><span class="built_in">console</span>.log(t());<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>这就涉及Javascript的内存空间了，就是说，<strong>obj对象的b属性存储的是对该匿名函数的一个引用</strong>，可以理解为一个指针。<strong>当赋值给t的时候，并没有单独开辟内存空间存储新的函数，而是让t存储了一个指针，该指针指向这个函数。</strong>相当于代码变成了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;<span class="comment">//此函数存储在堆中</span></span><br><span class="line">    <span class="comment">// 所以这个 this 相当于第一种情况 函数的直接调用，所以是 window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: fun <span class="comment">//b指向fun函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = fun;<span class="comment">//变量t指向fun函数</span></span><br><span class="line"><span class="built_in">console</span>.log(t());<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>此时的t就是一个指向fun函数的指针，调用t，相当于直接调用fun，套用以上规则，打印出来1自然很好理解了。</p>
<h4 id="使用apply和call-以及bind"><a href="#使用apply和call-以及bind" class="headerlink" title="使用apply和call 以及bind"></a><strong>使用apply和call</strong> 以及bind</h4><p>call 和 apply 方法都可以改变当前指针为 参数的第一个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">obj.b()</span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line">obj.b.call(obj)</span><br></pre></td></tr></table></figure>
<p>这两个其实表现的是一个意思，就是语法糖。<em>指的是在计算机语言中添加的某种语法</em>,这种语法对语言的编译结果和功能并没有实际影响。</p>
<h4 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        console.log(this.name, &quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">// extends 原型继承</span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    constructor(name,age,grade)&#123;</span><br><span class="line">        // 实现对 父类属性的继承</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.grade = grade</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 方法 覆盖 并调用父类say方法</span><br><span class="line">    say()&#123;</span><br><span class="line">        super.say()</span><br><span class="line">        console.log(this.name, &quot;congratulate! &quot;, this.grade)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = new Student(&quot;kaikai&quot;,24,100)</span><br><span class="line">obj.say()</span><br></pre></td></tr></table></figure>
<p><strong>如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。</strong></p>
<h4 id="箭头函数中"><a href="#箭头函数中" class="headerlink" title="箭头函数中"></a>箭头函数中</h4><font color="blue">箭头函数是一个**不可以用call和apply改变this的典型。**</font>

<p>我们看下面这个🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line"><span class="comment">// 此处 fun函数的上下文是 window 所以this 也是window</span></span><br><span class="line">fun();<span class="comment">//1</span></span><br><span class="line"><span class="comment">// 因为fun是个箭头函数  call 和 apply 只能传参</span></span><br><span class="line">fun.call(obj)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p><strong>箭头函数会捕获其所在上下文的 <code>this</code> 值，作为自己的 <code>this</code> 值</strong>，也就是说箭头函数的this在词法层面就完成了绑定。apply，call方法只是传入参数，却改不了this。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    f();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// fun 的上下文还是 window 所以 this 指向window</span></span><br><span class="line">fun();<span class="comment">//1</span></span><br><span class="line">fun.call(obj);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>但是这里fun 本身是个普通函数，不是箭头函数，所以 call 的指针改变对她是有效的，所以新的上下文重新被建立了，此时fun的  this 指向的是 obj。</p>
<p>再来一个🌰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Damonare&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Fun.prototype.say = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fun();</span><br><span class="line">f.say();<span class="comment">//this 是 window </span></span><br></pre></td></tr></table></figure>
<p>这个虽然说是 构造函数里的方法，但是他是个箭头函数，所以 this 指的还是他的上下文 也就是 f 对应的 window。</p>
<h2 id="考点8：浅拷贝和深拷贝"><a href="#考点8：浅拷贝和深拷贝" class="headerlink" title="考点8：浅拷贝和深拷贝"></a>考点8：浅拷贝和深拷贝</h2><h3 id="面试题：如何理解深浅拷贝"><a href="#面试题：如何理解深浅拷贝" class="headerlink" title="面试题：如何理解深浅拷贝"></a>面试题：如何理解深浅拷贝</h3><ul>
<li>浅拷贝：一般指的是把对象的<strong>第一层拷贝到一个新对象上去， 并新建地址引用</strong>，其内部第二层及其以后引用地址均不会发生变化。</li>
<li>深拷贝：一般需要借助递归实现，如果对象的值还是个对象，要进一步的深入拷贝，<strong>完全替换掉每一个复杂类型的引用。</strong></li>
</ul>
<p><strong>浅拷贝</strong>🌰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">count</span>: <span class="number">1</span>, <span class="attr">deep</span>: &#123; <span class="attr">count</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;...a&#125;</span><br><span class="line"></span><br><span class="line">a.count = <span class="number">3</span></span><br><span class="line">b.count = <span class="number">1</span>  <span class="comment">// b 的第一层内容地址是全新的引用地址 所以 改变a 不会引起 b的变化</span></span><br><span class="line">a.deep.count = <span class="number">5</span></span><br><span class="line">b.deep.count <span class="comment">// 5 因为浅拷贝并不改变第二层的引用地址</span></span><br></pre></td></tr></table></figure>
<p><strong>深拷贝</strong>🌰</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">count</span>: <span class="number">1</span>, <span class="attr">deep</span>: &#123; <span class="attr">count</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> b = deepCopy(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅层</span></span><br><span class="line">a.count = <span class="number">3</span></span><br><span class="line">b.count  <span class="comment">// 1  </span></span><br><span class="line"><span class="comment">// 深层</span></span><br><span class="line">a.deep.count = <span class="number">5</span></span><br><span class="line">b.deep.count <span class="comment">// 2  因为深拷贝是 任意一层的 数据引用地址完全发生变化，所以其 算是个独立数据 a的修改 和 b 一点关系没有</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：实现深拷贝代码-（手写）"><a href="#面试题：实现深拷贝代码-（手写）" class="headerlink" title="面试题：实现深拷贝代码 （手写）"></a>面试题：实现深拷贝代码 （手写）</h3><p><strong>方法一 ： 采用递归去拷贝所有层级属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCopy = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 obj 是对象还是数组 用对应的进行收纳</span></span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>? [] :&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> value = obj[key]</span><br><span class="line">        newObj[key] = <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>? deepCopy(value) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deepCopy(a)  <span class="comment">// a 是个 obj</span></span><br></pre></td></tr></table></figure>
<p><strong>方法二：使用JSON.stringify和JSON.parse实现深拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objTemp = <span class="built_in">JSON</span>.stringify(obj1);</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(objTemp);</span><br><span class="line">    <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法三：使用node库 lodash</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = lodash.cloneDeep(obj1);</span><br></pre></td></tr></table></figure>
<h2 id="考点9：事件冒泡和事件捕获以及事件代理"><a href="#考点9：事件冒泡和事件捕获以及事件代理" class="headerlink" title="考点9：事件冒泡和事件捕获以及事件代理"></a>考点9：事件冒泡和事件捕获以及事件代理</h2><h3 id="面试题：事件冒泡、事件捕获的定义？"><a href="#面试题：事件冒泡、事件捕获的定义？" class="headerlink" title="面试题：事件冒泡、事件捕获的定义？"></a>面试题：事件冒泡、事件捕获的定义？</h3><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中<strong>事件流</strong>（事件发生顺序）的问题。</p>
<font color="blue">假设我们父子两个元素，均有对应的触发事件。</font>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span> ο<span class="attr">nclick</span>=<span class="string">&quot;method1()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span> ο<span class="attr">nclick</span>=<span class="string">&quot;method2()&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/事件冒泡和事件捕获.png" style="zoom:50%;" /></p>
<font color="blue">JS dom的事件流三个阶段：1-5是事件捕获过程，5-6是处于目标阶段，6-10是事件冒泡阶段；</font>

<p><strong>事件冒泡</strong></p>
<p>微软提出了名为<strong>事件冒泡</strong>(event bubbling)的事件流。</p>
<p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，  那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一 级根据嵌套关系向外触发，直document/window，冒泡过程结束。  </p>
<p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是</p>
<p><strong>p -&gt; div -&gt; body -&gt; html -&gt; document</strong></p>
<p><strong>事件捕获</strong></p>
<p>网景提出另一种事件流名为<strong>事件捕获</strong>(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p>
<p>上面的例子在事件捕获的概念下发生click事件的顺序应该是</p>
<p><strong>document -&gt; html -&gt; body -&gt; div -&gt; p</strong></p>
<h3 id="面试题：如何开启事件冒泡-或者-事件捕获？"><a href="#面试题：如何开启事件冒泡-或者-事件捕获？" class="headerlink" title="面试题：如何开启事件冒泡 或者 事件捕获？"></a>面试题：如何开启事件冒泡 或者 事件捕获？</h3><p>addEventListener 方式（称为dom2级方式）方式中</p>
<p>语法： <code>元素.addEventListener(&#39;事件类型&#39;， 事件处理函数， 冒泡还是捕获)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oDiv.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">  console.log(&#x27;我是第一个事件&#x27;)</span><br><span class="line">&#125;, false)</span><br><span class="line">// false 表示 开启冒泡 </span><br><span class="line">// true 表示 开启捕获</span><br></pre></td></tr></table></figure>
<font color="blue">注意： 并非所有的事件都支持冒泡，比如focus，blur等等</font>

<h3 id="面试题：如何理解-事件流的优势-即事件委托的优势？"><a href="#面试题：如何理解-事件流的优势-即事件委托的优势？" class="headerlink" title="面试题：如何理解 事件流的优势 即事件委托的优势？"></a>面试题：如何理解 事件流的优势 即事件委托的优势？</h3><p>举个例子 我们现在有 如下的结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;color_list&quot;</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>purple<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/事件委托的例子.png" alt=""></p>
<p>想要实现的功能为：<strong>在点击每个 li 标签时，在下面输出li当中的颜色<code>（innerHTML）</code></strong></p>
<p>如果不使用事件委托，其<strong>常规的做法</strong>应该事 为每个 li 标签都绑定一个功能点击事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> color_list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.color_list&quot;</span>);     </span><br><span class="line"><span class="keyword">var</span> colors = color_list.getElementsByTagName(<span class="string">&quot;li&quot;</span>);         </span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.box&quot;</span>);            </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; colors.length; i++)&#123;                </span><br><span class="line">    colors[i].addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        <span class="comment">// this 由于事普通函数 谁点谁是this</span></span><br><span class="line">        <span class="comment">// 所以 this 指的是 colors[i]</span></span><br><span class="line">        box.innerHTML=<span class="string">&quot;该颜色为 &quot;</span>+<span class="built_in">this</span>.innerHTML;             </span><br><span class="line">    &#125;)            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法的弊端是，代码比较繁琐，并且 构建了一个循环，如果 li 标签很多性能是很差的。且不能动态的为新添加的 li 元素添加事件。</p>
<p><strong>使用事件委托</strong></p>
<p><strong>事件委托</strong>指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父 元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，<font color="blue">通过判断事件发生元素DOM的类型，来做出不同的响应。  </font></p>
<ul>
<li><font color="red">原理是：`evt.target` 永远拿到的都是最深层的目标节点，在点击节点的时候，由于冒泡的原因，触发了父节点的点击事件，这个时候可以通过 evt.target 拿到真正点击的深层子节点，然后做进一步逻辑</font>



</li>
</ul>
<p>使用事件委托，即我们利用事件流的特性，通过将事件绑定在 li 的父组件上。</p>
<p>利用冒泡机制，可以让父元素触发对应的事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorChange</span>(<span class="params">event</span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//even.target 是事件源</span></span><br><span class="line">    <span class="keyword">if</span>(event.target.nodeName.toLowerCase()===<span class="string">&quot;li&quot;</span>)&#123;         </span><br><span class="line">        box.innerHTML=<span class="string">&quot;该颜色为 &quot;</span>+e.target.innerHTML;         </span><br><span class="line">    &#125;                            </span><br><span class="line">&#125;            </span><br><span class="line">color_list.addEventListener(<span class="string">&quot;click&quot;</span>,colorChange,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p><strong>由于事件冒泡机制，点击了 li 后会冒泡到 ul ，此时就会触发绑定在 ul 上的点击事件，再利用 target 找到事件实际发生的元素（事件源 即 li），就可以达到预期的效果。</strong></p>
<font color="blue">比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。  </font>



<h3 id="面试题：阻止事件冒泡的-方法有哪些？"><a href="#面试题：阻止事件冒泡的-方法有哪些？" class="headerlink" title="面试题：阻止事件冒泡的 方法有哪些？"></a>面试题：阻止事件冒泡的 方法有哪些？</h3><p><strong>stopPropagation 方法</strong></p>
<p>在某个元素上定义 一个事件 <strong>例如onclick 的自定义函数中，添加 事件对象</strong>，然后就会<strong>阻止冒泡</strong></p>
<p>用法： <code>evt.stopPropagation()</code></p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/阻止事件冒泡.png" alt=""></p>
<ul>
<li><strong>event.target返回的是，触发事件的元素</strong></li>
<li><strong>event.currentTarget返回的是，绑定事件的元素</strong></li>
</ul>
<h3 id="面试题：有哪些方法可以阻止默认行为？"><a href="#面试题：有哪些方法可以阻止默认行为？" class="headerlink" title="面试题：有哪些方法可以阻止默认行为？"></a>面试题：有哪些方法可以阻止默认行为？</h3><p>默认行为 以及对应的阻止效果 指的是，例如：</p>
<ul>
<li>a 标签 一定会进行跳转，阻止的话就是我不跳转，我就要个你的跳转地址</li>
<li>form 表单的 submit button，点击一定会进行表单提交， 阻止的话表示我不先交，我还想验证一下你写的格式对不对等问题</li>
<li>document的oncontextmenu （右击方法），默认是显示浏览器自带的审查列表，我不想要，想自定义</li>
<li>…</li>
</ul>
<h4 id="dom0-onxxx方式-直接-return-false"><a href="#dom0-onxxx方式-直接-return-false" class="headerlink" title="dom0 onxxx方式  直接 return false"></a>dom0 <code>onxxx</code>方式  直接 return false</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;右键点击，自定义右键菜单&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dom2addEventListener方式-事件对象-preventDefault"><a href="#dom2addEventListener方式-事件对象-preventDefault" class="headerlink" title="dom2addEventListener方式   事件对象.preventDefault()"></a>dom2<code>addEventListener</code>方式   事件对象.preventDefault()</h4><p>实测 IE 高版本 11 也是使用的 <code>事件对象.preventDefault()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;contextmenu&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;右键点击，自定义右键菜单&quot;</span>)</span><br><span class="line">    evt.preventDefault()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="考点10：BOM-与-DOM-操作"><a href="#考点10：BOM-与-DOM-操作" class="headerlink" title="考点10：BOM 与 DOM 操作"></a>考点10：BOM 与 DOM 操作</h2><p><strong>BOM 是即浏览器对象模型。</strong></p>
<p>其属性对象有：<strong>window对象</strong>、window对象的属性 ： location对象、history对象、Navigator对象等</p>
<p><strong>location对象</strong>主要是存储和 URL 有关的东西，例如：</p>
<ul>
<li>location.href— 返回或设置当前文档的URL  </li>
<li>location.host—返回URL中的域名部分</li>
<li>location.hostname— 返回URL中的主域名部分</li>
<li>location.protocol— 返回URL中的协议部分</li>
</ul>
<p><strong>history对象</strong> 存储了浏览器浏览记录</p>
<ul>
<li>history.go()— 前进或后退指定的页面数 history.go(num);  </li>
<li>history.back()— 后退一页  </li>
<li>history.forward()— 前进一页</li>
</ul>
<p><strong>Navigator对象</strong> </p>
<ul>
<li>navigator.userAgent—  返回用户代理头的字符串表示(就是包括浏览器版本信息等的字 符串)  </li>
<li>navigator.cookieEnabled— 返回浏览器是否支持(启用)cookie</li>
</ul>
<p><strong>DOM 是文档对象模型。</strong>利用 DOM 我们可以操作 HTML 中的元素，使得网页被下载到浏览器后，开发者可以根据需求进行页面内容的修改。</p>
<h2 id="考点11：Ajax与跨域"><a href="#考点11：Ajax与跨域" class="headerlink" title="考点11：Ajax与跨域"></a>考点11：Ajax与跨域</h2><h4 id="面试题：原生-js-ajax-请求有哪5个步骤？分别是什么？"><a href="#面试题：原生-js-ajax-请求有哪5个步骤？分别是什么？" class="headerlink" title="面试题：原生 js ajax 请求有哪5个步骤？分别是什么？"></a>面试题：原生 js ajax 请求有哪5个步骤？分别是什么？</h4><p>分为5个步骤：</p>
<p><strong>Step1：</strong>创建 XMLHttpRequest 对象， 使用 xhr 对象发送 ajax 请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br></pre></td></tr></table></figure>
<p><strong>Step2：</strong>规定请求的类型、URL 以及是否异步处理请求。</p>
<p>xhr.open(‘请求方式’, ‘请求地址’, 是否异步)</p>
<ul>
<li>请求的方式有：get / post / put</li>
<li>请求地址：本次请求的 url</li>
<li>是否异步：本次请求是否异步，默认 true 表示异步，false 表示同步</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:3000/users?username=kaikai&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Step3：</strong>发送信息至服务器时内容编码类型 （get不需要）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span> 或者 <span class="string">&quot;application/json&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Step4</strong>：使用 xhr 对象中的 send 方法来发送请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.send()</span><br><span class="line"><span class="comment">//（）中有没有参数 根据 请求来判断</span></span><br></pre></td></tr></table></figure>
<p><strong>在此时，我们（客户端）已经将请求发送给服务端了，如果服务端正常的话，就会响应东西给客户端</strong>。</p>
<p>但是要想成功的拿到响应，必须有两个条件</p>
<ul>
<li>本次 HTTP 请求是成功的，也就是 Http 状态码 （<code>xhr.status</code>）为 200 ~ 299</li>
<li>ajax 对象 xhr 也有自己的状态码（readyState），用来表示本次 ajax 请求中各个阶段</li>
</ul>
<p><strong>Step5：</strong>验证 Http状态码 和 ajax对象 xhr 状态码，接受服务器响应数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次 readyState 改变的时候都会触发该事件</span></span><br><span class="line">    <span class="comment">// 我们就在这里判断 readyState 的值是不是到 4</span></span><br><span class="line">    <span class="comment">// 并且 http 的状态码是不是 200 ~ 299</span></span><br><span class="line">    <span class="built_in">console</span>.log(xhr.readyState)</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2&#125;$/</span>.test(xhr.status)) &#123;</span><br><span class="line">        <span class="comment">// 这里表示验证通过</span></span><br><span class="line">        <span class="comment">// 我们就可以获取服务端给我们响应的内容了</span></span><br><span class="line">        <span class="comment">// responseText 返回请求响应体内容</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 xhr.onload 使用该方法，其指挥监听道 ajax状态码为 4 的时候才会有效。</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/^2\d&#123;2&#125;$/</span>.test(xhr.status))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="面试题：ajax中-xhr的-readyState有哪几种状态，分别什么含义？"><a href="#面试题：ajax中-xhr的-readyState有哪几种状态，分别什么含义？" class="headerlink" title="面试题：ajax中 xhr的 readyState有哪几种状态，分别什么含义？"></a>面试题：ajax中 xhr的 readyState有哪几种状态，分别什么含义？</h4><p>ajax 状态码 - <code>xhr.readyState</code>   是用来表示一个 ajax 请求的全部过程中的某一个状态</p>
<ul>
<li>当状态码 为 0 时，表示未初始化完成，也就是 <code>open</code> 方法还没有执行</li>
<li>当状态码 为 1 时，表示配置信息已经完成，也就是执行完 <code>open</code> 之后，还未调用send方法</li>
<li>当状态码 为 2 时，表示 <code>send</code> 方法已经执行完成，还没接收到响应</li>
<li>当状态码 为 3 时，表示正在解析响应内容，开始接受到部分数据</li>
<li>当状态码 为 4 时，表示响应内容已经解析完毕，可以在客户端使用了</li>
</ul>
<h4 id="面试题：-ajax-请求的-5种类型"><a href="#面试题：-ajax-请求的-5种类型" class="headerlink" title="面试题： ajax 请求的 5种类型"></a>面试题： ajax 请求的 5种类型</h4><ul>
<li>get  偏向获取数据  常用</li>
<li>post  偏向提交数据  常用</li>
<li>put  偏向更新（全部）   </li>
<li>delete  偏向删除信息</li>
<li>patch 偏向部分修改</li>
</ul>
<h4 id="面试题：-ajax-的封装"><a href="#面试题：-ajax-的封装" class="headerlink" title="面试题： ajax 的封装"></a>面试题： ajax 的封装</h4><p>需要将 原生 js 里的步骤全部封装到文件中，并暴露一个 ajax 方法进行使用</p>
<p>封装代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment"> * @公众号: 大前端私房菜</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        str += <span class="string">`<span class="subst">$&#123;k&#125;</span>=<span class="subst">$&#123;obj[k]&#125;</span>&amp;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//username=kerwin&amp;password=789&amp;</span></span><br><span class="line">    <span class="keyword">return</span> str.slice(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装 ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> defaultoptions = &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">async</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123; url, method, <span class="keyword">async</span>, data, headers, success, error &#125; = &#123;</span><br><span class="line">        ...defaultoptions,</span><br><span class="line">        ...options</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(url, method, async, data, headers, success, error)</span></span><br><span class="line">    <span class="comment">// 这个问号的意思是  ? 如果前面取不到就 返回undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp; headers[<span class="string">&quot;content-type&quot;</span>]?.indexOf(<span class="string">&quot;json&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        data = queryStringify(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 如果是 get 请求, 并且有参数, 那么直接组装一下 url 信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^get$/i</span>.test(method) &amp;&amp; data) url += <span class="string">&#x27;?&#x27;</span> + data</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 4. 发送请求</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(method, url, <span class="keyword">async</span>)</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/^2\d&#123;2&#125;$/</span>.test(xhr.status)) &#123;</span><br><span class="line">            <span class="comment">// console.log(error)</span></span><br><span class="line">            error(<span class="string">`错误状态码:<span class="subst">$&#123;xhr.status&#125;</span>`</span>) <span class="comment">//回调</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行解析</span></span><br><span class="line">        <span class="comment">// try catch 是防止你返回来的不是 json 格式导致报错</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">            success(result)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            error(<span class="string">&#x27;解析失败 ! 因为后端返回的结果不是 json 格式字符串&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log(22222)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求头内表示传递的参数格式 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> headers)</span><br><span class="line">        xhr.setRequestHeader(k, headers[k])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是 GET 就直接发送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^get$/i</span>.test(method)) &#123;</span><br><span class="line">        xhr.send()</span><br><span class="line">        <span class="comment">// 否则需要传入data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr.send(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ajax</span><br></pre></td></tr></table></figure>
<p><strong>调用 ajax 方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/users&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&quot;kerwin3333&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&quot;789&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">headers</span>:&#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;sucess&quot;</span>,res)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>url: 是服务器的地址，Get和Post是不需要引入参数的   其他需要定位的需要引入参数 如id号</li>
<li>method：传入的请求方法 </li>
<li>data:用来定义传入的数据，一定要是 obj格式的</li>
<li>headers: 也就是我们data输入的是什么形式的   就两种  我们一般采取第二种，后面看成JSON处理即可，第一种的话，后面会用字符串的形式，拼成可以使用的obj类型<ul>
<li><code>&quot;content-type&quot;:&quot;application/x-www-form-urlencoded&quot;</code></li>
<li><code>&quot;content-type&quot;:&quot;application/json&quot;</code></li>
</ul>
</li>
<li>success：成功返回的内容 res ，对其进行操作</li>
<li>error： 失败返回的内容 err，对其进行操作</li>
</ul>
<h4 id="面试题：跨域产生的原因？"><a href="#面试题：跨域产生的原因？" class="headerlink" title="面试题：跨域产生的原因？"></a>面试题：跨域产生的原因？</h4><p>同源策略限制，不同源会造成跨域。以下任意一种情况不同，都是不同源。</p>
<p><strong>同源：1. 协议；2.域名；3.端口号三者要求全部相同，只要有一个不相同就是非同源策略。</strong></p>
<h4 id="面试题：跨域解决方案有哪些？"><a href="#面试题：跨域解决方案有哪些？" class="headerlink" title="面试题：跨域解决方案有哪些？"></a>面试题：跨域解决方案有哪些？</h4><ul>
<li><p>cors 由后端设置 <strong>Access-Control-Allow-Origin</strong>   <strong>设置为* 则表示所有域名可控制。</strong></p>
<font color="red">但是此方法需要后端进行配合。</font>

<p>例如数据是用json-server 搭建在 3000端口号上的，但是 preview on browser 是在 8080 端口上，这明显是个跨域访问的问题。</p>
<p>json-server 在 response headers 中 可以传递给8080端口 <code>http://localhost:8080</code></p>
<blockquote>
<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
</blockquote>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ截图20221130144553.png" style="zoom:67%;" /></p>
</li>
<li><p>jsonp  前后端交互实现 （因为前后端都要干 所以不常用  而且其只能解决 get 请求，其他不行，<font color="red"><strong>但是面试很喜欢考这个</strong></font>）</p>
<p>jsonp 原理：<strong>动态创建script标签，因为其src属性指向没有跨域限制</strong>，其指向一个接口，接口返回的格式一定是 某某方法名（）函数表达式。</p>
<p>所有的 src 属性和 href 属性都不受同源策略限制。可以请求第三方服务器数据内容。</p>
<p><strong>jsonp 的缺点</strong></p>
<ol>
<li><p>后端接口形式必须是  <strong>某某名字（），需要后端进行配合</strong></p>
<p>这个是可以改的，一般键叫做cb，我后面的函数某某名字 可以根据前端写的进行修改</p>
<p>例如百度联想提供的搜索引擎：&amp;cb=test&amp;_=1669794337686，test为前端写的方法，cb是后端暴露的接口</p>
</li>
<li><p>会一直动态叠加相同的script标签，所以在onload时删除script标签</p>
</li>
<li><p>只能进行 get 请求，不能post put patch 和 delete。</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;mybtn&quot;</span>&gt;</span>jsonp<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(obj)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        mybtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> oscript = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 配置script结点的src属性</span></span></span><br><span class="line"><span class="javascript">            oscript.src = <span class="string">&quot;01.txt&quot;</span> <span class="comment">// 未来地址 可以是 txt文本 也可以是 服务器地址</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(oscript)</span></span><br><span class="line"><span class="javascript">            oscript.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//删除当前结点</span></span></span><br><span class="line"><span class="javascript">                oscript.remove()</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反向代理</strong>   比如常见的 nginx反向代理，Vue 中的 vue-cli 脚手架配置的反向代理等。</p>
<p>其实现的原理为：</p>
<p><img src="https://gitee.com/kaikai-superman/imgs/raw/master/img/384df09d184a4d4eb576ff000a433413.png" style="zoom: 67%;" /></p>
<p>​     反向代理的 协议，服务器地址和端口与  客户端保持一致， 客户端 通过 ajax 将请求发给 代理服务器（因为同源所以成功）; 代理服务器将请求再发给 真正的服务端 ，然后获取数据再 response给 客户端</p>
<font color="red">**为什么 代理服务器和 服务端 不同源也可以？**</font>

<p>因为他压根用的不是 ajax，只有前端采用这个，其使用普通 http 协议就可以通信了！</p>
</li>
</ul>
<h2 id="考点12：ES6-一般指-ES6-ES13-篇"><a href="#考点12：ES6-一般指-ES6-ES13-篇" class="headerlink" title="考点12：ES6 (一般指 ES6- ES13)篇"></a>考点12：ES6 (一般指 ES6- ES13)篇</h2><h3 id="面试题：ES6的新特性有哪些？"><a href="#面试题：ES6的新特性有哪些？" class="headerlink" title="面试题：ES6的新特性有哪些？"></a>面试题：ES6的新特性有哪些？</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7087403522806775815">https://juejin.cn/post/7087403522806775815</a></p>
<ul>
<li><p>引入了 class 类，让js面向对象的变成更易于理解。<strong>ES6的class不是新的对象继承模型，它只是原型链的语法糖表现形式。</strong></p>
</li>
<li><p>ES6中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。</p>
</li>
<li><p>箭头函数</p>
<p><find>不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。&lt;/font&gt;</p>
</li>
<li><p>函数参数默认值</p>
</li>
<li><p>模板字符串</p>
</li>
<li><p><strong>解构赋值 （数组 对象均使用）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//不使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, numbers));</span><br><span class="line"><span class="comment">//使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...numbers));<span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>例如：用于构造数组/对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stuendts = [<span class="string">&#x27;Jine&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>]; </span><br><span class="line"><span class="keyword">const</span> persons = [<span class="string">&#x27;Tony&#x27;</span>,... stuendts,<span class="string">&#x27;Aaron&#x27;</span>,<span class="string">&#x27;Anna&#x27;</span>];</span><br><span class="line">conslog.log(persions)<span class="comment">// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]</span></span><br></pre></td></tr></table></figure>
<p>数组/对象拷贝和连接多个数组/对象</p>
<font color="red">**注意：拷贝都是浅拷贝**</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// 等同于 arr.slice()</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="built_in">Object</span>.assign(arr)  <span class="comment">// 与上面一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];<span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.concat(arr2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象属性简写  </p>
<p>例如再 obj 中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">	<span class="attr">name</span>:name,</span><br><span class="line">	<span class="attr">age</span>:age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为键和值(变量)相同，所以可以简写</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">	name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise  异步编程串行化 解决回调地狱</p>
</li>
<li><p>let 和 const 出现  他们与 var 的区别主要在于 其<strong>具有块级作用域</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br><span class="line">——————————————————————————————————————————————————————————————————</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//-1 or Error“ReferenceError: a is not defined”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题：ES7-有哪些新特性？"><a href="#面试题：ES7-有哪些新特性？" class="headerlink" title="面试题：ES7 有哪些新特性？"></a>面试题：ES7 有哪些新特性？</h3><ul>
<li>数组<code>includes()</code>方法 【Array.prototype.includes()】，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。</li>
<li>a ** b指数运算符，它与 Math.pow(a, b)相同。</li>
</ul>
<h3 id="面试题：ES8-有哪些新特性？"><a href="#面试题：ES8-有哪些新特性？" class="headerlink" title="面试题：ES8 有哪些新特性？"></a>面试题：ES8 有哪些新特性？</h3><ul>
<li><p><font  color="red"><strong>async/await</strong></font>    <strong>非常重要</strong></p>
</li>
<li><p>```javascript<br>// 直接获取对象属性<br>Object.values()<br>// 可以迭代遍历 对象键+值了<br>for(let [key,value] of Object.entries(obj1))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- String padding: `padStart()`和`padEnd()`，填充字符串达到当前长度</span><br><span class="line"></span><br><span class="line">- 函数参数列表结尾允许逗号</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</span><br><span class="line">  Object.getOwnPropertyDescriptors()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ShareArrayBuffer</code>和<code>Atomics</code>对象，用于从共享内存位置读取和写入。 这个忽略不看，我觉得不重要。</p>
</li>
</ul>
<h3 id="面试题：ES9-有哪些新特性？"><a href="#面试题：ES9-有哪些新特性？" class="headerlink" title="面试题：ES9 有哪些新特性？"></a>面试题：ES9 有哪些新特性？</h3><ul>
<li><p>异步迭代</p>
</li>
<li><font color="red">**Promise.finally()**</font>

<p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p><code>.finally()</code>允许你指定最终的逻辑：</p>
</li>
<li><p><strong>Rest/Spread 属性</strong></p>
<p>Rest参数语法允许我们将<strong>一个不定数量的参数表示为一个数组/对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// P3 会接剩下的部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 = 1</span></span><br><span class="line">  <span class="comment">// p2 = 2</span></span><br><span class="line">  <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面试题：ES10-有哪些新特性？"><a href="#面试题：ES10-有哪些新特性？" class="headerlink" title="面试题：ES10 有哪些新特性？"></a>面试题：ES10 有哪些新特性？</h3><ul>
<li><p><font color="blue">新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</font>  <code>flat()</code>和<code>flatMap()</code>本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<p>flat() 方法主要是用于 <strong>数组降维</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>
<p>其次，还可以利用<code>flat()</code>方法的特性来去除数组的空项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat();</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>flatMap() 暂时没看到非常有用的用处，应该不考</p>
</li>
<li><font color="blue">String 的去除前后空白字符   String的`trimStart()`方法和`trimEnd()`方法</font>



</li>
</ul>
<h2 id="考点13：Js的五种模块化的方式有哪些？有什么区别？"><a href="#考点13：Js的五种模块化的方式有哪些？有什么区别？" class="headerlink" title="考点13：Js的五种模块化的方式有哪些？有什么区别？"></a>考点13：Js的五种模块化的方式有哪些？有什么区别？</h2><ul>
<li>AMD (异步模块定义)和 CMD （公共模块定义）都是<strong>浏览器端</strong>的JS模块化规范，分别由require.js和sea.js实现</li>
<li>CommonJS（缩写：CJS ）是<strong>服务器端</strong>的js模块化规范，<strong>由NodeJS实现</strong>  模块输出，modules.exports，模块加载require()引入模块。  </li>
<li>ES6 提出的方案（ESM），使用 import 和 export 的形式来导入导出模块，在nodeJS新版本中可以直接使用。</li>
<li>另外还有一些独特的例如  <strong>UMD</strong> （通用模块定义）他是 AMD 和 Common JS 糅合的产物。</li>
</ul>
<h2 id="考点14：基于ajax-更新的异步通信的方式有哪些"><a href="#考点14：基于ajax-更新的异步通信的方式有哪些" class="headerlink" title="考点14：基于ajax 更新的异步通信的方式有哪些"></a>考点14：基于ajax 更新的异步通信的方式有哪些</h2><p>ajax存在的问题就是   <font color="blue">比如使用Ajax 对某个数据的获取，需要先访问上一个数据拿到对应的索引再获取。这样重复，就会导致可读性非常的差，而且不好维护，因为嵌套的过于难看，不清晰。</font> 产生回调地狱，代码横向生长了。</p>
<h3 id="面试题：谈一下对Promise的理解"><a href="#面试题：谈一下对Promise的理解" class="headerlink" title="面试题：谈一下对Promise的理解"></a>面试题：谈一下对Promise的理解</h3><p>promise 的目的是为了解决ajax的回调地狱问题，将原来的嵌套访问，变成了链式访问。是一个成熟方案。</p>
<p>其基础语法定义为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// resolve 表示成功的回调</span></span><br><span class="line">  <span class="comment">// reject 表示失败的回调</span></span><br><span class="line">    这里面一定要调用 resolve/reject 才能跳转到对应的 then 或者 err中</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;成功&quot;</span>,res)</span><br><span class="line">  <span class="comment">// 成功的函数</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;失败&quot;</span>,err)</span><br><span class="line">  <span class="comment">// 失败的函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>每一个异步事件的执行，都有三种状态 <font color="red"><strong>执行中（pending） / 成功（fulfilled） / 失败（Rejected）</strong></font></p>
<p><code>Promise</code>对象的状态改变，只有两种可能：从<code>Pending</code>变为<code>fulfilled</code>和从<code>Pending</code>变为<code>Rejected</code>。</p>
<p><strong>总结</strong></p>
<p>是用来解决回调地域的，其解决回调地域的思想就是promise构造函数生成promise对象之后，就会处于执行中（pending）这个状态。如果在异步结束成功了，这个对象就会调用resolve回调，也就是到了成功（fulfilled）状态，就会调用then里面的内容执行成功的函数，反之就会调用reject回调 进入失败（reject）状态 在catch中执行失败函数。</p>
<p><strong>封装 Promise 再 ajax 后</strong></p>
<p>如何封装看下面：比如封装成 <code>pajax</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pajax</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是封装的 ajax</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">            ...options,</span><br><span class="line">            <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套变成链式调用  == 每次成功就return一个 pajax回去  我们总体最后返回一个错误catch即可</span></span><br><span class="line">pajax(&#123;</span><br><span class="line">    <span class="comment">// options 传入</span></span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/news&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">author</span>:<span class="string">&quot;tiechui&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 源码执行了 success</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/comments&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">newsId</span>: res[<span class="number">0</span>].id,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>, res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="面试题：谈一下对-Promise-all-的理解"><a href="#面试题：谈一下对-Promise-all-的理解" class="headerlink" title="面试题：谈一下对 Promise.all 的理解"></a>面试题：谈一下对 Promise.all 的理解</h3><p>请求如果顺序写，并不能实现并行的效果。因为请求一定是先后请求服务器，获取结果有时间差。</p>
<p>为了展示出并行的效果，我们使用 Promise.all 方法，其可以使得引入的 请求列表，在所有请求的完成之后，then返回一个整体的结果，如果出错则在catch中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 Promise.all 来将两个 promise封装的ajax请求同步获取最后结果</span></span><br><span class="line"><span class="keyword">let</span> q1 = pajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/looplist&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> q2 = pajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/datalist&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 为了不是分别加载，所以这里要两个q1和q2 ajax请求全部到位（模拟出并发），res中得到两个请求返回 整合在一起了</span></span><br><span class="line"><span class="built_in">Promise</span>.all([q1,q2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;隐藏加载中&quot;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="面试题：如何理解-aync-await？"><a href="#面试题：如何理解-aync-await？" class="headerlink" title="面试题：如何理解 aync/await？"></a>面试题：如何理解 aync/await？</h3><p>使用 <code>Promise</code> 能很好地解决回调地狱的问题，但是这种方式充满了 <code>Promise</code> 的 <code>then()</code> 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 <code>then</code>，语义化不明显，代码不能很好地表示执行流程。</p>
<p>基于这个原因，ES7 引入了 <code>async</code>/<code>await</code>，这是 JavaScript 异步编程的一个重大改进，提供了 <strong>在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力</strong>，并且使得代码逻辑更加清晰。<font color="red">也就是 我可以直接顺序写。</font></p>
<font color="red">ASYNC 和 AWAIT 需要配合使用 的**封装后的 promise对象**</font>

<p>语法格式为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// await 用于同步代码 或者 promise对象（因为其为异步）</span></span><br><span class="line">    <span class="keyword">await</span> pajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/list&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">value</span>:<span class="string">&quot;凯凯超人&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).then( <span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求成功&quot;</span>,res)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请求失败&quot;</span>,err)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面才是 真正的 async/await 使用的方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// await 用于同步代码 或者 promise对象（因为其为异步）</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> pajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/news&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">author</span>:<span class="string">&quot;tiechui&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> res1 = pajax(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/comments&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">newsId</span>: res[<span class="number">0</span>].id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;成功获取&quot;</span>,res)</span><br><span class="line">&#125;).catch( <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取失败&quot;</span>,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/QQ截图20221127200934.png" alt=""></p>
<h3 id="面试题：如何理解-xhr-和-fetch-的区别？"><a href="#面试题：如何理解-xhr-和-fetch-的区别？" class="headerlink" title="面试题：如何理解  xhr 和 fetch 的区别？"></a>面试题：如何理解  xhr 和 fetch 的区别？</h3><p><code>XMLHttpRequest</code> 是一个设计粗糙的 API，配置和调用方式非常混乱， 而且基于事件的异步模型写起来不友好。其含有多步骤，主要分为三步  （按照传输方式，细节有所不同，查看 <strong>ajax获取数据方式章节</strong>）</p>
<ul>
<li>创建一个 ajax 对象</li>
<li>配置链接信息</li>
<li>发送请求</li>
</ul>
<p>fetch 是用来后续替代 xhr 的，但是目前能支持fetch的浏览器版本比较高，所以现在常用的还是 xhr。</p>
<font color="red">**fetch实际上是基于Promise做的操作**。</font>

<p>fetch 比 xhr 相对便捷的地方在于，<strong>其不需要引入一个 util.js 专门封装 xhr 实现 ajax 的文件</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch 返回的 res 是个结构体，里面包含很多信息，包括是否成功，以及错误类型和返回数据等等</span></span><br><span class="line">myget.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这个返回的是一个promise对象 pending状态 状态如果成功就是 fulfilled态，此时结果是个 ResPonse结构体，里面包含很多信息</span></span><br><span class="line">    fetch(<span class="string">&quot;http://localhost:3000/users&quot;</span>)    </span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.ok)</span><br><span class="line">            <span class="keyword">return</span> res.json()  <span class="comment">// res.text() 是获取字符格式的 obj   res.join() 会自动解析成obj  这里相当于成功回调resolve 走then</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 这里使用了一个 Promise 拒绝回调相当于之前的 reject 会去执行下面的 catch （这里有个特点 如果不写的话，他默认会走then的 无论你是不是返回成功，一定要拒绝才可以）</span></span><br><span class="line">            <span class="comment">// 同样也有 Promise.resolve() 同意回调 但这里用不到，这里要拒绝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span><br><span class="line">                <span class="attr">status</span>:res.status,</span><br><span class="line">                <span class="attr">statusText</span>:res.statusText</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)  <span class="comment">// 这个返回的是一个promise对象 处于pending状态 状态转换看是否成功 分别指向下面两处</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;   <span class="comment">// 这里相当于成功返回之后要干嘛 我拿到了返回的数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;成功获取&quot;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;  <span class="comment">// 正常是打印 失败的信息手动在前面的拒绝中返回 我们需要的东西</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;获取失败&quot;</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="考点15：JS的事件循环（事件队列）-（宏任务和微任务）"><a href="#考点15：JS的事件循环（事件队列）-（宏任务和微任务）" class="headerlink" title="考点15：JS的事件循环（事件队列） （宏任务和微任务）"></a>考点15：JS的事件循环（事件队列） （宏任务和微任务）</h2><h3 id="面试题：JS的-同步任务与异步任务-起因？"><a href="#面试题：JS的-同步任务与异步任务-起因？" class="headerlink" title="面试题：JS的 同步任务与异步任务 起因？"></a>面试题：JS的 同步任务与异步任务 起因？</h3><p>JS是一门单线程语言，单线程就意味着，所有的任务需要排队，前一个任务结束，才会执行下一个任务。</p>
<p>这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</p>
<p>为了解决这个问题，JS中出现了同步和异步。他们的本质区别是：一条流水线上各个流程的执行顺序不同。在讲JS任务执行机制前，先要了解一下什么是同步任务与异步任务。</p>
<ul>
<li><strong>同步任务：</strong>即主线程上的任务，按照顺序由上⾄下依次执⾏，当前⼀个任务执⾏完毕后，才能执⾏下⼀个任务。</li>
<li><strong>异步任务：</strong>不进⼊主线程，⽽是进⼊任务队列的任务，执行完毕之后会产生一个回调函数,并且通知主线程。当主线程上的任务执行完后，就会调取最早通知自己的回调函数，使其进入主线程中执行。</li>
</ul>
<h3 id="面试题：什么是-JS的事件循环（loop-或队列），宏任务和微任务的定义？-loop具体的执行机制描述？"><a href="#面试题：什么是-JS的事件循环（loop-或队列），宏任务和微任务的定义？-loop具体的执行机制描述？" class="headerlink" title="面试题：什么是 JS的事件循环（loop 或队列），宏任务和微任务的定义？ loop具体的执行机制描述？"></a>面试题：什么是 JS的事件循环（loop 或队列），宏任务和微任务的定义？ loop具体的执行机制描述？</h3><p>事件循环指的是<font color="blue"><strong>js代码所在运行环境（浏览器、nodejs）编译器的一种解析执行规则</strong></font>。事件循环不属于js代码本身的范畴，而是属于<strong>js编译器的范畴</strong>，在js中讨论事件循环是没有意义的。</p>
<p>换句话说，js代码可以理解为是一个人在公司中具体做的事情， 而 事件循环 相当于是公司的一种规章制度。 两者不是一个层面的概念。</p>
<h4 id="微任务、宏任务"><a href="#微任务、宏任务" class="headerlink" title="微任务、宏任务"></a>微任务、宏任务</h4><ol>
<li><p>微任务与宏任务就属于js代码的范畴</p>
</li>
<li><p>js代码主要分为两大类： 同步代码、异步代码</p>
<font color="red">**注意：Promise 和 async/await 是同步代码，await XXX    XXX是同步代码**</font>
</li>
<li><p><strong>异步代码又分为：微任务与宏任务</strong></p>
<font color="red">**Promise的 .then是一个微任务， await 下一行及其之后的代码也是微任务。**</font>

</li>
</ol>
<p>宏任务包括：</p>
<ul>
<li><p><strong>setTimeout 和 setInterval</strong>， I/O文件读取 例如 fs.readFile()， 事件</p>
</li>
<li><p>postMessage</p>
</li>
<li><p>setImmediate (node中的特性，浏览器已经废弃该API)</p>
</li>
<li><p>requestAnimationFrame() 请求动画帧</p>
<p>他的作用就是代替定时器做更加<strong>流畅高性能</strong>的动画，做可以匹配设备刷新率的动画，他解决了<strong>定时器做动画时间间隔不稳定的问题</strong>（也就是解决定时器做动画不流畅的问题）。他的用法与setTimeout差不多。</p>
</li>
<li><p>UI渲染</p>
</li>
<li><p>ajax</p>
</li>
</ul>
<p>微任务包括：</p>
<ul>
<li>Promise.then  catch finally</li>
<li>async/await</li>
<li>MutationObserver（chrome种 node无）</li>
<li>process.nextTick (node中)</li>
</ul>
<h4 id="事件循环Event-Loop执行机制"><a href="#事件循环Event-Loop执行机制" class="headerlink" title="事件循环Event Loop执行机制"></a>事件循环Event Loop执行机制</h4><p>1.进入到script标签,就进入到了第一次事件循环.</p>
<p>2.遇到同步代码，立即执行，然后继续读</p>
<p>3.如果遇到宏任务,放入到宏任务队列里，跳过宏任务的代码，继续顺序读同步的</p>
<p>4.如果遇到微任务,放入到微任务队列里，也跳过微任务的代码，继续顺序读同步的</p>
<p>5.程序到最后了，所有同步代码都执行完毕</p>
<p>6.这个时候我们开始读取微任务队列，采取先进先出的原则，执行第一个先存入的微任务代码。 执行过程同样是一次 先同步，碰到宏任务进宏任务队列，微任务进微任务队列的做法。</p>
<p>7.微任务队列中，所有微任务代码执行完毕，本次队列清空</p>
<p>8.这个时候开始执行 宏任务队列中的任务，同样先执行第一个先存入的宏任务，执行过程同样是一次 先同步，碰到宏任务进宏任务队列，微任务进微任务队列的做法。</p>
<p>直到所有同步，微任务，宏任务全部完事，叫执行完毕。</p>
<p>面试中经常碰到题目：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a2699ee99c456186b774afecd78a4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>解答：</p>
<font color="blue">promise本身是一个同步的代码(只是容器)，只有它后面调用的then()方法里面的回调才是微任务。</font>

<p>所以先顺序执行同步代码，发现有个 Promise是个同步代码，所以先执行。执行发现里面有个同步代码 打印777，所以先打印777，然后顺序同步执行resolve()，发现微任务 Promise.then。将.then对于的回调函数存入 微任务队列。然后我再顺序执行同步代码，发现999，打印999。这个时候发现我们已经读到最后了，这个时候去找微任务队列，发现不为空，取出第一个（也是唯一一个），顺序执行里面的代码，发现同步代码 打印888，所以我们打印888，然后代码结束。微任务队列中没有其他微任务了，然后看宏任务队列，发现也是空的。所以程序彻底结束。</p>
<p><strong>正确答案：  7777  9999  8888</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9beb8dd124454046b53f74a472717b5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<font color="blue">await右边的表达式还是会立即执行,表达式之后的代码才是微任务, await微任务可以转换成等价的promise微任务分析</font>

<p>顺序执行同步代码，发现打印1，所以打印了1。然后顺序发现 async 方法 async1() (<strong>中间一堆需要被调用才会执行奥，别搞错我说的是最后一行那个调用的</strong>)，其await 紧跟的方法是同步代码会立即执行，所以跳转到 async2方法，其也是一个 async方法，顺序同步执行，里面的函数内容同样是顺序执行，打印3。然后 async2 方法执行结束，其后面的部分代码全被定义为 微任务，所以整个存入 微任务队列。 这个时候发现已经到底了，所以我们去查看微任务队列，发现里面有，拿出第一个，然后顺序同步执行里面的代码，发现只有 打印2，所以打印2之后。发现微任务队列和宏任务队列全部为空，所以程序结束。</p>
<p><strong>正确答案： 1 3 2</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27f658ad77f146608950bccebe7dff97~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<font color="blue">script标签本身是一个`宏任务`， 当页面出现多个script标签的时候，浏览器会把script标签作为宏任务来解析</font>

<p>我们也是顺序读同步代码，发现第一个script标签，是个宏任务，所以存入宏任务队列，然后跳过整个宏任务代码，我们继续读同步代码。又发现一个  script标签，也是一个宏任务，我继续存入宏任务队列。这个时候我们的程序到底了，所以我们先去看微任务队列，发现为空。所以我们再去找宏任务队列，发现不为空，取出第一个，即第一次存入的script标签，然后顺序执行里面的同步代码，发现同步代码打印1，然后又看到一个宏任务 setTimeOut 将这个宏任务也存入宏任务队列。这个时候这个宏任务执行完毕，开始下一个宏任务，顺序执行打印出3，然后再下一个宏任务也就是刚才存入的 setTimeOut，顺序执行里面的函数，执行同步代码 打印2。此时发现微任务队列和宏任务队列全部为空，所以程序结束。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4860b43cd48d42028f3c6a7adf1f1a0a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>正确答案：1 4 6 2 5 3</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a09ff1dcda4e44858fd3416bff1d0283~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>正确答案：1 5 7 6 2 3 4</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72d83f696a654b7994616e0d2137ea13~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>注意连续的两次 .then 上一个.then执行完毕之后，才会继续顺序读后面，后面这个then相当于第一个 then 的内容。</p>
<p>正确答案：1 4 7 2 5 8 3 9 6</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dbddbe92d96489a86242d5b66f0bb96~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>正确答案：</p>
<p><strong>必须 resolve 顺序执行之后，才会调用 .then方法，才会将 then 放入微任务。</strong></p>
<p>1 2 4 3 7 6 9 5 8 </p>
<h2 id="考点16：JS-面试代码题目"><a href="#考点16：JS-面试代码题目" class="headerlink" title="考点16：JS 面试代码题目"></a>考点16：JS 面试代码题目</h2><h3 id="面试题：js中两个数组怎么取交集-差集、并集、补集"><a href="#面试题：js中两个数组怎么取交集-差集、并集、补集" class="headerlink" title="面试题：js中两个数组怎么取交集+(差集、并集、补集)"></a>面试题：js中两个数组怎么取交集+(差集、并集、补集)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个数组去重</span></span><br><span class="line"><span class="keyword">var</span> sa = <span class="keyword">new</span> <span class="built_in">Set</span>(a);</span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> <span class="built_in">Set</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="comment">// a 当中过滤出 sb 中有的数</span></span><br><span class="line"><span class="keyword">let</span> intersect = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> sb.has(x));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;交集为：&quot;</span>, intersect)  <span class="comment">// [ 2, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> unionSet = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;并集为：&quot;</span>, unionSet) <span class="comment">//  [1, 2, 3,  4, 5, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="comment">// a 当中过滤出 sb 中没有的数</span></span><br><span class="line"><span class="keyword">let</span> minus = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> !sb.has(x));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;差集为：&quot;</span>, minus)  <span class="comment">// [ 1, 3, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补集  （就是 并集 - 交集）</span></span><br><span class="line"><span class="comment">// a 当中过滤出 sb 中没有的数  b 当中过滤出 sa 中没有的数 </span></span><br><span class="line"><span class="keyword">let</span> complement  = [...a.filter(<span class="function"><span class="params">x</span> =&gt;</span> !sb.has(x)), ...b.filter(<span class="function"><span class="params">x</span> =&gt;</span> !sa.has(x))];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;补集为：&quot;</span>, complement)  <span class="comment">// [ 1, 3, 5, 6, 8, 10 ]</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：用正则和非正则实现123456789-12-》123-456-789-12"><a href="#面试题：用正则和非正则实现123456789-12-》123-456-789-12" class="headerlink" title="面试题：用正则和非正则实现123456789.12=》123,456,789.12"></a>面试题：用正则和非正则实现123456789.12=》123,456,789.12</h3><ul>
<li>没有小数点，用专属的 API  <code>toLocaleString</code></li>
<li>否则用正则表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numFormat</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = (num.toString().indexOf (<span class="string">&#x27;.&#x27;</span>) !== -<span class="number">1</span>) ? num.toLocaleString() : </span><br><span class="line">             num.toString().replace(<span class="regexp">/(\d)(?=(?:\d&#123;3&#125;)+$)/g</span>, <span class="string">&#x27;$1,&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：-写一个判断是否是空对象的函数"><a href="#面试题：-写一个判断是否是空对象的函数" class="headerlink" title="面试题： 写一个判断是否是空对象的函数"></a>面试题： 写一个判断是否是空对象的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        value === <span class="literal">null</span> || value === <span class="literal">undefined</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">Object</span>.keys(value).length === <span class="number">0</span>) </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：颜色值16进制转10进制rgb"><a href="#面试题：颜色值16进制转10进制rgb" class="headerlink" title="面试题：颜色值16进制转10进制rgb"></a>面试题：颜色值16进制转10进制rgb</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toRGB</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regex = <span class="regexp">/^#([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)([0-9a-fA-F]&#123;2&#125;)$/</span> <span class="comment">//匹配十六进制的正则</span></span><br><span class="line">    match = color.match(regex)  <span class="comment">// 判断是否是十六进制颜色值</span></span><br><span class="line">    <span class="keyword">return</span> match ? <span class="string">&#x27;rgb(&#x27;</span>+<span class="built_in">parseInt</span>(match[<span class="number">1</span>], <span class="number">16</span>)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">parseInt</span>(match[<span class="number">2</span>], <span class="number">16</span>)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">parseInt</span>(match[<span class="number">3</span>], <span class="number">16</span>)+<span class="string">&#x27;)&#x27;</span> : color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：数组扁平化-常考"><a href="#面试题：数组扁平化-常考" class="headerlink" title="面试题：数组扁平化  常考"></a>面试题：数组扁平化  常考</h3><p><strong>方法1：最正常的想法 使用递归</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<p><strong>方法2：使用 reduce 函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<h3 id="面试题：实现一个数组对象的去重，相同value的只保留最后一个"><a href="#面试题：实现一个数组对象的去重，相同value的只保留最后一个" class="headerlink" title="面试题：实现一个数组对象的去重，相同value的只保留最后一个"></a>面试题：实现一个数组对象的去重，相同value的只保留最后一个</h3><p><strong>方法1：最佳肯定是使用 ES6 的 Set 方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique5</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">   <span class="keyword">return</span> [...x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的方法都是 ES5 的</p>
<p><strong>方法2：呆方法，遍历每个碰到没存过的存一下</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique5</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = []</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 或者 ES6 方法 temp.includes(element) 直接判断 True/False</span></span><br><span class="line">       <span class="keyword">if</span>(temp.indexOf(element) == -<span class="number">1</span>) </span><br><span class="line">            temp.push(element)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组"><a href="#面试题：function-rand-min-max-N-：生成长度是N，且在min、max内不重复的整数随机数组" class="headerlink" title="面试题：function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组"></a>面试题：function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组</h3><p>把考点拆成了4个小项；需要用递归算法实现：<br>a) 生成一个长度为n的空数组arr。<br>b) 生成一个（min－max）之间的随机整数rand。<br>c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到 arr内[需要使用递归实现，不能使用for/while等循环]<br>d) 最终输出一个长度为n，且内容不重复的数组arr。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildArray</span>(<span class="params">n, min, max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    dfsCreate(arr)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfsCreate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min</span><br><span class="line">        <span class="keyword">if</span> (!arr.includes(num)) </span><br><span class="line">            arr.push(num)</span><br><span class="line">        <span class="keyword">return</span> arr.length === n ? arr : dfsCreate(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：字符串中的单词逆序输出（手写）"><a href="#面试题：字符串中的单词逆序输出（手写）" class="headerlink" title="面试题：字符串中的单词逆序输出（手写）"></a>面试题：字符串中的单词逆序输出（手写）</h3><p><strong>方法1：快速法  推荐</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：傻逼呆逼法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=str.length;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    i=i-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = i; x &gt;=<span class="number">0</span>; x--) &#123; </span><br><span class="line">            result += str[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法3：高级一点使用 reduce 法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strReverse</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> next + prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度-（力扣）"><a href="#面试题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度-（力扣）" class="headerlink" title="面试题：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度   （力扣）"></a>面试题：<strong>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度</strong>   （力扣）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">while</span> (res.includes(letter)) &#123;</span><br><span class="line">      res.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(letter)</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max,res.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面试题：去掉字符串前后的空格"><a href="#面试题：去掉字符串前后的空格" class="headerlink" title="面试题：去掉字符串前后的空格"></a>面试题：去掉字符串前后的空格</h3><p>这个可以用 新的ES6  API <strong>trim</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;   hello world   &quot;</span>;</span><br><span class="line"><span class="keyword">const</span> trimmedStr = str.trim(); <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果遇到需要去掉 字符串内所有的空格，并且空格不定长度，可以使用正则表达式来做</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;  hello   world!  &quot;</span>;</span><br><span class="line"><span class="keyword">const</span> trimmedStr = str.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// &quot;helloworld!&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="面试题：三数之和-（力扣）"><a href="#面试题：三数之和-（力扣）" class="headerlink" title="面试题：三数之和  （力扣）"></a>面试题：三数之和  （力扣）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">let</span> length = nums.length</span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        nums.sort( <span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length ; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 二分法寻找</span></span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">let</span> right = length - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    result.push(<span class="keyword">new</span> <span class="built_in">Array</span>(nums[i], nums[left], nums[right]))</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) </span><br><span class="line">                        left++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) </span><br><span class="line">                        right--; <span class="comment">// 去重</span></span><br><span class="line">                    left ++;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明 左指针小了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) left ++;</span><br><span class="line">                <span class="comment">// 说明 右指针大了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) right --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">凯凯超人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/">http://example.com/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">一只柴犬</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/"><img class="prev-cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端性能优化</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/VuePurchase%E6%98%93%E8%B4%AD%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VuePurchase易购平台项目笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/23/前端 JS 选择题笔试/" title="前端 JS 选择题笔试"><img class="cover" src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">前端 JS 选择题笔试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/admin.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凯凯超人</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/×××" target="_blank" title="Gitee"><i class="iconfont gitee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E7%AF%87%EF%BC%88%E5%8C%85%E5%90%ABES6%EF%BC%89%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">JavaScript 篇（包含ES6）面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9-1%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">考点 1：数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AE%B2%E8%AE%B2JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">面试题：讲讲JS的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">面试题：基本数据类型 和 引用数据类型的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">引用数据类型(复杂数据类型)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">面试题：四种判断数据类型的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">instanceof  的实现原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">toString</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">面试题：强制类型转换和隐式类型转换是什么？举几个例子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajs-%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">面试题：js 中 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9-2%EF%BC%9A%E4%BC%A0%E5%80%BC-VS-%E4%BC%A0%E5%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">考点 2：传值 VS 传址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%9D%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">传址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9-3%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.</span> <span class="toc-text">考点 3：作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">面试题：谈谈你对 作用域链 的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9-4%EF%BC%9A%E9%97%AD%E5%8C%85"><span class="toc-number">1.4.</span> <span class="toc-text">考点 4：闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">面试题：什么是闭包？如何理解闭包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%97%AD%E5%8C%85%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">面试题：闭包的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-%EF%BC%88%E8%A6%81%E5%9B%9E%E5%86%99%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">闭包的应用： 函数柯里化 （要回写）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B9-5%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.</span> <span class="toc-text">考点 5：原型链和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">面试题： new 操作符的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%92%8C-%E5%AE%9E%E4%BE%8B%E7%9A%84-%E5%8E%9F%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">面试题：构造函数 和 实例的 原型关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES5%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">1.5.3.</span> <span class="toc-text">面试题：ES5的继承有哪几种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">构造函数继承（经典继承）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">组合式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES5-%E5%92%8C-ES6-%E6%98%AF%E5%A6%82%E4%BD%95%E6%98%AF%E5%AE%9E%E7%8E%B0-%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">面试题：ES5 和 ES6 是如何是实现 类继承的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES5-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">ES5 的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6-%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E-Java%E5%9F%BA%E6%9C%AC%E4%B8%80%E8%87%B4%EF%BC%88%E8%A6%81%E4%BC%9A%E5%86%99%EF%BC%89"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">ES6 的继承与 Java基本一致（要会写）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B96%EF%BC%9AMap-%E3%80%81-Set%E3%80%81weakSet-%E5%92%8C-weakMap"><span class="toc-number">1.6.</span> <span class="toc-text">考点6：Map 、 Set、weakSet 和 weakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Map-%E4%B8%8E-%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">面试题：如何理解 Map 与 普通对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AweakMap-%E5%92%8C-Map%EF%BC%8CweakSet-%E5%92%8C-Set-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">面试题：weakMap 和 Map，weakSet 和 Set 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B97%EF%BC%9AJS-%E4%B8%AD%E7%9A%84this"><span class="toc-number">1.7.</span> <span class="toc-text">考点7：JS 中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%9C%A8%E4%BA%94%E7%A7%8D%E6%83%85%E6%99%AF%E4%B8%8B%EF%BC%8Cthis%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E8%B0%81%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">面试题：在五种情景下，this指针指向谁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E6%88%96%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">在全局环境或是普通函数中直接调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">作为对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8apply%E5%92%8Ccall-%E4%BB%A5%E5%8F%8Abind"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">使用apply和call 以及bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">作为构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">箭头函数中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B98%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.8.</span> <span class="toc-text">考点8：浅拷贝和深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.8.1.</span> <span class="toc-text">面试题：如何理解深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%BB%A3%E7%A0%81-%EF%BC%88%E6%89%8B%E5%86%99%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">面试题：实现深拷贝代码 （手写）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B99%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">考点9：事件冒泡和事件捕获以及事件代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">面试题：事件冒泡、事件捕获的定义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-%E6%88%96%E8%80%85-%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">面试题：如何开启事件冒泡 或者 事件捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E4%BC%98%E5%8A%BF-%E5%8D%B3%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">面试题：如何理解 事件流的优势 即事件委托的优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E7%9A%84-%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.9.4.</span> <span class="toc-text">面试题：阻止事件冒泡的 方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-number">1.9.5.</span> <span class="toc-text">面试题：有哪些方法可以阻止默认行为？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dom0-onxxx%E6%96%B9%E5%BC%8F-%E7%9B%B4%E6%8E%A5-return-false"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">dom0 onxxx方式  直接 return false</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dom2addEventListener%E6%96%B9%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-preventDefault"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">dom2addEventListener方式   事件对象.preventDefault()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B910%EF%BC%9ABOM-%E4%B8%8E-DOM-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.10.</span> <span class="toc-text">考点10：BOM 与 DOM 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B911%EF%BC%9AAjax%E4%B8%8E%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.11.</span> <span class="toc-text">考点11：Ajax与跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8E%9F%E7%94%9F-js-ajax-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA5%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9F%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.0.1.</span> <span class="toc-text">面试题：原生 js ajax 请求有哪5个步骤？分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Aajax%E4%B8%AD-xhr%E7%9A%84-readyState%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-number">1.11.0.2.</span> <span class="toc-text">面试题：ajax中 xhr的 readyState有哪几种状态，分别什么含义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-ajax-%E8%AF%B7%E6%B1%82%E7%9A%84-5%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.11.0.3.</span> <span class="toc-text">面试题： ajax 请求的 5种类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-ajax-%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.11.0.4.</span> <span class="toc-text">面试题： ajax 的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B7%A8%E5%9F%9F%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.11.0.5.</span> <span class="toc-text">面试题：跨域产生的原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.11.0.6.</span> <span class="toc-text">面试题：跨域解决方案有哪些？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B912%EF%BC%9AES6-%E4%B8%80%E8%88%AC%E6%8C%87-ES6-ES13-%E7%AF%87"><span class="toc-number">1.12.</span> <span class="toc-text">考点12：ES6 (一般指 ES6- ES13)篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">面试题：ES6的新特性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES7-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.12.2.</span> <span class="toc-text">面试题：ES7 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES8-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.12.3.</span> <span class="toc-text">面试题：ES8 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES9-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.12.4.</span> <span class="toc-text">面试题：ES9 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AES10-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.12.5.</span> <span class="toc-text">面试题：ES10 有哪些新特性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B913%EF%BC%9AJs%E7%9A%84%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">考点13：Js的五种模块化的方式有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B914%EF%BC%9A%E5%9F%BA%E4%BA%8Eajax-%E6%9B%B4%E6%96%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.14.</span> <span class="toc-text">考点14：基于ajax 更新的异步通信的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.14.1.</span> <span class="toc-text">面试题：谈一下对Promise的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9-Promise-all-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.14.2.</span> <span class="toc-text">面试题：谈一下对 Promise.all 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-aync-await%EF%BC%9F"><span class="toc-number">1.14.3.</span> <span class="toc-text">面试题：如何理解 aync&#x2F;await？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-xhr-%E5%92%8C-fetch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.4.</span> <span class="toc-text">面试题：如何理解  xhr 和 fetch 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B915%EF%BC%9AJS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%EF%BC%89-%EF%BC%88%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">考点15：JS的事件循环（事件队列） （宏任务和微任务）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AJS%E7%9A%84-%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-%E8%B5%B7%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.15.1.</span> <span class="toc-text">面试题：JS的 同步任务与异步任务 起因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-JS%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88loop-%E6%88%96%E9%98%9F%E5%88%97%EF%BC%89%EF%BC%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F-loop%E5%85%B7%E4%BD%93%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%8F%8F%E8%BF%B0%EF%BC%9F"><span class="toc-number">1.15.2.</span> <span class="toc-text">面试题：什么是 JS的事件循环（loop 或队列），宏任务和微任务的定义？ loop具体的执行机制描述？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">微任务、宏任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEvent-Loop%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">事件循环Event Loop执行机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E7%82%B916%EF%BC%9AJS-%E9%9D%A2%E8%AF%95%E4%BB%A3%E7%A0%81%E9%A2%98%E7%9B%AE"><span class="toc-number">1.16.</span> <span class="toc-text">考点16：JS 面试代码题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajs%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%80%8E%E4%B9%88%E5%8F%96%E4%BA%A4%E9%9B%86-%E5%B7%AE%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86"><span class="toc-number">1.16.1.</span> <span class="toc-text">面试题：js中两个数组怎么取交集+(差集、并集、补集)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%94%A8%E6%AD%A3%E5%88%99%E5%92%8C%E9%9D%9E%E6%AD%A3%E5%88%99%E5%AE%9E%E7%8E%B0123456789-12-%E3%80%8B123-456-789-12"><span class="toc-number">1.16.2.</span> <span class="toc-text">面试题：用正则和非正则实现123456789.12&#x3D;》123,456,789.12</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-%E5%86%99%E4%B8%80%E4%B8%AA%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.3.</span> <span class="toc-text">面试题： 写一个判断是否是空对象的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%80%BC16%E8%BF%9B%E5%88%B6%E8%BD%AC10%E8%BF%9B%E5%88%B6rgb"><span class="toc-number">1.16.4.</span> <span class="toc-text">面试题：颜色值16进制转10进制rgb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96-%E5%B8%B8%E8%80%83"><span class="toc-number">1.16.5.</span> <span class="toc-text">面试题：数组扁平化  常考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%8C%E7%9B%B8%E5%90%8Cvalue%E7%9A%84%E5%8F%AA%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA"><span class="toc-number">1.16.6.</span> <span class="toc-text">面试题：实现一个数组对象的去重，相同value的只保留最后一个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Afunction-rand-min-max-N-%EF%BC%9A%E7%94%9F%E6%88%90%E9%95%BF%E5%BA%A6%E6%98%AFN%EF%BC%8C%E4%B8%94%E5%9C%A8min%E3%80%81max%E5%86%85%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.16.7.</span> <span class="toc-text">面试题：function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%EF%BC%88%E6%89%8B%E5%86%99%EF%BC%89"><span class="toc-number">1.16.8.</span> <span class="toc-text">面试题：字符串中的单词逆序输出（手写）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%AF%B7%E4%BD%A0%E6%89%BE%E5%87%BA%E5%85%B6%E4%B8%AD%E4%B8%8D%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84-%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%E7%9A%84%E9%95%BF%E5%BA%A6-%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%89"><span class="toc-number">1.16.9.</span> <span class="toc-text">面试题：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度   （力扣）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.16.10.</span> <span class="toc-text">面试题：去掉字符串前后的空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%EF%BC%88%E5%8A%9B%E6%89%A3%EF%BC%89"><span class="toc-number">1.16.11.</span> <span class="toc-text">面试题：三数之和  （力扣）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/23/%E5%89%8D%E7%AB%AF%20JS%20%E9%80%89%E6%8B%A9%E9%A2%98%E7%AC%94%E8%AF%95/" title="前端 JS 选择题笔试"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端 JS 选择题笔试"/></a><div class="content"><a class="title" href="/2023/03/23/%E5%89%8D%E7%AB%AF%20JS%20%E9%80%89%E6%8B%A9%E9%A2%98%E7%AC%94%E8%AF%95/" title="前端 JS 选择题笔试">前端 JS 选择题笔试</a><time datetime="2023-03-23T15:52:02.000Z" title="发表于 2023-03-23 23:52:02">2023-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/" title="代码随想录  （题目 与 类型归纳）"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录  （题目 与 类型归纳）"/></a><div class="content"><a class="title" href="/2023/03/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%20%20%EF%BC%88%E9%A2%98%E7%9B%AE%20%E4%B8%8E%20%E7%B1%BB%E5%9E%8B%E5%BD%92%E7%BA%B3%EF%BC%89/" title="代码随想录  （题目 与 类型归纳）">代码随想录  （题目 与 类型归纳）</a><time datetime="2023-03-22T15:52:03.000Z" title="发表于 2023-03-22 23:52:03">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="前端性能优化"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Moren5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端性能优化"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="前端性能优化">前端性能优化</a><time datetime="2023-03-22T15:51:03.000Z" title="发表于 2023-03-22 23:51:03">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="JavaScript 篇（包含ES6）面试题"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/JavaScript.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript 篇（包含ES6）面试题"/></a><div class="content"><a class="title" href="/2023/03/20/JavaScript%20%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98_%E5%87%AF%E5%87%AF%E8%B6%85%E4%BA%BA%E7%89%88%E6%9C%AC/" title="JavaScript 篇（包含ES6）面试题">JavaScript 篇（包含ES6）面试题</a><time datetime="2023-03-20T15:58:01.000Z" title="发表于 2023-03-20 23:58:01">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/VuePurchase%E6%98%93%E8%B4%AD%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="VuePurchase易购平台项目笔记"><img src="http://kyle-pic.oss-cn-hangzhou.aliyuncs.com/img/Vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="VuePurchase易购平台项目笔记"/></a><div class="content"><a class="title" href="/2023/03/20/VuePurchase%E6%98%93%E8%B4%AD%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="VuePurchase易购平台项目笔记">VuePurchase易购平台项目笔记</a><time datetime="2023-03-20T15:55:01.000Z" title="发表于 2023-03-20 23:55:01">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 凯凯超人</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"><script src="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideMobileSidebar.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>